<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>simmyo_z的博客</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://x1nes.github.io/blog/"/>
  <updated>2021-07-19T16:16:42.692Z</updated>
  <id>https://x1nes.github.io/blog/</id>
  
  <author>
    <name>x1nes</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>几个有意思的智力题</title>
    <link href="https://x1nes.github.io/blog/posts/b998d6a0/"/>
    <id>https://x1nes.github.io/blog/posts/b998d6a0/</id>
    <published>2021-07-19T23:06:10.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为了锻炼脑力，避免提前患上老年痴呆症，有必要做一些锻炼思维的智力题。🙂这里不给出答案，答案网上都有，只给一点提示。</p></blockquote><h2 id="1-1000瓶药水找毒药"><a class="header-anchor" href="#1-1000瓶药水找毒药">¶</a>1.1000瓶药水找毒药</h2><p>一道经典题，网上都说是微软面试题，但貌似这几年没见微软考过…</p><p>题目描述如下：</p><p>一共 1000 瓶药水，其中 1 瓶有毒药。<br>已知小白鼠喝毒药一天内死<br>若想在一天内找到毒药，最少需要几只小白鼠？</p><p><strong>关键字：二进制</strong></p><h2 id="2-抢30"><a class="header-anchor" href="#2-抢30">¶</a>2.抢30</h2><p>抢 30 是双人游戏<br>游戏规则是：第一个人喊 “ 1 ”或 “ 2 ”，第二个人要接着往下喊一个或两个数，然后再轮到第一个人。两人轮流进行下去。最后喊 30 的人获胜。问喊数字的最佳策略。</p><p><strong>关键字：bash博弈</strong></p><h2 id="3-三个空瓶子"><a class="header-anchor" href="#3-三个空瓶子">¶</a>3.三个空瓶子</h2><p>有三个空瓶子，一个8L，一个5L，一个3L，目前8L的瓶子装满了牛奶。试问，如果在不浪费一滴水和无刻度的情况下，如何测量出4L的牛奶？</p><p><strong>关键字: 模拟，反推</strong></p><h2 id="4-灯泡开关"><a class="header-anchor" href="#4-灯泡开关">¶</a>4.灯泡开关</h2><p>一个圆环上有 100 个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。 设计一种算法，对于任意初始状态，使所有灯泡全亮。</p><p><strong>关键字：模拟，反推，从全灭可以恢复到全亮。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;为了锻炼脑力，避免提前患上老年痴呆症，有必要做一些锻炼思维的智力题。🙂这里不给出答案，答案网上都有，只给一点提示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-1000瓶药水找毒药&quot;&gt;&lt;a class=&quot;header-anchor&quot; 
      
    
    </summary>
    
    
      <category term="-智力题" scheme="https://x1nes.github.io/blog/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>给博客加上pwa</title>
    <link href="https://x1nes.github.io/blog/posts/b198188b/"/>
    <id>https://x1nes.github.io/blog/posts/b198188b/</id>
    <published>2021-06-08T22:19:28.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给博客加上pwa，断网也可以打开</p></blockquote><h2 id="pwa简介"><a class="header-anchor" href="#pwa简介">¶</a><code>pwa</code>简介</h2><p><code>PWA</code>（<code>Progressive Web Apps</code>，渐进式 <code>Web</code> 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。这些应用无处不在、功能丰富，使其具有与原生应用相同的用户体验优势。这组文档和指南告诉您有关 <code>PWA</code> 的所有信息。</p><h2 id="过程"><a class="header-anchor" href="#过程">¶</a>过程</h2><p>用到了 <code>hexo-pwa</code> 这个插件，在<code>config.yml</code> 里加上配置，会自动生成<code>mainfest.json</code> ,再手动加上<code>sw.js</code>文件。</p><pre><code class="language-yml">pwa:  manifest:    path: manifest.json    body:      name: x1nes      short_name: x1nes      theme_color: white      background_color: white      display: standalone      orientation: portrait      scope: /      start_url: /blog/      icons:        - src: img/logo.png          type: image/png          sizes: 600x600        - src: img/icon-60@2x.png          type: image/png          sizes: 120x120        - src: img/icon-40@2x.png          type: image/png          sizes: 80x80        - src: img/icon-29@2x.png          type: image/png          sizes: 58x58        - src: img/icon-20@2x.png          type: image/png          sizes: 40x40     serviceWorker:    path: /sw.js    preload:      urls:        - /      posts: 5    opts:      networkTimeoutSeconds: 20    routes:      - pattern: !!js/regexp /hm.baidu.com/        strategy: networkOnly      - pattern: !!js/regexp /www.google-analytics.com/        strategy: networkOnly      - pattern: !!js/regexp /pagead2.googlesyndication.com/        strategy: networkOnly      - pattern: !!js/regexp /cdn.jsdelivr.net/        strategy: cacheFirst      - pattern: !!js/regexp /.*\.(js|css|jpg|jpeg|png|gif)$/        strategy: cacheFirst      - pattern: !!js/regexp /\//        strategy: networkFirst  priority: 5</code></pre><p>sw.js</p><pre><code class="language-js">importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js');if (workbox) {    workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' });    workbox.precaching.precache(['/', '/index.html']);    workbox.routing.registerRoute(new RegExp('^https?://x1nes.github.io/?$'), workbox.strategies.networkFirst());    workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst());    workbox.routing.registerRoute(new RegExp('.*.(?:js|css)'), workbox.strategies.staleWhileRevalidate());}</code></pre><p>完成！再次打开页面，就可以看见控制台里<code>application</code>里面的<code>Mainfest</code> 和 <code>service workers</code>里都成功加载了。现在可以把这个网页当作app一样添加到桌面使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;给博客加上pwa，断网也可以打开&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;pwa简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#pwa简介&quot;&gt;¶&lt;/a&gt;&lt;code&gt;pwa&lt;/code&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;co
      
    
    </summary>
    
    
      <category term="pwa" scheme="https://x1nes.github.io/blog/tags/pwa/"/>
    
  </entry>
  
  <entry>
    <title>地球上还剩一个鸡蛋</title>
    <link href="https://x1nes.github.io/blog/posts/11ca1e89/"/>
    <id>https://x1nes.github.io/blog/posts/11ca1e89/</id>
    <published>2021-05-30T21:46:21.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近的内卷话题，突然想到小时候看到的一篇郑渊洁的小说，挺有意思的，这里转载一下。</p></blockquote><h2 id="地球上还剩一个鸡蛋"><a class="header-anchor" href="#地球上还剩一个鸡蛋">¶</a>地球上还剩一个鸡蛋</h2><p>一</p><p>整个鸡家族都不甘心自己在地球上的地位–任人宰割，供人食用。<br>从１００年前起，鸡家族的有识之士就试图摆脱鸡家族的困境。但每次行动都以鸡的失败告终。人类大获全胜，还不断完善着吃鸡的艺术：现代化养鸡场、填鸡、肯德鸡、扒鸡、烧鸡……真是到了炉火纯青的境界。<br>这还不算，鸡被人类吃得最多，可人类却发明出&quot;黄鼠狼给鸡拜年&quot;的成语嫁祸于黄鼠狼，鸡们确实咽不下这口气。<br>鸡王决定在本世纪末之前扭转鸡家族的处境，他召集幕僚想办法。<br>&quot;要想让人类放弃吃鸡很难。&quot;一位幕僚说。他曾经用１０斤鸡蛋收买了人类中一位写东西的人，让他在报上写文章说，吃鸡容易患癌症。人类照吃不误。<br>&quot;依我看，人吃咱们并不是因为恨咱们，而是说明他们离不开咱们。&quot;另一位年纪大一些的幕僚说，他曾经发明过鸡瘟，但被人类用药物治住了。<br>&quot;有道理。&quot;鸡王点头。示意这位慕僚继续往下说。<br>&quot;大王下一道圣旨，命令所有母鸡停止下蛋。保准人类不会再像现在这样对待咱们了。&quot;幕僚建议。<br>&quot;停止下蛋？&quot;鸡王吃了一惊，这可是断子绝孙的举动。<br>&quot;没有鸡蛋，就不会再有新的鸡出生，光这一点，就够人类伤脑筋的。&quot;幕僚说。<br>鸡王点点头。<br>５分钟后，鸡王向整个鸡家族下达了圣旨：停止下蛋。</p><p>二</p><p>当人类发现全世界所有的母鸡都不下蛋了时，地球上只剩下一个鸡蛋了。<br>人类意识到问题的严重性了，地球上的鸡将吃一只少一只，最终灭绝。人们将不再有鸡肉吃，不再有鸡蛋吃。<br>科学家们想尽一切方法动员母鸡们恢复下蛋，什么音乐刺激法啦，红外线紫外线这线那线照射啦，遗撼的是母鸡们不为所动，不管科学家们想出什么绝活儿，她们就是不下蛋。<br>人类专门为此召开了一个紧急会议，会议的结果是制定了一部关于保护珍贵动物–鸡的法律。鸡终于改变了卑微的地位，加入珍贵动物的行列。<br>人们以拥有一只鸡为荣，狗和猫的地位一落千丈。在公园里时常见到牵着鸡散步的达官贵人。一只鸡的售价已高达上千美元。<br>科学家们研制的延长鸡的寿命的药物刚一问世就被抢购一空。有几个国家的国旗上出现了鸡的图案。这一切都因为母鸡不下蛋了。<br>经营炸鸡的快餐店统统倒闭，老板不是跳楼就是离婚。<br>地球上唯一的的那个鸡蛋更是价值连城，光是守护它的军队就有两个旅之多。这个鸡蛋的妈妈是最后一个听到鸡王的圣旨的，当时她正在下蛋，想把这个蛋退回到肚子里已经不可能了，于是她成了地球上唯一的鸡蛋的母亲。<br>她因此身价百倍，人们将延续鸡的生命的期望寄托在她身上，人们把最好的食物给她吃，为她建造了超豪华住宅，还让她上报纸上电视上电影。<br>鸡王的臣民们不再被人类杀戮，不再供人类食用，人类视他们为珍宝。鸡王满意了。</p><p>三</p><p>那个唯一的鸡蛋的母亲的显赫地位渐渐引起了鸡家族成员的注意，他们羡慕她嫉妒她。同样是鸡，为什么她住的房子比同类的好？为什么她的食谱比同类的高级？为什么她能上电视还享有鸡皇后的称号？就因为她生了地球上最后一个鸡蛋！<br>没人甘心比同类活得差。<br>于是，在一个上午，一只母鸡违抗鸡王的圣旨，她公然下了一个蛋。<br>这只母鸡立刻成为全球新闻的焦点，她的待遇立即超过了那只&quot;鸡皇后&quot;。<br>鸡家族受到了强烈的震动。<br>第三个鸡蛋出生了。<br>第四个鸡蛋问世了。<br>第五个鸡蛋降临了。<br>第六个鸡蛋诞辰了。<br>鸡王感到大事不妙，他连降圣旨制止母鸡们下蛋，但他已经控制不了他的臣民了。<br>所有的母鸡都想当鸡皇后，所有的母鸡都想比别的鸡活得好，她们特玩命地下蛋。<br>当鸡蛋的数量多到派不过来军队保护时，人类醒悟到鸡不会灭绝了。人们嘴里出现了口水，他们仿佛又闻到炸鸡的香味了。<br>保护鸡的法律取消了。<br>鸡又重新出现在餐桌上。<br>没人牵着鸡逛公园了。<br>鸡王想再发一道不下蛋的圣旨，幕僚进谏劝住了他。幕僚告诉鸡王，人类已经有了对付鸡不下蛋的办法：他们留出一个鸡蛋，只要鸡们再不下蛋，他们就拼命抬举这个鸡蛋和它的妈妈。<br>鸡家族算是没有出头之日了。鸡王哀叹。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近的内卷话题，突然想到小时候看到的一篇郑渊洁的小说，挺有意思的，这里转载一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;地球上还剩一个鸡蛋&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#地球上还剩一个鸡蛋&quot;&gt;¶&lt;/
      
    
    </summary>
    
    
      <category term="小说" scheme="https://x1nes.github.io/blog/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>redis常见的使用案例</title>
    <link href="https://x1nes.github.io/blog/posts/753a7543/"/>
    <id>https://x1nes.github.io/blog/posts/753a7543/</id>
    <published>2021-05-30T20:15:43.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>redis</code>除了缓存，还有很多的使用方式，互联网项目的很多功能都是通过<code>redis</code>实现的，今天简单介绍一些。</p></blockquote><h2 id="简单回顾下redis是什么"><a class="header-anchor" href="#简单回顾下redis是什么">¶</a>简单回顾下redis是什么</h2><p><code>Redis</code>是一个使用<code>ANSI C</code>编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库。从2015年6月开始，<code>Redis</code>的开发由<code>Redis Labs</code>赞助，而2013年5月至2015年6月期间，其开发由<code>Pivotal</code>赞助。在2013年5月之前，其开发由<code>VMware</code>赞助。根据月度排行网站<code>DB-Engines.com</code>的数据，<code>Redis</code>是最流行的键值对存储数据库。</p><h2 id="redis的特点"><a class="header-anchor" href="#redis的特点">¶</a>redis的特点</h2><ol><li>高性能<br>性能极高 – <code>Redis</code>能读的速度是110000次/s,写的速度是81000次/s 。</li><li>和原生语言无缝的数据结构<br><code>Redis</code>支持二进制案例的 <code>Strings</code>, <code>Lists</code>, <code>Hashes</code>, <code>Sets</code> 及 <code>Ordered Sets</code> 数据类型操作。</li><li>丰富的特性<br>Redis还支持 <code>publish/subscribe</code>, 通知, <code>key</code> 过期等等特性。</li><li>支持持久化<br><code>Redis</code>支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>分布式<br><code>Redis</code>支持数据的备份，即<code>master-slave</code>模式的数据备份。</li><li>高可用<br><code>Redis Sentinel</code> 一个分布式架构，监控各个机器的状态及时作出调整，重新选取主节点。</li></ol><h2 id="五种数据类型和常见用法"><a class="header-anchor" href="#五种数据类型和常见用法">¶</a>五种数据类型和常见用法</h2><h3 id="1-string"><a class="header-anchor" href="#1-string">¶</a>1. <code>string</code></h3><p><code>string</code>在<code>redis</code>里是通过字符数组实现的。你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。value其实不仅是String，也可以是数字。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><h4 id="常见的场景"><a class="header-anchor" href="#常见的场景">¶</a>常见的场景</h4><ol><li><code>json</code>字符串储存缓存</li><li><code>string</code>也可以是一个数字，所以也可以作为计数器，使用<code>INCR</code>命令</li><li><code>redis</code>也支持二进制，所以可以当作一个<code>bitmap</code>,把固定长度的bit位储存数据。</li><li>布隆过滤器，一个很长的二进制向量，作为超大的包含关系的查询。详细点击<a href="https://www.huaweicloud.com/articles/cd70d43549f0a4c36641be61780ab66a.html" target="_blank" rel="noopener">这里</a></li><li>分布式锁，比较复杂，可以看下<a href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/" target="_blank" rel="noopener">这里</a>。</li></ol><p>常用命令：</p><pre><code class="language-bash">  APPEND key value  summary: Append a value to a key  since: 2.0.0  BITCOUNT key [start end]  summary: Count set bits in a string  since: 2.6.0  BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]  summary: Perform arbitrary bitfield integer operations on strings  since: 3.2.0  BITOP operation destkey key [key ...]  summary: Perform bitwise operations between strings  since: 2.6.0  BITPOS key bit [start] [end]  summary: Find first bit set or clear in a string  since: 2.8.7  DECR key  summary: Decrement the integer value of a key by one  since: 1.0.0  DECRBY key decrement  summary: Decrement the integer value of a key by the given number  since: 1.0.0  GET key  summary: Get the value of a key  since: 1.0.0  GETBIT key offset  summary: Returns the bit value at offset in the string value stored at key  since: 2.2.0  GETRANGE key start end  summary: Get a substring of the string stored at a key  since: 2.4.0  GETSET key value  summary: Set the string value of a key and return its old value  since: 1.0.0  INCR key  summary: Increment the integer value of a key by one  since: 1.0.0  INCRBY key increment  summary: Increment the integer value of a key by the given amount  since: 1.0.0  INCRBYFLOAT key increment  summary: Increment the float value of a key by the given amount  since: 2.6.0  MGET key [key ...]  summary: Get the values of all the given keys  since: 1.0.0  MSET key value [key value ...]  summary: Set multiple keys to multiple values  since: 1.0.1  MSETNX key value [key value ...]  summary: Set multiple keys to multiple values, only if none of the keys exist  since: 1.0.1  PSETEX key milliseconds value  summary: Set the value and expiration in milliseconds of a key  since: 2.6.0  SET key value [EX seconds] [PX milliseconds] [NX|XX]  summary: Set the string value of a key  since: 1.0.0  SETBIT key offset value  summary: Sets or clears the bit at offset in the string value stored at key  since: 2.2.0  SETEX key seconds value  summary: Set the value and expiration of a key  since: 2.0.0  SETNX key value  summary: Set the value of a key, only if the key does not exist  since: 1.0.0  SETRANGE key offset value  summary: Overwrite part of a string at key starting at the specified offset  since: 2.2.0  STRLEN key  summary: Get the length of the value stored in a key  since: 2.2.0</code></pre><h3 id="2-hash"><a class="header-anchor" href="#2-hash">¶</a>2. hash</h3><p>Hash 是一个键值(key =&gt; value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。比如储存用户信息。用户id作为key，姓名，年龄，生日等信息可以维护序列化的对象。</p><h4 id="使用场景"><a class="header-anchor" href="#使用场景">¶</a>使用场景</h4><ol><li>存储对象类数据，因此可以存一些结构化的数据，比如购物车，用户基本信息。</li></ol><pre><code class="language-bash">  HDEL key field [field ...]  summary: Delete one or more hash fields  since: 2.0.0  HEXISTS key field  summary: Determine if a hash field exists  since: 2.0.0  HGET key field  summary: Get the value of a hash field  since: 2.0.0  HGETALL key  summary: Get all the fields and values in a hash  since: 2.0.0  HINCRBY key field increment  summary: Increment the integer value of a hash field by the given number  since: 2.0.0  HINCRBYFLOAT key field increment  summary: Increment the float value of a hash field by the given amount  since: 2.6.0  HKEYS key  summary: Get all the fields in a hash  since: 2.0.0  HLEN key  summary: Get the number of fields in a hash  since: 2.0.0  HMGET key field [field ...]  summary: Get the values of all the given hash fields  since: 2.0.0  HMSET key field value [field value ...]  summary: Set multiple hash fields to multiple values  since: 2.0.0  HSCAN key cursor [MATCH pattern] [COUNT count]  summary: Incrementally iterate hash fields and associated values  since: 2.8.0  HSET key field value  summary: Set the string value of a hash field  since: 2.0.0  HSETNX key field value  summary: Set the value of a hash field, only if the field does not exist  since: 2.0.0  HSTRLEN key field  summary: Get the length of the value of a hash field  since: 3.2.0  HVALS key  summary: Get all the values in a hash  since: 2.0.0</code></pre><h3 id="3-list"><a class="header-anchor" href="#3-list">¶</a>3. list</h3><p>list 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>可以作为一个简单的消息队列。</p><h4 id="使用场景-v2"><a class="header-anchor" href="#使用场景-v2">¶</a>使用场景</h4><ol><li>简易消息队列，右(左)边进左(右)边出，用来消费队列里的信息。但是ack机制麻烦，复杂场景还是使用专业的mq。</li><li>作为栈使用，支持右(左)边进右(左)边出。</li><li>用于储存线性数据，比如某个人的关注列表。文章点赞的人的id。</li></ol><pre><code class="language-bash">  BLPOP key [key ...] timeout  summary: Remove and get the first element in a list, or block until one is available  since: 2.0.0  BRPOP key [key ...] timeout  summary: Remove and get the last element in a list, or block until one is available  since: 2.0.0  BRPOPLPUSH source destination timeout  summary: Pop a value from a list, push it to another list and return it; or block until one is available  since: 2.2.0  LINDEX key index  summary: Get an element from a list by its index  since: 1.0.0  LINSERT key BEFORE|AFTER pivot value  summary: Insert an element before or after another element in a list  since: 2.2.0  LLEN key  summary: Get the length of a list  since: 1.0.0  LPOP key  summary: Remove and get the first element in a list  since: 1.0.0  LPUSH key value [value ...]  summary: Prepend one or multiple values to a list  since: 1.0.0  LPUSHX key value  summary: Prepend a value to a list, only if the list exists  since: 2.2.0  LRANGE key start stop  summary: Get a range of elements from a list  since: 1.0.0  LREM key count value  summary: Remove elements from a list  since: 1.0.0  LSET key index value  summary: Set the value of an element in a list by its index  since: 1.0.0  LTRIM key start stop  summary: Trim a list to the specified range  since: 1.0.0  RPOP key  summary: Remove and get the last element in a list  since: 1.0.0  RPOPLPUSH source destination  summary: Remove the last element in a list, prepend it to another list and return it  since: 1.2.0  RPUSH key value [value ...]  summary: Append one or multiple values to a list  since: 1.0.0  RPUSHX key value  summary: Append a value to a list, only if the list exists  since: 2.2.0</code></pre><h3 id="4-set"><a class="header-anchor" href="#4-set">¶</a>4. set</h3><p>set 是string类型的无序集合。集合是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。所以添加，删除，查找的复杂度都是O(1)。</p><h3 id="使用场景-v3"><a class="header-anchor" href="#使用场景-v3">¶</a>使用场景</h3><ol><li>去重，多台服务可以放在一个set里去重。</li><li>redis 提供了求交集、并集、差集的操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能。</li></ol><pre><code class="language-bash">  SADD key member [member ...]  summary: Add one or more members to a set  since: 1.0.0  SCARD key  summary: Get the number of members in a set  since: 1.0.0  SDIFF key [key ...]  summary: Subtract multiple sets  since: 1.0.0  SDIFFSTORE destination key [key ...]  summary: Subtract multiple sets and store the resulting set in a key  since: 1.0.0  SINTER key [key ...]  summary: Intersect multiple sets  since: 1.0.0  SINTERSTORE destination key [key ...]  summary: Intersect multiple sets and store the resulting set in a key  since: 1.0.0  SISMEMBER key member  summary: Determine if a given value is a member of a set  since: 1.0.0  SMEMBERS key  summary: Get all the members in a set  since: 1.0.0  SMOVE source destination member  summary: Move a member from one set to another  since: 1.0.0  SPOP key [count]  summary: Remove and return one or multiple random members from a set  since: 1.0.0  SRANDMEMBER key [count]  summary: Get one or multiple random members from a set  since: 1.0.0  SREM key member [member ...]  summary: Remove one or more members from a set  since: 1.0.0  SSCAN key cursor [MATCH pattern] [COUNT count]  summary: Incrementally iterate Set elements  since: 2.8.0  SUNION key [key ...]  summary: Add multiple sets  since: 1.0.0  SUNIONSTORE destination key [key ...]  summary: Add multiple sets and store the resulting set in a key  since: 1.0.0</code></pre><h3 id="5-sorted-set"><a class="header-anchor" href="#5-sorted-set">¶</a>5. sorted_set</h3><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 *zadd 命令：*添加元素到集合，元素在集合中存在则更新对应score。set是有序的，根据<code>score</code>排序。</p><h3 id="使用场景-v4"><a class="header-anchor" href="#使用场景-v4">¶</a>使用场景</h3><ol><li>因为自带排序，显示最新的项目列表 ，排行榜相关。</li><li>处理过期项目，比如处理没付款的订单。根据下单时间放进<code>sorted_set</code>，后台任务根据<code>ZRANGE</code>查最近的几条数据，如果过期再回写到数据库。</li></ol><pre><code class="language-bash">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]  summary: Add one or more members to a sorted set, or update its score if it already exists  since: 1.2.0  ZCARD key  summary: Get the number of members in a sorted set  since: 1.2.0  ZCOUNT key min max  summary: Count the members in a sorted set with scores within the given values  since: 2.0.0  ZINCRBY key increment member  summary: Increment the score of a member in a sorted set  since: 1.2.0  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]  summary: Intersect multiple sorted sets and store the resulting sorted set in a new key  since: 2.0.0  ZLEXCOUNT key min max  summary: Count the number of members in a sorted set between a given lexicographical range  since: 2.8.9  ZRANGE key start stop [WITHSCORES]  summary: Return a range of members in a sorted set, by index  since: 1.2.0  ZRANGEBYLEX key min max [LIMIT offset count]  summary: Return a range of members in a sorted set, by lexicographical range  since: 2.8.9  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]  summary: Return a range of members in a sorted set, by score  since: 1.0.5  ZRANK key member  summary: Determine the index of a member in a sorted set  since: 2.0.0  ZREM key member [member ...]  summary: Remove one or more members from a sorted set  since: 1.2.0  ZREMRANGEBYLEX key min max  summary: Remove all members in a sorted set between the given lexicographical range  since: 2.8.9  ZREMRANGEBYRANK key start stop  summary: Remove all members in a sorted set within the given indexes  since: 2.0.0  ZREMRANGEBYSCORE key min max  summary: Remove all members in a sorted set within the given scores  since: 1.2.0  ZREVRANGE key start stop [WITHSCORES]  summary: Return a range of members in a sorted set, by index, with scores ordered from high to low  since: 1.2.0  ZREVRANGEBYLEX key max min [LIMIT offset count]  summary: Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.  since: 2.8.9  ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]  summary: Return a range of members in a sorted set, by score, with scores ordered from high to low  since: 2.2.0  ZREVRANK key member  summary: Determine the index of a member in a sorted set, with scores ordered from high to low  since: 2.0.0  ZSCAN key cursor [MATCH pattern] [COUNT count]  summary: Incrementally iterate sorted sets elements and associated scores  since: 2.8.0  ZSCORE key member  summary: Get the score associated with the given member in a sorted set  since: 1.2.0  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]  summary: Add multiple sorted sets and store the resulting sorted set in a new key  since: 2.0.0</code></pre><h2 id="其他功能"><a class="header-anchor" href="#其他功能">¶</a>其他功能</h2><ol><li>Pub/Sub<br>Redis的Pub/Sub非常非常简单，运行稳定并且快速。可以作为发布订阅使用。<br>2.<code>geo</code><br>储存地理坐标数据，用来实现附近的人功能。</li><li>HyperLogLog<br><code>Redis HyperLogLog</code> 是用来做基数统计的算法，<code>HyperLogLog</code> 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。<br>在 <code>Redis</code> 里面，每个 <code>HyperLogLog</code> 键只需要花费 <code>12 KB</code> 内存，就可以计算接近 <code>2^64</code> 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;redis&lt;/code&gt;除了缓存，还有很多的使用方式，互联网项目的很多功能都是通过&lt;code&gt;redis&lt;/code&gt;实现的，今天简单介绍一些。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简单回顾下redis是什么&quot;&gt;&lt;a c
      
    
    </summary>
    
    
      <category term="redis" scheme="https://x1nes.github.io/blog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷到500题，我决定从头开始学习算法</title>
    <link href="https://x1nes.github.io/blog/posts/cec8bc39/"/>
    <id>https://x1nes.github.io/blog/posts/cec8bc39/</id>
    <published>2021-05-05T01:21:09.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>算法刷到500道，我决定暂停一下</p></blockquote><h2 id="截图留念"><a class="header-anchor" href="#截图留念">¶</a>截图留念</h2><p><img src="./1.PNG" alt="截图纪念"></p><h2 id="几个周赛题-我被虐了"><a class="header-anchor" href="#几个周赛题-我被虐了">¶</a>几个周赛题，我被虐了</h2><p>刷了这么多，我感觉自己膨胀了，可以参加周赛了，于是打了几场，结果惨不忍睹，最好的一次做了三道题，平均两道题，有时只能做出来一道。<br>让我伤心的是不是题目有多难，而是结束后看了下别人的答案，原来这么简单，一点都不难，都是很简单的逻辑，但是我就是没想到，这些题有些甚至是我做过的原题，只是换了一个表达方式，把他应用到了实际的场景中，我就想不到怎么解决了😭。但是一旦想明白要干什么，才发现原来是做过的原题。</p><h2 id="我缺乏什么"><a class="header-anchor" href="#我缺乏什么">¶</a>我缺乏什么</h2><p>第一：透过现象看本质，这一点我十分确认和智商有关系，数学家可以把复杂的显示世界用公式描述，编程高手可以用代码实现复杂的系统设计。著名的物理学家、电机专家斯坦门茨的画一条线，1美元；<br>知道在哪儿画线，9999美元的故事大家也都清楚，天赋固然重要，但是大部分人的努力程度还不到拼天赋的的地步，智商也许可以决定上限，努力和勤奋更能决定下限，只有不断的练习，激发自己对未知领域的试探，我相信自己也能解开层层面纱，看到题目纷繁条件下的细枝末节🧐。</p><p>第二：对数据结构的理解和使用场景不到位。日常工作中，使用复杂数据结构的场景其实不多，前端业务代码往往并不复杂，因此很多数据结构还没熟悉到，下一步定个目标，一周真正学会一个数据结构。</p><p>第三：我想，刷力扣，高中的数学知识应该差不多了，但其实，离散和线性代数如果熟练的话，更好。现在要再复习下一些基本的数学知识。</p><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>每日一题还要坚持下去，但是不会花大时间漫无目的的刷题了，接下来的目标是学习以下的数据结构。目前在看的一本书是《算法》第四版。</p><p>栈/单调栈，队列/单调队列，链表，哈希表，堆，二叉树/二叉搜索树/平衡树，跳表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;算法刷到500道，我决定暂停一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;截图留念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#截图留念&quot;&gt;¶&lt;/a&gt;截图留念&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;./1.PNG&quot; 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://x1nes.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跨页面通信的几种方法</title>
    <link href="https://x1nes.github.io/blog/posts/97160c27/"/>
    <id>https://x1nes.github.io/blog/posts/97160c27/</id>
    <published>2021-04-14T23:40:07.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原来，跨页面通信有这这么多方法</p></blockquote><h2 id="同源页面之间的通信"><a class="header-anchor" href="#同源页面之间的通信">¶</a>同源页面之间的通信</h2><h3 id="localstorage"><a class="header-anchor" href="#localstorage">¶</a>localStorage</h3><p>这个大家都很熟悉了，但是他还有一个storage事件，之前没接触过<br>当 LocalStorage 变化时，会触发storage事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听storage事件即可收到通知。</p><pre><code class="language-js">// 一个页面监听事件window.addEventListener('storage', function (e) {    if (e.key === 'ctc-msg') {        const data = JSON.parse(e.newValue);        const text = '[receive] ' + data.msg + ' —— tab ' + data.from;        console.log('[Storage I] receive message:', text);    }});// 另外一个页面set数据，这里加上事件戳是因为只有真正改变才会触发storagemydata.st = +(new Date);window.localStorage.setItem('ctc-msg', JSON.stringify(mydata));</code></pre><h3 id="indexeddb"><a class="header-anchor" href="#indexeddb">¶</a>IndexedDB</h3><p>不多介绍了，就是简单的轮询</p><h3 id="service-worker"><a class="header-anchor" href="#service-worker">¶</a>Service Worker</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service workers</a> 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用采取来适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。<br>Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们会使用轮询的方式，来拉取最新的数据。思路如下：<br>让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过postMessage传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：<br>首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：</p><pre><code class="language-JS">// 构造函数的第二个参数是 Shared Worker 名称，也可以留空const sharedWorker = new SharedWorker('../util.shared.js', 'ctc');</code></pre><p>然后，在该 Shared Worker 中支持 get 与 post 形式的消息：</p><pre><code class="language-js">/* ../util.shared.js: Shared Worker 代码 */let data = null;self.addEventListener('connect', function (e) {    const port = e.ports[0];    port.addEventListener('message', function (event) {        // get 指令则返回存储的消息数据        if (event.data.get) {            data &amp;&amp; port.postMessage(data);        }        // 非 get 指令则存储该消息数据        else {            data = event.data;        }    });    port.start();});</code></pre><p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：</p><pre><code class="language-js">// 定时轮询，发送 get 指令的消息setInterval(function () {    sharedWorker.port.postMessage({get: true});}, 1000);// 监听 get 消息的返回数据sharedWorker.port.addEventListener('message', (e) =&gt; {    const data = e.data;    const text = '[receive] ' + data.msg + ' —— tab ' + data.from;    console.log('[Shared Worker] receive message:', text);}, false);sharedWorker.port.start();</code></pre><p>最后，当要跨页面通信时，只需给 Shared Worker postMessage即可：</p><pre><code class="language-js">sharedWorker.port.postMessage(mydata);</code></pre><p>注意，如果使用addEventListener来添加 Shared Worker 的消息监听，需要显式调用MessagePort.start方法，即上文中的sharedWorker.port.start()；如果使用onmessage绑定监听则不需要。</p><h3 id="broadcast-channel"><a class="header-anchor" href="#broadcast-channel">¶</a>BroadCast Channel</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Broadcast_Channel_API" target="_blank" rel="noopener">Broadcast Channel API</a> 可以实现同 源 下浏览器不同窗口，Tab页，frame或者 iframe 下的 浏览器上下文 (通常是同一个网站下不同的页面)之间的简单通讯。</p><p>简单的api展示：</p><pre><code class="language-js">// 连接到广播频道,在多个页面注册同一个频道var bc = new BroadcastChannel('test_channel');// 发送简单消息的示例bc.postMessage('This is a test message.');// 简单示例，用于将事件打印到控制台bc.onmessage = function (ev) { console.log(ev); }// 断开频道连接bc.close()</code></pre><h2 id="非同源页面之间的通信"><a class="header-anchor" href="#非同源页面之间的通信">¶</a>非同源页面之间的通信</h2><h3 id="利用中间iframe作为brideg"><a class="header-anchor" href="#利用中间iframe作为brideg">¶</a>利用中间iframe作为brideg</h3><p>使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定origin来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：<a href="http://sample.com/bridge.html%EF%BC%89%EF%BC%8C%E8%80%8C%E8%BF%99%E4%BA%9B" target="_blank" rel="noopener">http://sample.com/bridge.html），而这些</a> iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。</p><pre><code class="language-js">/* 业务页面代码 */window.addEventListener('message', function (e) {    // …… do something});/* 业务页面代码发信息 */window.frames[0].window.postMessage(mydata, '*');</code></pre><h3 id="利用websocket"><a class="header-anchor" href="#利用websocket">¶</a>利用websocket</h3><p>利用后端新开一个websocket服务，多个页面都接受服务端的推送，也可以实现同步状态。</p><hr><p>原文地址，本文稍作删改：<br><a href="https://juejin.cn/post/6844903811232825357" target="_blank" rel="noopener">https://juejin.cn/post/6844903811232825357</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原来，跨页面通信有这这么多方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;同源页面之间的通信&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#同源页面之间的通信&quot;&gt;¶&lt;/a&gt;同源页面之间的通信&lt;/h2&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="javaScript" scheme="https://x1nes.github.io/blog/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch使用</title>
    <link href="https://x1nes.github.io/blog/posts/5e47ac86/"/>
    <id>https://x1nes.github.io/blog/posts/5e47ac86/</id>
    <published>2021-04-11T23:38:41.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一次将千万级别的数据库表迁移到Elasticsearch 的过程</p></blockquote><h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2><p>我们有一张千万级别，并且每天都新增将近万条数据，更新也在十几万的业务表，这个业务表可以说是我们的核心业务，因为历史问题，表字段除了基本的字段外，还存了json， 一个字符串可代表多业务， 甚至存了二进制的对象， 同时，我们的运营页面需要根据将近20个查询条件对这个表进行查询，一方面因为数据量大，多个查询条件组合起来，查出数据有时也要十几秒，甚至在一些极端情况下，页面直接超时，用户体验很不好，另一方面，有些字段隐藏在json内部，或者二进制的对象里面，限制了其作为查询条件。</p><h2 id="预研"><a class="header-anchor" href="#预研">¶</a>预研</h2><p>于是我花了两天的时间了解了Elasticsearch 是什么，可以做什么，大概的操作步骤，查询api，以及配套的生态，又花了一天在测试环境搭建了一套elk，就开始了迁移的测试。<br>ps：在这里说明一下<br>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。<br>Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。<br>Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志<br>elk当然就是这三部分的组合了。</p><h2 id="用logstash-同步数据"><a class="header-anchor" href="#用logstash-同步数据">¶</a>用logstash 同步数据</h2><p>logstash 本身的配置也不复杂，分为<code>input</code>，<code>filter</code>，<code>output</code> 三部分。<br><code>input</code> 和 <code>output</code>支持各种插件。<br>比如<code>input</code> 支持 <code>mysql</code>，<code>file</code>，<code>http</code>，等等，最新的<code>input</code> 甚至支持<code>Twitter</code>。<br><code>output</code> 支持 <code>elasticsearch</code>，<code>email</code>，<code>rabbitmq</code>等等。<br>查看所有支持的插件可以点击<a href="https://www.elastic.co/guide/en/logstash/7.12/introduction.html" target="_blank" rel="noopener">这里</a></p><p>这一步本来是很简单的，因为logstash 本身就支持同步mysql数据到es，只需要简单的配置，加上json的中间filter，就可以完成了，但是就是二进制的数据对象要解析出来有点麻烦，还好logstash支持用ruby作为脚本，于是就需要编写一个ruby脚本，把从mysql里读出来的二进制转化成对象，我们存的二进制是protobuf转化的对象，因此，需要用一个protobuf的库 把二进制转成ruby对象，然后在解析这个对象，分割成不同的字段存入es。<br>首先，我从内部的平台，下载了原始的protobuf文件，然后在公司的编译机上，便成ruby的class文件，但是怎么从二进制解码到对象呢？我又翻看了下logstash的文档，发现他有一个codec的插件是直接支持解码pb对象的，但是这个插件只支持每次解析一行，但是我从mysql读出来的数据，是一行sql插叙结果，里面只有几个字段是二进制的，于是我找到了这个插件<code>logstash-codec-protobuf</code>的github<a href="https://github.com/logstash-plugins/logstash-codec-protobuf" target="_blank" rel="noopener">地址</a>，简单看了下源码和<code>api</code>，源码不多加上注释也才700多行，虽然没学过ruby但也大概看出来一些逻辑，看了下他的依赖，</p><pre><code class="language-ruby">require 'logstash/codecs/base'require 'logstash/util/charset'require 'google/protobuf' # for protobuf3require 'protocol_buffers' # https://github.com/codekitchen/ruby-protocol-buffers, for protobuf2</code></pre><p>主要起作用的应该是</p><pre><code class="language-ruby">require 'google/protobuf' # for protobuf3require 'protocol_buffers</code></pre><p>整个代码是一个面向对象的语法， 定义了一个class</p><pre><code class="language-ruby">class LogStash::Codecs::Protobuf &lt; LogStash::Codecs::Base</code></pre><p>里面有<code>register</code>,<code>decode</code>,<code>encode</code> 等方法，看来起作用的就是<code>decode</code> 了，马上拿来放在脚本里面跑了一下，成功从二进制解析得到了ruby对象。</p><p>接下来就简单了，注意细节，对照字段开始同步。大概花了25个小时，就把所有的数据同步到了es,增量的数据，我用<code>updatetime</code>作为查询条件更新。</p><h2 id="用php客户端查询数据"><a class="header-anchor" href="#用php客户端查询数据">¶</a>用php客户端查询数据</h2><p>最后，我用php客户端，通过http调用的形式，使用es查询语法，对数据进行查询，果然快了很多，复杂的查询条件，也能在1s左右查询出来。</p><p>这里要说明的是<code>kibana</code>里面有个devtool的页面，可以在里面写查询语句验证结果，使用起来十分方便。</p><h2 id="遇到的坑"><a class="header-anchor" href="#遇到的坑">¶</a>遇到的坑</h2><p>主要是分页查询的时候，很大的数据量下不能以一般的查询语法，即from to 这种，因为在深度分页的情况下，这种使用方式效率是非常低的，比如from = 5000, size=10， es 需要在各个分片上匹配排序并得到5000*10条有效数据，然后在结果集中取最后10条数据返回。</p><p>我们就遇到了这个问题，先把<code>max_result_window</code>调大了一些，后来用深度分页代替：<br>es 提供了 <code>Scroll API</code> 的方式进行分页读取。原理上是对某次查询生成一个游标 scroll_id ， 后续的查询只需要根据这个游标去取数据，直到结果集中返回的 hits 字段为空，就表示遍历结束。scroll_id 的生成可以理解为建立了一个临时的历史快照，在此之后的增删改查等操作不会影响到这个快照的结果。<br>但是这个也不允许随机跳页，适合类似微博那种下拉翻页的场景。</p><p>ps: 关于深度分页优化可以看下<a href="https://juejin.cn/post/6850037275456339975" target="_blank" rel="noopener">这里</a></p><h2 id="elk很复杂的"><a class="header-anchor" href="#elk很复杂的">¶</a>elk很复杂的</h2><p>虽然基本符合了使用场景，但是关于elk我感觉还是只了解了皮毛，如何优化，怎么关联查询，怎么设置索引结构更高效，更复杂的查询语句，这些都还没接触到。<br>ps: 网上很多关于性能优化的文章，比如<a href="https://zhuanlan.zhihu.com/p/67362440" target="_blank" rel="noopener">这篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录一次将千万级别的数据库表迁移到Elasticsearch 的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;¶&lt;/a&gt;背景&lt;/h2&gt;
&lt;p&gt;我们有一张千万
      
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="https://x1nes.github.io/blog/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>2道算法题的优化过程</title>
    <link href="https://x1nes.github.io/blog/posts/7e570359/"/>
    <id>https://x1nes.github.io/blog/posts/7e570359/</id>
    <published>2021-04-08T23:38:41.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近刷了那么多的算法,感觉自己刚刚有点进步,又被两道简单题搞晕了🙃🙃,彻底暴露了自己对时间复杂度掌握不足的遗漏,因此在这里记录下优化的过程.</p></blockquote><h3 id="第一题"><a class="header-anchor" href="#第一题">¶</a>第一题</h3><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1：</p><p>输入：nums = [1,1,1,2,2,3]<br>输出：5, nums = [1,1,2,2,3]<br>解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p><p>输入：nums = [0,0,1,1,1,1,2,3,3]<br>输出：7, nums = [0,0,1,1,2,3,3]<br>解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。<br>一看到题目,觉得不难,马上开始写代码,就模拟整个过程,几分钟搞定.</p><pre><code class="language-javaScript">var removeDuplicates = function(nums) {        let len = nums.length    let last = nums[len-1]    let count = 1    for(let i = nums.length-2;i&gt;=0;i--) {        if(nums[i] === last) {            count++            if(count&gt;2) {                len--                for(let j = i;j&lt;len;j++) {                    nums[j] = nums[j+1]                }            }        }else {            count = 1            last = nums[i]        }       }    return len};</code></pre><p>刚好这几天几个同事都在打卡每日一题,我们交流了一下,我把自己的代码给同事看了看,一个同事立马说,你这个时间复杂度太高了,我仔细看了看代码,确实,循环里面移动数组,大概复杂度O(n^2).</p><p>听了同事的的解法,我顿悟了,原来双指针就好了,快慢指针,慢指针保持长度,快指针每次+1用来检查后面的元素,遇到不同的元素,并且前方已经出现了两个重复的,就覆盖前方慢指针的元素,然后慢指针继续+1</p><p>下面是代码:</p><pre><code class="language-javaScript">var removeDuplicates = function(nums) {    let n = nums.length    if(n&lt;2) {        return n    }    let slow = 2    let fast = 2        while(fast&lt;n) {        if(nums[slow-2] !== nums[fast]) {            nums[slow] = nums[fast]            slow++        }        fast++    }        return slow};</code></pre><p>这样时间复杂度就被优化到了O(n),只遍历了一边.<br>经过自己的测试,在长度为999999,三个一组相同的数组的运行测试下,第二种花费大概3ms,而第一种,居然用了100000+ms,相差了3万倍!!!🤯 🤯 🤯 🤯 🤯</p><h3 id="第二题"><a class="header-anchor" href="#第二题">¶</a>第二题</h3><p>小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。</p><p>注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1<br>示例 1：</p><p>输入：nums = [2,5,3,5], target = 6</p><p>输出：1</p><p>解释：预算内仅能购买 nums[0] 与 nums[2]。</p><p>示例 2：</p><p>输入：nums = [2,2,1,9], target = 10</p><p>输出：4</p><p>解释：符合预算的采购方案如下：<br>nums[0] + nums[1] = 4<br>nums[0] + nums[2] = 3<br>nums[1] + nums[2] = 3<br>nums[2] + nums[3] = 10</p><p>第一眼看到这个题,心想这么简单的吗?<br>立马又是双层循环遍历一边,果不其然超时了,一看给的测试用例,长度 <code>2 &lt;= nums.length &lt;= 10^5</code><br>考虑到没有负数,于是加了个判断第一个数的长度是否大于target,然而还是超时.<br>想了想,先排下顺序吧,然后二分找到小于target的部分,在这个范围内判断,后来又想,如果target很大怎么办?不还是要遍历很多次吗?<br>想啊想,死掉n个脑细胞,m根头发后,我明白了,在一个顺序的数组里,如果下标i和下标j满足小于target,那么i和其他小于j的其他组合都满足,这个个数是(j-i)个,然后i++继续判断就行了,如果大于target了,就大数的下标,j 向左移动j-- 就行了. 想明白后,才发现已经过去1个小时了.马上动手写代码</p><pre><code class="language-javaScript">var purchasePlans = function(nums, target) {    const MOD = 1000000007    nums.sort((a,b) =&gt; a-b)    let i = 0    let  j = nums.length-1    let res = 0    while(i&lt;j) {        if(nums[i] + nums[j] &lt;= target) {            res+=j-i            res = res%MOD            i++        }else {            j--        }    }    return res};</code></pre><p>这样就O(n)了,同时,不要忘了模MOD.</p><p>注意时间复杂度,不要再写低效率的代码了💪💪💪💪💪</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近刷了那么多的算法,感觉自己刚刚有点进步,又被两道简单题搞晕了🙃🙃,彻底暴露了自己对时间复杂度掌握不足的遗漏,因此在这里记录下优化的过程.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第一题&quot;&gt;&lt;a class=&quot;header-anc
      
    
    </summary>
    
    
      <category term="算法" scheme="https://x1nes.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浏览器兼容性问题</title>
    <link href="https://x1nes.github.io/blog/posts/fe80343/"/>
    <id>https://x1nes.github.io/blog/posts/fe80343/</id>
    <published>2021-04-07T21:23:44.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个记录日常结局浏览器兼容问题的备忘录</p></blockquote><ol><li>如何查看某个javaScript 对象或者css 属性的兼容性</li></ol><p>到MND搜索需要查看的内容,页面底部提供一份不同平台(比如PC端,手机端,node端)以及不同浏览器进行和其各个历史版本的兼容表格,可以很直观的看到你要用的技术是否支持业务覆盖的浏览器或者平台.</p><ol start="2"><li>浏览器强制用webkit内核<br>国内部分双核浏览器如：360极速浏览器、搜狗浏览器、百度浏览器等等，这些浏览器都号称拥有两个内核，用户可以根据需要自由切换。双核浏览器的2个内个分别为极速内核（webkit内核），兼容内核（trident内核）。使用极速内核浏览器会按照w3c的新标准渲染页面，其结果是渲染速度更快，规范性更好。而兼容内核也并非一无是处，国内很多政府、银行类网站在编写之初考虑了兼容旧版本ie的trident内核，其代码并非为w3c规范的标准，而是浏览器厂商自定义的模式，这类网站则必须使用兼容模式打开，如果使用极速模式打开就会产生布局错乱等问题。</li></ol><p>可以用下面的标签强制浏览器使用极速内核:</p><meta name="renderer" content="webkit"><p>也可以使用兼容的写法:</p><meta name="renderer" content="webkit|ie-comp|ie-stand">这里会根据先后顺序,启用支持的内核,不支持也不会<ol start="3"><li>重置样式<br>不同的浏览器之间基本样式很不一样，比如IE浏览器使用ie盒子模型，现代浏览器大多使用标准盒子模型。他们之间的宽度计算很不一样。<br>这个时候就需要用reset.css重置一下样式了</li></ol><pre><code class="language-css">@charset &quot;utf-8&quot;;/* CSS Document */html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, font, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td {    margin: 0;    padding: 0;    border: 0;    outline: 0;    font-size: 100%;    vertical-align: baseline;    background: transparent;}body {    line-height: 1;}ol, ul {    list-style: none;}blockquote, q {    quotes: none;}blockquote:before, blockquote:after,q:before, q:after {    content: '';    content: none;}/* remember to define focus styles! */:focus {    outline: 0;}/* remember to highlight inserts somehow! */ins {    text-decoration: none;}del {    text-decoration: line-through;}/* tables still need 'cellspacing=&quot;0&quot;' in the markup */table {    border-collapse: collapse;    border-spacing: 0;}/* 清除浮动 */.clearfloat:after{display:block;clear:both;content:&quot;&quot;;visibility:hidden; height:0;} .clearfloat{zoom:1} </code></pre><ol start="4"><li>浏览器类型判断</li></ol><pre><code class="language-javaScript">// 浏览器类型判断function browserType () {    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串    var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器    var isIE = window.ActiveXObject || &quot;ActiveXObject&quot; in window    var isEdge = userAgent.indexOf(&quot;Edge&quot;) &gt; -1; //判断是否IE的Edge浏览器    var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器    var isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Chrome&quot;) == -1; //判断是否Safari浏览器    var isChrome = userAgent.indexOf(&quot;Chrome&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; !isEdge; //判断Chrome浏览器    if (isIE) {        var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;);        reIE.test(userAgent);        var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]);        if (userAgent.indexOf('MSIE 6.0') != -1) {            return &quot;IE6&quot;;        } else if (fIEVersion == 7) {            return &quot;IE7&quot;;        }        else if (fIEVersion == 8) {            return &quot;IE8&quot;;        }        else if (fIEVersion == 9) {            return &quot;IE9&quot;;        }        else if (fIEVersion == 10) {            return &quot;IE10&quot;;        }        else if (userAgent.toLowerCase().match(/rv:([\d.]+)\) like gecko/)) {            return &quot;IE11&quot;;        }        else {            return &quot;0&quot;        }//IE版本过低    }    if (isFF) {        return &quot;FF&quot;;    }    if (isOpera) {        return &quot;Opera&quot;;    }    if (isSafari) {        return &quot;Safari&quot;;    }    if (isChrome) {        return &quot;Chrome&quot;;    }    if (isEdge) {        return &quot;Edge&quot;;    }}</code></pre><ol start="5"><li>html if 判断浏览器ie版本</li></ol><pre><code class="language-html">&lt;!--[if !IE]&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt;</code></pre><p>~~未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一个记录日常结局浏览器兼容问题的备忘录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如何查看某个javaScript 对象或者css 属性的兼容性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到MND搜索需要查看的内容,页面底部提供一份不同平台(比如PC
      
    
    </summary>
    
    
      <category term="html" scheme="https://x1nes.github.io/blog/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>promiseA+</title>
    <link href="https://x1nes.github.io/blog/posts/d721f59f/"/>
    <id>https://x1nes.github.io/blog/posts/d721f59f/</id>
    <published>2021-04-06T23:36:55.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript Promise A+ 规范</p></blockquote><p>译者序：一年前曾译过 Promise/A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知这样一篇拙译，一年之间竟然点击数千，成为谷歌搜索的头条。今日在理解之后重译此规范，以飨读者。</p><p>一个开放、健全且通用的 JavaScript Promise 标准。由开发者制定，供开发者参考。</p><p>译文术语:</p><p>解决（fulfill）：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。</p><p>拒绝（reject）：指一个 promise 失败时进行的一系列操作。</p><p>终值（eventual value）：所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</p><p>据因（reason）：也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。</p><p>实现:</p><pre><code class="language-javaScript">/** * Promise 实现 遵循promise/A+规范 * Promise/A+规范译文: * https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4 */// promise 三个状态const PENDING = &quot;pending&quot;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;function Promise(excutor) {    let that = this; // 缓存当前promise实例对象    that.status = PENDING; // 初始状态    that.value = undefined; // fulfilled状态时 返回的信息    that.reason = undefined; // rejected状态时 拒绝的原因    that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数    that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数    function resolve(value) { // value成功态时接收的终值        if (value instanceof Promise) {            return value.then(resolve, reject);        }        // 为什么resolve 加setTimeout?        // 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行.        // 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。        setTimeout(() =&gt; {            // 调用resolve 回调对应onFulfilled函数            if (that.status === PENDING) {                // 只能由pedning状态 =&gt; fulfilled状态 (避免调用多次resolve reject)                that.status = FULFILLED;                that.value = value;                that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value));            }        });    }    function reject(reason) { // reason失败态时接收的拒因        setTimeout(() =&gt; {            // 调用reject 回调对应onRejected函数            if (that.status === PENDING) {                // 只能由pedning状态 =&gt; rejected状态 (避免调用多次resolve reject)                that.status = REJECTED;                that.reason = reason;                that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason));            }        });    }    // 捕获在excutor执行器中抛出的异常    // new Promise((resolve, reject) =&gt; {    //     throw new Error('error in excutor')    // })    try {        excutor(resolve, reject);    } catch (e) {        reject(e);    }}/** * resolve中的值几种情况： * 1.普通值 * 2.promise对象 * 3.thenable对象/函数 *//** * 对resolve 进行改造增强 针对resolve中不同值情况 进行处理 * @param  {promise} promise2 promise1.then方法返回的新的promise对象 * @param  {[type]} x         promise1中onFulfilled的返回值 * @param  {[type]} resolve   promise2的resolve方法 * @param  {[type]} reject    promise2的reject方法 */function resolvePromise(promise2, x, resolve, reject) {    if (promise2 === x) { // 如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错        return reject(new TypeError('循环引用'));    }    let called = false; // 避免多次调用    // 如果x是一个promise对象 （该判断和下面 判断是不是thenable对象重复 所以可有可无）    if (x instanceof Promise) { // 获得它的终值 继续resolve        if (x.status === PENDING) { // 如果为等待态需等待直至 x 被执行或拒绝 并解析y值            x.then(y =&gt; {                resolvePromise(promise2, y, resolve, reject);            }, reason =&gt; {                reject(reason);            });        } else { // 如果 x 已经处于执行态/拒绝态(值已经被解析为普通值)，用相同的值执行传递下去 promise            x.then(resolve, reject);        }        // 如果 x 为对象或者函数    } else if (x != null &amp;&amp; ((typeof x === 'object') || (typeof x === 'function'))) {        try { // 是否是thenable对象（具有then方法的对象/函数）            let then = x.then;            if (typeof then === 'function') {                then.call(x, y =&gt; {                    if (called) return;                    called = true;                    resolvePromise(promise2, y, resolve, reject);                }, reason =&gt; {                    if (called) return;                    called = true;                    reject(reason);                })            } else { // 说明是一个普通对象/函数                resolve(x);            }        } catch (e) {            if (called) return;            called = true;            reject(e);        }    } else {        resolve(x);    }}/** * [注册fulfilled状态/rejected状态对应的回调函数] * @param  {function} onFulfilled fulfilled状态时 执行的函数 * @param  {function} onRejected  rejected状态时 执行的函数 * @return {function} newPromsie  返回一个新的promise对象 */Promise.prototype.then = function (onFulfilled, onRejected) {    const that = this;    let newPromise;    // 处理参数默认值 保证参数后续能够继续执行    onFulfilled =        typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value;    onRejected =        typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; {            throw reason;        };    // then里面的FULFILLED/REJECTED状态时 为什么要加setTimeout ?    // 原因:    // 其一 2.2.4规范 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout    // 其二 2.2.6规范 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected    // 其二 2.2.6规范 也是resolve函数里加setTimeout的原因    // 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行    // 如下面这种情景 多次调用p1.then    // p1.then((value) =&gt; { // 此时p1.status 由pedding状态 =&gt; fulfilled状态    //     console.log(value); // resolve    //     // console.log(p1.status); // fulfilled    //     p1.then(value =&gt; { // 再次p1.then 这时已经为fulfilled状态 走的是fulfilled状态判断里的逻辑 所以我们也要确保判断里面onFuilled异步执行    //         console.log(value); // 'resolve'    //     });    //     console.log('当前执行栈中同步代码');    // })    // console.log('全局执行栈中同步代码');    //    if (that.status === FULFILLED) { // 成功态        return newPromise = new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                try {                    let x = onFulfilled(that.value);                    resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值                } catch (e) {                    reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);                }            });        })    }    if (that.status === REJECTED) { // 失败态        return newPromise = new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                try {                    let x = onRejected(that.reason);                    resolvePromise(newPromise, x, resolve, reject);                } catch (e) {                    reject(e);                }            });        });    }    if (that.status === PENDING) { // 等待态        // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中        return newPromise = new Promise((resolve, reject) =&gt; {            that.onFulfilledCallbacks.push((value) =&gt; {                try {                    let x = onFulfilled(value);                    resolvePromise(newPromise, x, resolve, reject);                } catch (e) {                    reject(e);                }            });            that.onRejectedCallbacks.push((reason) =&gt; {                try {                    let x = onRejected(reason);                    resolvePromise(newPromise, x, resolve, reject);                } catch (e) {                    reject(e);                }            });        });    }};/** * Promise.all Promise进行并行处理 * 参数: promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。 */Promise.all = function (promises) {    return new Promise((resolve, reject) =&gt; {        let done = gen(promises.length, resolve);        promises.forEach((promise, index) =&gt; {            promise.then((value) =&gt; {                done(index, value)            }, reject)        })    })}function gen(length, resolve) {    let count = 0;    let values = [];    return function (i, value) {        values[i] = value;        if (++count === length) {            console.log(values);            resolve(values);        }    }}/** * Promise.race * 参数: 接收 promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快) */Promise.race = function (promises) {    return new Promise((resolve, reject) =&gt; {        promises.forEach((promise, index) =&gt; {            promise.then(resolve, reject);        });    });}// 用于promise方法链时 捕获前面onFulfilled/onRejected抛出的异常Promise.prototype.catch = function (onRejected) {    return this.then(null, onRejected);}Promise.resolve = function (value) {    return new Promise(resolve =&gt; {        resolve(value);    });}Promise.reject = function (reason) {    return new Promise((resolve, reject) =&gt; {        reject(reason);    });}/** * 基于Promise实现Deferred的 * Deferred和Promise的关系 * - Deferred 拥有 Promise * - Deferred 具备对 Promise的状态进行操作的特权方法（resolve reject） * *参考jQuery.Deferred *url: http://api.jquery.com/category/deferred-object/ */Promise.deferred = function () { // 延迟对象    let defer = {};    defer.promise = new Promise((resolve, reject) =&gt; {        defer.resolve = resolve;        defer.reject = reject;    });    return defer;}/** * Promise/A+规范测试 * npm i -g promises-aplus-tests * promises-aplus-tests Promise.js */try {    module.exports = Promise} catch (e) {}</code></pre><p>来源:<br><a href="https://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">https://www.ituring.com.cn/article/66566</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;JavaScript Promise A+ 规范&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;译者序：一年前曾译过 Promise/A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知
      
    
    </summary>
    
    
      <category term="javaScript" scheme="https://x1nes.github.io/blog/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>蝙蝠侠：黑暗骑士</title>
    <link href="https://x1nes.github.io/blog/posts/48fde4e8/"/>
    <id>https://x1nes.github.io/blog/posts/48fde4e8/</id>
    <published>2021-04-03T00:32:38.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我心目中最好的一步蝙蝠侠电影，没有之一。</p></blockquote><p>分享豆瓣热评。</p><p>大片中很有内涵的一部，不管是人们心中暗自涌动的对小丑疯狂灭世主义的不安的共鸣，还是对蝙蝠侠孤独暗夜行走的英雄惜英雄般同情，其实都是人们对这个世界失望的一种情绪释放。其实小丑说的很对，他和蝙蝠侠很像，都是异类，只不过蝙蝠侠把痛苦留给自己，顽固地去坚守一丝信仰，而小丑把痛苦还给世界。<br>–<strong>fishlee 看过   2009-07-28</strong></p><p>赞誉众口一致夸上了天，百闻不如一见，这种连环画超级英雄故事居然能扯到第六集真是要把编剧逼跳楼了，最后呈现的暗夜骑士全然超越了原著，悲怆到迷人的境界，着实是个奇迹。剧本确实很卓越，导演确实很出色，还有演技真是不得不叹服一下太tmd震撼<br>–<strong>37°2 看过  2008-11-21</strong></p><p>对于这么优秀的电影来说，再多的赞美都是多余的。<br>–<strong>Jin 看过  2008-09-15</strong></p><p>“有些人并不喜欢那些常人偏爱的东西，比如金钱，他们不被收买、不会被恐吓、不可理喻、更不接受谈判，有些人就想看人间地狱。” 也只有蝙蝠侠，才能让小丑变得完整。无尽的黑暗。<br>–<strong>影志 看过  2008-12-14</strong></p><h2 id="影评"><a class="header-anchor" href="#影评">¶</a>影评</h2><p>作者:武志红<br>来源：<br><a href="https://movie.douban.com/review/1629723/" target="_blank" rel="noopener">https://movie.douban.com/review/1629723/</a></p><p>【22日，美国第81届奥斯卡奖的提名名单公布，令人们大跌眼镜的是，2008年全球票房冠军、好莱坞历史上第二卖座的《蝙蝠侠·暗夜骑士》只拿到了数项无关痛痒的提名。<br>不过，评委们可以轻视这部影片，但却不能轻视影片中的反角小丑，饰演小丑的演员希斯·莱杰众望所归获得了最佳配角提名，而分析者们也普遍认为，这一奖项铁定是希斯·莱杰的，这不是因为曾在《断臂山》等影片中有上佳表现的希斯·莱杰多么有影响力，而仅仅是因为小丑在《蝙蝠侠·暗夜骑士》中的表现是无以伦比的，这注定将是电影史最有名的反角之一。<br>22日也是希斯·莱杰去世一周年的纪念日。2008年的这一天，年仅29岁的他被发现猝死纽约曼哈顿租住的公寓中。<br>在这一特殊的日子，我写下了对《暗夜骑士》这部影片的心理分析文章，以此来纪念这位演艺界不多见的奇才。】</p><p>在生活中，我听到见到无数这样的故事，两个相爱的人，一个不断去突破另一个人的底线。<br>这个人的潜在的逻辑是，你说你爱我，这是真的吗？我不信，所谓爱我只是给你的生活添加光彩罢了，如果你真的爱我，你就会不顾一切地爱我，你真的能做到这一点吗？<br>这也是电影《蝙蝠侠·暗夜骑士》（也即《蝙蝠侠》系列影片之六）中隐藏的核心逻辑。</p><p>这部影片的背景是，在黑帮和毒贩横行的高谭市，蝙蝠侠不断神出鬼没地打击罪犯，而他有一个众所周知的规则——不杀人。<br>在蝙蝠侠这位“暗夜骑士”的帮助下，高谭市警长戈登将黑社会老大们一网打尽，而高谭市检察长、有“光明骑士”之称的哈维·邓特试图将他们全部送上法庭，证据确凿，看来他们注定要住在监狱了，而高谭市似乎终于可以恢复平静和光明了。<br>就在这时，小丑出现了，他阴险狡诈，没有任何底线，头脑中也没有任何教条，他以杀死蝙蝠侠为由而将黑帮团结在自己周围，并带领他们和他招募来的精神分裂症患者们随心所欲地杀人，以此向市民们施加压力，让他们迫使蝙蝠侠脱下面具公布身份。<br>这只是影片一条表面的脉络，而影片核心的脉络是，小丑不断刺激哈维·邓特和蝙蝠侠这两个“正义的化身”，甚至希望哈维·邓特将自己击毙，蝙蝠侠将自己杀死。因为这样一来，他们就和他一样了，他们所信奉的正义不过是一个表面上的表演而已，而真正掌握这个世界的，还是小丑的逻辑——“没有迫不得已的时候，谁不想正义凛然？”<br>每个人都以为，他的逻辑是正确的，这个世界在按照他相信的那一套逻辑运转，如果这个世界不是这样的，我们就会以为，这不过是表面现象而已，真正的深层逻辑一定是自己掌握的那一套逻辑，要证明这一点，只需要将别人“轻轻推一下”，这些人就会陷入在自己的逻辑中。<br>例如，假若一个美女相信，男人都不是好东西，男人只是对她的身体感兴趣而根本不会爱她。那么，她会使用她的身体去勾引男人，而她会发现，她只需要这样将男人们“轻轻推一下”，这些男人就会变成贪婪的色鬼。<br>例如，假若一个富人相信，每个人都是贪婪的，有钱能使鬼推磨。那么，他会使用他的金钱将无数人“轻轻推一下”，这些人就会陷入他的掌握中。<br>小丑则认为，每个人都是邪恶的，没有信任可以的，他只需要将人们“轻轻推一下”，每个人都会放弃正义，变得很自私和丑恶，于是出卖别人甚至亲自杀死战友。在影片中，小丑“轻轻推一下”的武器是人们心中的恐惧，他认为，每个人爱的都是自己和自己的亲人，只要你去威胁他们的生命，那么每个人都会放弃原有的底线，而变成恶魔。</p><p>影片一开始就展示了小丑的逻辑。他引诱几个戴着小丑面具的匪徒打劫黑帮的银行，并对他们说，杀死你的同伴，这样你分到的钱更多。于是，这些匪徒果真在抢劫过程中相互屠杀，那些稍有犹豫的人，立即会被同伙干掉，而小丑自己在这个过程中是最果断的，所以他是唯一生存的。<br>对此，这个黑帮银行的头目说：“这座城市的匪徒向来有信念。”他是说，他们是有底线的，这就是“盗亦有道”的意思了，但小丑证明，他只需要“轻轻推一下”，就可以破掉黑帮们的底线。<br>在小丑带领下，他的爪牙们打劫了多个黑帮银行，抢劫了6800万美元，但他竟然堂而皇之地闯进了黑帮老大们的聚会所。因为他明白，只要他“轻轻推一下”，这些黑帮老大们就会团结在他周围。<br>果不其然，当他说，他可以杀死蝙蝠侠时，大多数黑帮老大都被打动了。这既是诱惑，也是利用了恐惧的力量。这个时候，黑帮老大们被蝙蝠侠、哈维·邓特和戈登等光明力量逼到了绝路上，所以当他抛出这个诱饵后，高谭市黑社会很快整个投靠了他。<br>整个影片中，小丑经常利用人性的弱点给出选择题，令我印象深刻的选择题有三个，第一个是他抛给黑社会的。一个黑帮头子讨厌他而发出追杀令，结果被他所杀，而他扔给了活着的两个黑社会爪牙各自一截棍子，说你们只有一个可以活命，你们相互厮杀吧。“盗亦有道”中的一个很重要的“道”是不得内讧，但这个底线，小丑轻易就令他们突破了。<br>黑社会的“盗亦有道”毕竟是不大可靠的，被突破似乎不算什么。那么，那些最光明的正人君子呢？他们的底线能突破吗？接下来的故事显示，这并不是非常难。<br>获得了黑帮的支持后，小丑向哈维·邓特、高谭市警察局长和即将审判黑帮老大们的女法官三人同时发出了死亡威胁，并几乎在同时炸死了女法官和毒死了警察局长。警察局长是在和戈登对话时喝了一杯毒酒被毒死的，当时戈登说，你的周围已有内鬼，你要小心。但此时警察局长毒酒已落肚。<br>显然是内鬼给了警察局长毒酒，但内鬼为什么会听从小丑指挥？影片没给出直接回答，但不难推测的是，小丑向这些警察本人及其亲人发出了死亡威胁，这是小丑一直在使用的手段。<br>要杀死哈维·邓特就没有那么容易了，因为哈维·邓特的未婚妻瑞秋是蝙蝠侠的前女友，蝙蝠侠是哈维·邓特的偶像，而哈维·邓特则是蝙蝠侠心目中的救星。</p><p>两个男人被一个女人爱上，这通常意味着，这两个男人要么很像，要么截然不同。这两点综合起来还有更复杂的情形，即他们要么看上去很像但其实完全不同，或看上去不像但其实本质一样。<br>蝙蝠侠和哈维·邓特又有什么相同和不同呢？<br>蝙蝠侠的真名叫布卢斯·韦恩，是韦恩企业集团的董事长，全世界最富有的男人。他第一次和哈维·邓特相遇是在他的一个餐厅。高谭市检察官想和自己的同事未婚妻瑞秋约会，托了人才在这个餐厅定了一个位子，而恰好遇见了胳膊上挽着俄罗斯芭蕾舞演员的布卢斯·韦恩。不知道布卢斯·韦恩就是蝙蝠侠的哈维·邓特谈起了蝙蝠侠，言辞中充满着崇拜，他认为蝙蝠侠是英雄，而这个混乱的城市需要蝙蝠侠的看护，并担心蝙蝠侠的压力太大，“或是作为英雄战死，或是苟活道目睹自己被逼成坏人。”<br>哈维·邓特是布卢斯·韦恩的情敌，但韦恩还是被哈维·邓特打动了，他想用他的财富帮助这位“光明骑士”，让高谭市民彻底“相信哈维·邓特（这是哈维·邓特的竞选口号）”，他也渴望哈维·邓特愿望实现，将“看护高谭市”的责任交给他。<br>当然，这种无私藏着极大的自私。因为，布卢斯·韦恩仍然爱着瑞秋，而瑞秋不希望嫁给“蝙蝠侠”，过着担惊受怕的生活，她希望和布卢斯·韦恩过平淡而幸福的生活，所以此前对·布卢斯韦恩说过，如果你不再做蝙蝠侠，我就嫁给我。<br>所以，“暗夜骑士”是想将看护高谭市的重担交给“光明骑士”，那样他就可以和心爱的人过幸福生活了。<br>女人是矛盾的，女人常做这样的事情：爱上一个英雄，但对英雄说，你要变成平凡人我才嫁你。然而，这是真的吗？</p><p>因为有蝙蝠侠保护，哈维·邓特一直是安全的，但别人就没那么幸运了，高谭市市长都险些丧命于小丑的阴谋下，其他血腥的杀戮则不断刺激高谭人脆弱的灵魂。<br>最终，蝙蝠侠决定屈从小丑的要求。小丑说，只要蝙蝠侠自首（高谭市警方一直在追捕这位“暴力义警”），他就停止杀戮。这其实是在离间蝙蝠侠和高谭市民的关系。<br>大众比较容易被离间，他们纷纷呼吁蝙蝠侠现身。哈维·邓特质问民众：“你们真地要牺牲这位一直保护你们的英雄吗？”他们纷纷回答说，是的。<br>这时，哈维·邓特说，他就是蝙蝠侠。<br>也就在这一刻，瑞秋第一次真心痛恨起布卢斯·韦恩来，她斥责他让检察长背黑锅，并决定嫁给哈维·邓特。然而，她到底想嫁给谁呢？<br>显然，她是决定嫁给那个最英雄的人，那个最正确的人。那么，她是真的想让蝙蝠侠变成平凡人吗？<br>被捕的哈维·邓特要被送进监狱，小丑则在路上设计杀死他。自然，“暗夜骑士”会来保护“光明骑士”。经过一番激烈的大战后，小丑最后剩下了孤家寡人，而蝙蝠侠则开着高科技摩托车向他撞去。<br>但小丑并不躲闪，而是狞笑着自语：“撞我啊！撞我啊！”<br>一开始，对这一情节我有不解，但随即明白，他是想用自我牺牲来引诱蝙蝠侠突破自己“不杀人”的底线，以此来证明，他才是唯一正确的。<br>“只有我才是正确的”，这种感觉的诱惑力真是强大，为了“捍卫”这种感觉，小丑不惜一死。<br>蝙蝠侠也明白了这一点，在千钧一发时刻，他躲闪，并被摔晕，但小丑还是诈死的戈登被捕了。<br>孰料，被捕也是小丑的一个精心设计的圈套。他知道，戈登没死，而且戈登一定会把他送进戈登自己的特别牢房，那里还关着一个掌握着黑帮所有财富的特殊人物。围绕着这一点，他还设计了许多圈套。<br>但蝙蝠侠和警方不知道这一圈套，他们以为逮捕小丑就可以万事大吉了。但他们很快发现，这是幻觉，小丑的人抓走了哈维·邓特和瑞秋。而在监狱里，小丑给蝙蝠侠出了影片中的第二道选择题：一个地方关着哈维·邓特，另一个地方关着瑞秋，时间有限，你只能救一个，你救谁？<br>蝙蝠侠选择了救瑞秋，这恰恰中了小丑的圈套，小丑故意说错了地点，他说关瑞秋的地点其实关的是哈维·邓特。所以，蝙蝠侠救出的是哈维·邓特，而瑞秋葬身于火海中。<br>对此，布卢斯·韦恩反思，他做了一次“不正确的决定”，终于知道了“蝙蝠侠也有力不能及的事”。这一次也仿佛验证了小丑的逻辑“没到迫不得已的时候，谁不想正义凛然？”</p><p>这不只是蝙蝠侠“力不能及的事”，也是影片中所有好人变坏的原因。小丑的人没拉一个警察下水，都是通过胁迫警察亲人的生命而实现的。譬如瑞秋之所以被绑架，是因为戈登属下的一个女警察受到了这种威胁，而哈维·邓特被绑架也是如此，小丑能够肆无忌惮地制造炸死女法官、毒死警察局长、枪击市长、炸掉高谭综合医院等一系列事情，也都是因为他利用这一威胁突破了一个又一个好人的底线。<br>影片的高潮中，小丑将这一招数发挥到极致。他威胁整个城市的人，要么“成为我的人”，要么离开这个城市。最后一批逃离这个城市的人乘坐了两条船，一条船上是好人，一条船上是那些黑社会老大及其属下。<br>等这两条船开到河中时，突然停下了，并传来了小丑的威胁：每条船上都装有大量炸药，还有一个起爆器，但起爆器控制的是另一条船，只有一条船上的人可以生还，条件是12点前必须引爆另一条船。<br>这是小丑在影片中出的第三道选择题，而且选择范围是民众。民众曾经选择抛弃蝙蝠侠，他们还会选择抛弃别人吗？<br>结果，小丑失败了。载有普通人的船，通过投票决定不引爆起爆器，而载有罪犯的船，起爆器被一个黑社会老大扔到了河里。<br>基督教传说中，魔鬼撒旦赢得世界的方式是捕获人类的灵魂，而小丑使用的是同一逻辑，他对金钱丝毫不感兴趣，他曾将堆积如山的钱付之一炬，说“这个城市配得上一个有品味的罪犯”。他还对蝙蝠侠说：“你应该知道，我对钱没有兴趣，我不是那种人，你不要把我降格成那种人。”<br>小丑感兴趣的是，将他的逻辑——“没有迫不得已的时候，谁不想正义凛然？”——强加给周围的世界。对这一点，布卢斯·韦恩的管家阿尔弗雷德一开始就发现了，他给蝙蝠侠举例说，曾经有匪徒劫走了他们的宝石，但他们却将这些宝石随处丢弃，他们其实对宝石并不感兴趣，他们这么做，仅仅是因为“他们觉得有意思。他们不会被收买，不会被恐吓，不会讲道理，也不会接受谈判，有些人就是想看着这个世界燃烧。”<br>在我看来，这也是所有最邪恶罪犯的共同欲望，他们感兴趣的不是钱权名利等看得见摸得着的事物，他们要的是影响力，他们想将他们的意志强加给这个世界，让这个世界随着他们的欲望而战栗，用普通的逻辑看待他们是行不通的。</p><p>在这一点上，匪徒和英雄也常常是一个硬币的两面，他们要的其实都是影响力，而不是正义、公平、普世道理或“绝对正确的事”。<br>哈维·邓特就是这样的例子。影片的高潮是第三个选择，在这个选择上，小丑输了，但小丑仍哈哈大笑，因为认为他在“高谭灵魂之战”上赢了。<br>小丑的意思是，他用他的逻辑击败了哈维·邓特，最终让这位“光明骑士”服膺了他的逻辑。<br>这是真的。瑞秋丧生后，哈维·邓特绝望了。尽管蝙蝠侠救了他，但他的左半边脸被汽油烧烂了，皮肤脱落，肌肉和牙齿裸露，无比疼痛，但他拒绝接受任何去痛治疗。<br>这可以理解，因为，比起失去爱人的心痛来，这种肉体的痛更容易承受，而且它可以让自己的注意力从心痛上转到肉体的痛上来。<br>双重的痛让哈维·邓特放弃了“对公正的狂热追求”，转而变成了一个彻底的机会主义者，他追踪并拷问所有牵涉到瑞秋之死的人，并通过抛硬币来决定对方的生死。<br>“光明骑士”变成“双面骑士”，这看起来令人心痛，但这并非偶然。影片显示，他很早就有一个绰号“双面人”，而他一直喜欢抛硬币，他表现出的“对公正的狂热追求”不过是一面而已，而他的另一面早就存在，小丑的逻辑“没有迫不得已的时候，谁不想正义凛然？”可以不折不扣地用在他身上。<br>可以说，哈维·邓特并不是在追求“光明”，而是他发现，他可以通过追求光明来追求影响力，他通过“对公正的狂热追求”成为高谭市民的偶像，他也通过替蝙蝠侠背黑锅而终于获得了瑞秋的爱。这是极大的好处。<br>然而，瑞秋死了，他的生存逻辑也随之一下子被颠覆了。<br>从这一点看来，他与蝙蝠侠只是“形似而神离”，通俗说来，就是他看上去与蝙蝠侠很像，但本质上有根本差异。<br>这一差异是，蝙蝠侠对影响力没有兴趣，他追求的是正义。影片最后，他甘愿替哈维·邓特背黑锅，将这位“光明骑士”的杀业承担在自己身上，不惜令人们以为他已破了杀戒。但他愿意承担这一切，而让高谭人去迎接光明，这不是一个表现出来的英雄，而是一个真实的英雄。<br>重要的不是形式，重要的是灵魂，这是小丑和蝙蝠侠的共同之处。<br>并且，尽管小丑似乎没有任何底线，并说自己是“混乱的代理人”，说他憎恨秩序，但他想营造的世界仍然是有秩序的。<br>他想让世界恐惧，这不过是他的“内在的暴虐的父亲”折磨他的“内在的受虐的小男孩”的外化而已。他曾服膺于父亲的逻辑，认同了那个“内在的暴虐的父亲”，而他也希望整个世界和曾经的他一样，屈从于这种暴力之下。<br>但是，他的内心深处的那个小男孩又惧怕这一点的实现，因为这意味着他的所有世界都将陷入黑暗，将不再有任何光亮。所以，当有人真的想暴露蝙蝠侠的真实身份时，他却向这个人发出了追杀令。<br>甚至，我想，即便蝙蝠侠真的没有了抵抗能力，任他宰割时，他会放弃。或者，他会杀掉这个蝙蝠侠，然后再去找一个蝙蝠侠去杀。如果这个世界上只有一个蝙蝠侠的话，他会舍不得杀的。这不只是为了不断斗下去而活在“一个不那么无聊的世界”，也是他内心深处那个小男孩的一点微弱而坚定的呼声。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我心目中最好的一步蝙蝠侠电影，没有之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分享豆瓣热评。&lt;/p&gt;
&lt;p&gt;大片中很有内涵的一部，不管是人们心中暗自涌动的对小丑疯狂灭世主义的不安的共鸣，还是对蝙蝠侠孤独暗夜行走的英雄惜英雄般同情，其实都是人们
      
    
    </summary>
    
    
      <category term="电影" scheme="https://x1nes.github.io/blog/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>刷完300道leetcode的感想</title>
    <link href="https://x1nes.github.io/blog/posts/3d49f50c/"/>
    <id>https://x1nes.github.io/blog/posts/3d49f50c/</id>
    <published>2021-03-21T13:18:32.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近几个月刷了将近300道力扣题，这里记录下。</p></blockquote><p>首先，我想说的是，这种东西应该早点开始刷，可惜因为自己并非计算机科班出身，大学也对编程没产生兴趣，一直到参加工作，误打误撞接触到程序员这个行业，才开始真正的学习计算机基础，网络，算法之类的，但是现在开始也还行，毕竟，开始做一件事的最好时间点是十年前，另一个是现在。</p><h2 id="留个截图"><a class="header-anchor" href="#留个截图">¶</a>留个截图</h2><p><img src="./arfreafd.PNG" alt></p><p>刚开始刷的感受，很绝望</p><p><img src="./sdafths.jpg" alt></p><p>后来多刷，找到了一点感觉</p><p><img src="./1dguygffs.jpg" alt></p><h2 id="一点点收获"><a class="header-anchor" href="#一点点收获">¶</a>一点点收获</h2><p>第一，我发现自己对于边际的考虑变得更加完善了，每写一段代码都要考虑到边际问题。数组长度是否为0？对象的属性有没有可能为null，各种特殊情况下的考虑和兼容处理。<br>第二，写代码的逻辑也渐渐清晰起来，每个if都要考虑else怎么处理，对于不能处理的入参即使的return，使得整体的代码看起来更加容易。<br>第三，对性能上的考虑，每一步都要考虑有没有必要这样做，能不能空间换时间，能不能加上记忆化备忘录，能不能减少对象的创建和销毁，能不能用下标的移动代替数组切割等等。<br>第四，学到了之前没接触过或者深入了解的数据结构，比如单调栈的使用，优先级队列的使用和原理（可以用堆实现），并查集处理“家族”问题，前缀和的使用，了解了哈希表的实现原理。</p><h2 id="从二叉树中吸取的经验"><a class="header-anchor" href="#从二叉树中吸取的经验">¶</a>从二叉树中吸取的经验</h2><p>刷题我建议从二叉树开始刷，培养递归的意识，毕竟仔细想一下，其实代码块就是一个树型的结构，代码会被编译成AST语法树，进行解析运行，所以，多了解二叉树对培养逻辑思考很有帮助。</p><p>比如这道题：</p><blockquote><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p></blockquote><blockquote><p>例如：</p></blockquote><blockquote><p>给定二叉树 [3,9,20,null,null,15,7]，</p></blockquote><pre><code>    3   / \  9  20    /  \   15   7</code></pre><blockquote><p>返回它的最大深度 3 。</p></blockquote><p>一个答案是：</p><pre><code class="language-javascript">/** * @param {TreeNode} root * @return {number} */var maxDepth = function(root) {    if(!root) {        return 0    }    return Math.max(maxDepth(root.left),maxDepth(root.right)) +1};</code></pre><p>这里就用到了递归的思想。</p><h2 id="数学上的归纳和总结"><a class="header-anchor" href="#数学上的归纳和总结">¶</a>数学上的归纳和总结</h2><p>很多题表面上是编程题，其实是数学题，比如有些动态规划，总结出状态转移方程就可以很轻松AC，否则暴力解决必定超时。</p><p>但是，动态规划不同题型，不同场景下的变化很大，有时候很难找出对应的动态转移方程。这里真的需要大量的练习才能好好的理解其中的道理。动态规划我自己感觉是最难，变化最灵活的题型了。<br>分享下动态规划的类型，这也是我下一步需要重点练习的内容。</p><p>1.背包 DP。<br>2.区间 DP。<br>3.DAG 上的 DP。<br>4.树形 DP。<br>5.状压 DP。<br>6.数位 DP。<br>7.插头 DP。<br>8.计数 DP。<br>9.动态 DP。<br>10.概率 DP。</p><h2 id="多利用题目给的前提条件"><a class="header-anchor" href="#多利用题目给的前提条件">¶</a>多利用题目给的前提条件</h2><p>比如有些给的数组是有序的，或者给的二叉树是二叉搜索数，利用好给的前提条件，才能写出更高效率的代码。<br>这里要有一些肌肉反应。<br>顺序数组 —&gt; 二分搜索<br>二叉搜索数 —&gt; 中序遍历</p><h2 id="发现自己的薄弱部分"><a class="header-anchor" href="#发现自己的薄弱部分">¶</a>发现自己的薄弱部分</h2><p>对很多算法没研究，比如并查集，图的算法，稍微变形的动态规划题，一直没有思路，以后要先系统学习一遍这些内容，在开始进行练习。</p><p>以后每日一题要坚持下去，关键是要真的搞懂，不能单纯背答案。</p><p>over~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近几个月刷了将近300道力扣题，这里记录下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，我想说的是，这种东西应该早点开始刷，可惜因为自己并非计算机科班出身，大学也对编程没产生兴趣，一直到参加工作，误打误撞接触到程序员这个行业，才开始真正的学
      
    
    </summary>
    
    
      <category term="算法" scheme="https://x1nes.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>javascript实现优先级队列</title>
    <link href="https://x1nes.github.io/blog/posts/5d46f50c/"/>
    <id>https://x1nes.github.io/blog/posts/5d46f50c/</id>
    <published>2021-03-21T12:40:51.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>鉴于javascript 没有实现优先级队列，这里记录一个用堆实现的代码</p></blockquote><pre><code class="language-javascript">class Heap {    constructor(data = [], cmp = (lhs, rhs) =&gt; lhs - rhs) {        if (typeof data === 'function') {            cmp = data            data = []        }        this.data = [null, ...data]        this.size = data.length        this.lt = (i, j) =&gt; cmp(this.data[i], this.data[j]) &lt; 0        for(let i = this.size; i &gt; 0; i--) this.heapify(i)    }    push(v) {        this.data.push(v)        let i = ++this.size        while(i &gt;&gt; 1 &amp;&amp; this.lt(i, i &gt;&gt; 1)) this.swap(i, i &gt;&gt;= 1)    }    pop() {        this.swap(1, this.size)        const top = this.data.pop()        this.size--        this.heapify(1)        return top    }    top() { return this.data[1] }    heapify(i) {        while (true) {            let min = i            const [l, r, n] = [i * 2, i * 2 + 1, this.data.length]            if (l &lt; n &amp;&amp; this.lt(l, min)) min = l            if (r &lt; n &amp;&amp; this.lt(r, min)) min = r            if (min !== i) this.swap(i, min), i = min            else break        }    }    swap(i, j) {        const d = this.data;        [d[i], d[j]] = [d[j], d[i]]    }}let queue = new Heap((l, r) =&gt; l - r) queue.push(1)queue.push(43)queue.push(13)queue.push(99)queue.push(-23)console.log(queue.top())// -21queue.pop()console.log(queue.top())// 1</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;鉴于javascript 没有实现优先级队列，这里记录一个用堆实现的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
class Heap {
    constructor(
      
    
    </summary>
    
    
      <category term="javaScript" scheme="https://x1nes.github.io/blog/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>什么是真正的兴趣爱好</title>
    <link href="https://x1nes.github.io/blog/posts/5d7d167c/"/>
    <id>https://x1nes.github.io/blog/posts/5d7d167c/</id>
    <published>2021-03-13T22:45:01.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源网络</p></blockquote><p>★哪些东西【不能算】兴趣和爱好？</p><p>在本文的开头，俺想从【反面】来陈述这个话题——点评一下那些“容易跟兴趣爱好混为一谈的东西”。（对这些东西，俺称之为“伪兴趣”）<br>　　通过识别“伪兴趣”，有助于你去伪存真，识别出真正的兴趣。</p><p>◇三分钟热度，不是真正的兴趣</p><p>如果你留意观察儿童的行为，就会明白何为“三分钟热度”？比如当某个小孩得到自己喜欢的玩具，会很开心很兴奋。但是几天（甚至几小时）之后，这种开心兴奋状态就消失了——他/她的兴趣点已经转移到其它地方。<br>　　显然，“三分钟热度”不是真正的兴趣。这个很好理解，俺就不多说了。</p><p>◇动机带有【功利】因素，不是真正的兴趣</p><p>关于这点，就以今年（2015）的股灾为例。<br>　　在咱们天朝，每当牛市的时候，就有很多股民成天盯着电脑上的炒股软件，片刻不停。<br>　　如果你以为他们对“炒股”感兴趣，那就错了。大部分股民其实对“炒股”这个行为本身并【没有】兴趣——他们这么做是为了【赚钱】。换句话说，他们的行为带有“功利因素”，因此不能算是真正的兴趣。<br>　　（另外，确实有一小撮股民是真正喜欢“炒股”这个行为本身。但是这类人非常之少）</p><p>◇来自【外在】的动机，不是真正的兴趣</p><p>所谓“外在的动机”，大致包括如下：</p><ol><li>被别人强迫去做某事<br>（比如很多小孩被父母强迫去学钢琴）</li><li>受到社会观念的约束而去做某事<br>（比如大学填志愿的时候，报考热门专业）</li><li>为了得到他人的认可而去做某事<br>（比如某些人为了出名而去做某事）</li><li>受到法律的约束而去做某事<br>（比如很多国家的义务兵役制）<br>…<br>　　以上只是列出几种典型的情形，未必全面。欢迎大伙儿补充。<br>　　关于“外在的动机”，显然不是真正的兴趣。这个也比较好理解，俺就不深入聊了。</li></ol><p>◇【纯感官】的刺激导致的行为，不是真正的兴趣</p><p>所谓“真正的兴趣”，显然是人类独有的（其它动物不会有）。而“纯感官的刺激”导致的行为，不光人类会有，其它动物也会有。<br>　　所以，纯感官的刺激导致的行为，【不能算】真正的兴趣。对这类行为，俺更愿意称之为“本能的驱使”。<br>　　为了便于理解，举几个例子：吃顿美餐、泡个温泉…</p><p>◇【被动】的行为，不是真正的兴趣</p><p>请注意，本小节所说的“被动”，【不是】指他人的强迫。（“他人的强迫”已经在前面的小节分析过了）<br>　　本小节所说的“被动”，指的是【行为本身的特性】。换句话说，当某个行为【不】需要依靠你的主观意识，【不】需要发挥你的主动性，那么，俺就称之为“被动的行为”。<br>　　为了便于理解，同样举个例子：<br>　　有很多人喜欢一边工作一边听音乐。在这种情况下，“听音乐”这个行为是被动的。</p><p>◇始终停留在【心理舒适区】，不是真正的兴趣</p><p>首先来解释一下，何为“心理舒适区”。这玩意儿，洋文称之为“Comfort Zone”，用来描述一种“心理状态”。处于这种状态，你会感觉到放松，没有压力和焦虑。<br>　　如果你处于某个环境中，在该环境下所需要的行为你都可以轻松搞定。那么，你就处于“心理舒适区”。<br>　　举例：<br>　　俺曾经问过周围的一些人，他们业余时间有啥兴趣和爱好。在俺听到的反馈中，如下这几种很常见：<br>上网闲逛<br>看视频（短视频、影片、连续剧）<br>看八卦新闻<br>　　在俺看来，上述这几种行为都属于“让自己停留在心理舒适区”。这类行为，很多都是为了打发时间，【不能】算是真正的兴趣。</p><p>★【真正的】兴趣和爱好，具有哪些特征？</p><p>前面说了一大堆“反例”，接下来开始进入正题。</p><p>◇动机的【内在性】</p><p>真正的兴趣，其动机完全来自于内心，而不是外部世界。<br>　　只有这样产生的兴趣，才是纯粹的。换句话说，这样的动机，【不会】随着外部世界的改变而改变。</p><p>◇时间的【持久性】</p><p>对于真正的兴趣，通常能持续很长时间（至少几年，多达几十年）。<br>　　为啥“真正的兴趣”能持续这么久捏？在本文下面的章节，俺会分析。</p><p>◇思维的高度参与</p><p>前面提到了两种反例，分别是“纯感官刺激的行为”和“被动行为”。<br>　　与这两种相对应的是：真正的兴趣，其行为通常需要思维的高度参与。<br>　　举例：<br>　　下面这些活动都需要思维的高度参与，也都【有可能】成为真正的兴趣。</p><pre><code>  1.写程序  2.写作  3.作曲  4.绘画  5.摄影  6.电子游戏  7.棋牌游戏......</code></pre><p>◇快感的【内在性】</p><p>前面的小节提到了“动机的【内在性】”。这里所说的“快感的【内在性】”，也类似滴。通俗地说：真正的兴趣所导致的快感，【不需要】依赖外部环境。<br>　　举例：<br>　　数学史上很牛逼的费马（又称“费尔马”，洋文是“Fermat”），完全是凭兴趣研究数学，而且他的很多研究成果都【没】发表。比如他最有名的那个“费马大定理”，是他儿子整理遗物的时候发现的；再比如“费马小定理”是他与朋友的往来书信中顺便提及的。<br>　　也就是说，他的快乐【不是】依赖“荣誉感”之类的外在因素。<br>　　顺便说一下：费马严格来说连“数学家”都不是。他的正式职业是律师和法官，数学只是他的业余爱好。</p><p>◇不一样的快感</p><p>当你从事自己真正感兴趣的活动，通常会体验到不一样的快感——这快感就是你的动力。前面俺提到说，真正的兴趣可以持续很多年，原因也在于这快感。<br>　　兴趣与爱好导致的快感，大致可以分为两类：“过程性的快感”和“结果性的快感”。<br>　　这两种快感的差别在于：“过程性的快感”持久但是强度不高；“结果性的快感”只在短暂时间段发生，但是强度很高。<br>　　举例：<br>　　就拿俺的老本行来说事儿。当俺在写程序的时候，（不管是在公司里写还是在业余时间写）总是乐在其中。也就是说，单单是“写代码的过程”就可以让俺觉得快乐——这是“过程性的快感”；当连续几个月，终于完成了某个软件，这时候体验到的是“结果性的快感”。<br>　　“过程性的快感”虽然强度不高，但也很重要——这类快感使得你可以【持久地】从事感兴趣的活动（即便在你尚未获得成果的阶段，它也在起作用）。</p><p>◇成瘾性</p><p>如前一个小节所说，真正的兴趣会给你带来快感。因此，真正的兴趣通常也会带来【成瘾性】。<br>　　（关于“快感”与“成瘾性”的关系，这是心理学和脑神经学的重要研究话题。但是这个话题与本文的主题无关，所以俺就不展开了）<br>　　再拿俺自己举例：<br>　　比如俺连续几周没有写代码，就会手痒。虽然在许多年前已经转为管理岗位，不需要亲自写代码，但俺还是尽量找机会亲自操刀——在公司开发的软件中，挑一两个有难度的模块来写。<br>　　另外，在没有开博客之前，俺也会在业余时间写点小工具啥的练练手（可惜近几年维护博客耗费了太多时间）</p><p>◇愿意付出较高的代价</p><p>从事自己真正感兴趣的活动，你会愿意付出其它的代价。为啥捏？因为前面提及的“快感”会给予你补偿。换句话说：快感会抵消掉“付出代价”所导致的负面情绪。<br>　　举例：<br>　　某个摄影爱好者为了拍摄到火山喷发的镜头，愿意冒生命危险待在火山口附近。</p><p>◇持续的自我提升（走出心理舒适区）</p><p>如果某个活动是你真正的兴趣，那你不会满足于“只停留在该领域的心理舒适区”。你会不断尝试去突破自己的心理舒适区。通过不断地突破自己的心理舒适区，你在这个领域的能力就会得到提升；同时，你的心理舒适区的范围也扩大了。<br>　　当然，突破心理舒适区不一定容易，有的时候甚至是很困难的。但是在突破的过程中，“过程性的快感”会伴随着你；一旦实现突破，你会获得“结果性的快感”。</p><p>突破心理舒适区导致的能力提升，大致有两类：“深度”的提升 ＆“广度”的提升。对这两类，分别举例如下：<br>　　举例1：<br>　　假设有个热衷于编程的 C++ 程序员，通过不断学习，让自己从 C++ 的新手变成老手——这属于“深度的提升”。<br>　　举例2：<br>　　假设有个热衷于编程的 C++ 程序员，通过不断学习，又学会了另一门编程语言 Lisp——这属于“广度的提升”。</p><p>◇存在【心流】（物我两忘）的现象</p><p>当你从事自己真正感兴趣的活动，有时候你会进入到【心流】的状态。这词儿可不是俺杜撰滴，而是心理学的专门术语，洋文称之为“flow”，相关的维基词条在“这里”。<br>　　这种状态大概就是传说中的“物我两忘”。在这种状态下，你会忘记了时间的存在，甚至忘记自己的存在，全身心都融入到你感兴趣的活动当中。<br>　　举例：<br>　　某些非常热衷围棋的爱好者，在对弈或打谱的时候，就会进入到这种状态。此时他们的眼中只有棋盘，周围的世界仿佛都不存在了。</p><p>★【真正的】兴趣爱好对人生的影响</p><p>如果你能找到自己真正的兴趣爱好，对你的人生至少会产生如下一些影响：</p><p>◇更多的快乐</p><p>这是最显著的一个影响，也是俺在前面章节多次提及的“快感”。</p><p>◇更充实的生活</p><p>有了真正的兴趣爱好，通常就不需要找一些事情来“打发时间”。反之，你可以把所有的闲暇时间都用在你感兴趣的领域和活动。<br>　　相比之下，那些经常感叹生活空虚的人，通常都缺乏真正的兴趣和爱好。</p><p>◇兴趣与工作的结合</p><p>如果你够幸运的话，还可以让“自己的兴趣”成为“自己的职业”——这是很幸福的事情 😃 如此一来，就把“工作”和“娱乐”合为一体。你将不再有“工作时间”和“业余时间”的差异——不论是“工作时间”还是“业余时间”，对你而言都是【娱乐时间】。这当然很爽！<br>　　当这两者统一之后，还有更多其它的好处。比如说，你在自己的工作中，更有可能比别人走得更远，因此也就更有可能成为该领域的【优秀】者。（请注意，“优秀”和“卓越”是完全不同滴，别混淆了。在《成功学批判——简述其危害性及各种谬误》一文中，俺澄清了这两者的差异）<br>　　一旦你成为某个领域的优秀者，你就具备了【个人竞争优势】。这种情况下，你通常不至于太缺钱（当然，也会有极少数例外）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;来源网络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;★哪些东西【不能算】兴趣和爱好？&lt;/p&gt;
&lt;p&gt;在本文的开头，俺想从【反面】来陈述这个话题——点评一下那些“容易跟兴趣爱好混为一谈的东西”。（对这些东西，俺称之为“伪兴趣”）&lt;br&gt;
　　通过识别
      
    
    </summary>
    
    
      <category term="转载" scheme="https://x1nes.github.io/blog/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>vue3-new-feature</title>
    <link href="https://x1nes.github.io/blog/posts/20a24eb5/"/>
    <id>https://x1nes.github.io/blog/posts/20a24eb5/</id>
    <published>2020-12-29T15:47:59.000Z</published>
    <updated>2021-07-19T16:16:42.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总结一下最近一段时间学习 vue3 的收获</p></blockquote><h2 id="功能方面"><a class="header-anchor" href="#功能方面">¶</a>功能方面</h2><h4 id="composition-api-组合api"><a class="header-anchor" href="#composition-api-组合api">¶</a>Composition API (组合API)</h4><p>Composition API 的灵感来自于 React Hooks ，是比 mixin 更强大的存在。它可以提高代码逻辑的可复用性，从而实现与模板的无关性；同时函数式的编程使代码的可压缩性更强。另外，把 Reactivity 模块独立开来，意味着 Vue3.0 的响应式模块可以与其他框架相组合。<br>官方例子</p><pre><code class="language-javascript">    // 鼠标位置侦听逻辑     function useMouse() {            const state = reactive({                x: 0,                y: 0            })            const update = e =&gt; {                state.x = e.pageX                state.y = e.pageY            }            onMounted(() =&gt; {                window.addEventListener('mousemove', update)            })            onUnmounted(() =&gt; {                window.removeEventListener('mousemove', update)            })            return toRefs(state)        }</code></pre><p>总的来说，就是把相关的逻辑单独拿出来提高代码复用</p><h4 id="全局挂载-配置api更改"><a class="header-anchor" href="#全局挂载-配置api更改">¶</a>全局挂载/配置API更改</h4><p>vue2 使用 new Vue 创建实例，通过全局设置config配置vue的可选配置。<br>vue3 使用 createApp 定义的某个 Vue 程序。它可以使你的代码更易于理解，并且不易出现由第三方插件引发的意外问题。目前，如果某些第三方解决方案正在修改 Vue 对象，那么它可能会以意想不到的方式（尤其是全局混合）影响你的程序，而 Vue 3 则没有这个问题.</p><pre><code class="language-javascript">import { createApp } from 'vue'import App from './App.vue'const app = createApp(App)app.config.ignoredElements = [/^app-/]app.use(/* ... */)app.mixin(/* ... */)app.component(/* ... */)app.directive(/* ... */)app.mount('#app')</code></pre><h4 id="fragments-片段"><a class="header-anchor" href="#fragments-片段">¶</a>Fragments(片段)</h4><p>在书写vue2时，由于组件必须只有一个根节点，很多时候会添加一些没有意义的节点用于包裹。Fragment组件就是用于解决这个问题的（这和React中的Fragment组件是一样的）。</p><h4 id="suspense"><a class="header-anchor" href="#suspense">¶</a>Suspense</h4><p>同样的，这和React中的Supense是一样的。Suspense 让你的组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容。</p><pre><code class="language-html">&lt;Suspense&gt;  &lt;template &gt;    &lt;Suspended-component /&gt;  &lt;/template&gt;  &lt;template #fallback&gt;    Loading...  &lt;/template&gt;&lt;/Suspense&gt;</code></pre><h4 id="v-model-支持多个"><a class="header-anchor" href="#v-model-支持多个">¶</a>v-model 支持多个</h4><p>在 3.x 版本中，在自定义组件上使用 v-model 相当于传递了一个 modelValue 属性以及触发一个 update:modelValue 事件。<br>如果要改变绑定的属性名，只需要给 v-model 传递一个参数就好了：</p><pre><code class="language-html">&lt;KyrieInput v-model:title=&quot;name&quot; /&gt;&lt;!-- 等同于 --&gt;&lt;KyrieInput :title=&quot;name&quot; @update:title=&quot;name = $event&quot; /&gt;</code></pre><p>这个写法还彻底代替了 .sync 修饰符，并且支持统一组件绑定多个 v-model</p><h4 id="portals"><a class="header-anchor" href="#portals">¶</a>Portals</h4><p>Teleport其实就是React中的Portal。Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。</p><h2 id="实现逻辑重大更改"><a class="header-anchor" href="#实现逻辑重大更改">¶</a>实现逻辑重大更改</h2><h4 id="响应式原理"><a class="header-anchor" href="#响应式原理">¶</a>响应式原理</h4><p>Object.defineProperty -&gt; Proxy<br>Object.defineProperty是一个相对比较昂贵的操作，因为它直接操作对象的属性，颗粒度比较小。将它替换为es6的Proxy，在目标对象之上架了一层拦截，代理的是对象而不是对象的属性。这样可以将原本对对象属性的操作变为对整个对象的操作，颗粒度变大。</p><p>javascript引擎在解析的时候希望对象的结构越稳定越好，如果对象一直在变，可优化性降低，proxy不需要对原始对象做太多操作。</p><p>同时，有了Proxy，就不用考虑新增属性的响应行为了，是时候要跟$set说声再见了。</p><h2 id="性能方面"><a class="header-anchor" href="#性能方面">¶</a>性能方面</h2><p>双向响应原理由Object.defineProperty改为基于ES6的Proxy，使其颗粒度更大，速度更快，且消除了之前存在的警告；<br>重写了 Vdom ，突破了 Vdom 的性能瓶颈<br>进行了模板编译的优化<br>进行了更加高效的组件初始化</p><h4 id="支持tree-shaking-更加解耦的代码结构"><a class="header-anchor" href="#支持tree-shaking-更加解耦的代码结构">¶</a>支持tree-shaking , 更加解耦的代码结构</h4><p>支持了 tree-shaking （剪枝）：像修剪树叶一样把不需要的东西给修剪掉，使 Vue3 的体积更小。</p><p>需要的模块才会打入到包里，优化后的 Vue3.0 的打包体积只有原来的一半（13kb）。哪怕把所有的功能都引入进来也只有23kb，依然比 Vue2.x 更小。像 keep-alive 、 transition 甚至 v-for 等功能都可以按需引入。</p><h4 id="模板性能提升"><a class="header-anchor" href="#模板性能提升">¶</a>模板性能提升</h4><p>在之前的VDOM中，如果msg值发生改变，整个模版中的所有元素都需要重新渲染。但在Vue3.0中，在这个模版编译时，编译器会在动态标签末尾加上 /* Text*/ PatchFlag。只能带patchFlag 的 Node 才被认为是动态的元素，会被追踪属性的修改。并且 PatchFlag 会标识动态的属性类型有哪些，比如这里 的TEXT 表示只有节点中的文字是动态的。<br>每一个Block中的节点，就算很深，也是直接跟Block一层绑定的，可以直接跳转到动态节点而不需要逐个逐层遍历。<br>既有VDOM的灵活性，又有性能保证。<br>vue3 使用 hoistStatic 静态节点提升<br>当使用hoistStatic时，所有 静态的节点都被提升到render方法之外。这意味着，他们只会在应用启动的时候被创建一次，而后随着每次的渲染被不停的复用。</p><h4 id="时间分片"><a class="header-anchor" href="#时间分片">¶</a>时间分片</h4><p>在动态节点和数据的量都很大时，那么在数据更新时，js线程就会用很长的时间来执行vdom的相关计算，如果超过了16ms，造成交互或动画等等卡顿现象。而时间分片就是把vdom的大量计算分成多个小任务，保证每个小任务在16ms内执行完，从而不会阻塞用户交互，避免卡顿现象。<br>然鹅，此功能还未包含在vue3的更新中。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/147022323" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/147022323</a><br><a href="https://www.jianshu.com/p/1d2846f2a855" target="_blank" rel="noopener">https://www.jianshu.com/p/1d2846f2a855</a><br><a href="https://v3.vuejs.org/" target="_blank" rel="noopener">https://v3.vuejs.org/</a><br><a href="https://segmentfault.com/a/1190000024580501" target="_blank" rel="noopener">https://segmentfault.com/a/1190000024580501</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;总结一下最近一段时间学习 vue3 的收获&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;功能方面&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#功能方面&quot;&gt;¶&lt;/a&gt;功能方面&lt;/h2&gt;
&lt;h4 id=&quot;compositi
      
    
    </summary>
    
    
      <category term="vue3" scheme="https://x1nes.github.io/blog/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>开启网页3D效果之旅</title>
    <link href="https://x1nes.github.io/blog/posts/3d46f50c/"/>
    <id>https://x1nes.github.io/blog/posts/3d46f50c/</id>
    <published>2019-07-27T21:30:31.000Z</published>
    <updated>2021-07-19T16:16:42.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上古时代，当<code>html</code>语言和<code>http</code>协议刚被发明出来时，这些专家们也许怎么也想不到，当初发明来共享文本的技术如今统治了几乎整个互联网行业。当第一个网页被打开时，上面只有简陋的一个表单，甚至做一个简单的过渡变色效果，都要借用<code>java Applet</code>，后来要借助<code>javascript</code>。短短十几年过去，现在有了<code>css3</code>，你只需定义简单的<code>transition</code>,就可以实现各种神奇的过渡效果。</p></blockquote><p>本文不是介绍<code>css3</code>动画以及用法的，因此需要读者预先了<code>transition</code>,<code>transform</code>等属性。</p><p>###　回顾下<code>CSS3</code>的基础属性</p><h4 id="1-transition"><a class="header-anchor" href="#1-transition">¶</a>1.<code>transition</code></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition" target="_blank" rel="noopener">Transition</a>是被用到最多的也是最简单的<code>CSS3</code>动画类型，如果你想实现鼠标划过更改背景色的功能，用<code>transition</code>是最简单的方式。</p><pre><code class="language-html">&lt;button&gt;会变色的按钮&lt;/button&gt;</code></pre><pre><code class="language-css">button {    transition: all 0.8s ease;     background-color: red;}button:hover {    background-color: #EEEEEE;}</code></pre><p>下面是效果：</p><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master/img/1.gif" alt="gif"></p><p><strong>transition</strong> <a href="https://developer.mozilla.org/en/CSS" target="_blank" rel="noopener">CSS</a> 属性是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-property" target="_blank" rel="noopener"><code>transition-property</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-duration" target="_blank" rel="noopener"><code>transition-duration</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function" target="_blank" rel="noopener"><code>transition-timing-function</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-delay" target="_blank" rel="noopener"><code>transition-delay</code></a> 的一个<a href="https://developer.mozilla.org/en-US/docs/CSS/Shorthand_properties" target="_blank" rel="noopener">简写属性</a>。分别是可变换属性，持续时间，变换的过度函数(就是变换的加速度曲线)，效果生效的延时。</p><p>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition" target="_blank" rel="noopener">Transition</a>的更多<code>API</code>，请查看<code>MDN</code>的文档。</p><h4 id="2-transform"><a class="header-anchor" href="#2-transform">¶</a>2.<code>transform</code></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform" target="_blank" rel="noopener">transform</a>是执行元素旋转，缩放，位移，倾斜的<code>css</code>属性，它是通过修改视觉上的坐标空间实现的。</p><p>⚠️ 只能转换盒子模型定位的元素。</p><ul><li>旋转<br><code>rotate(a)</code><br>a是一种<angle>，表示旋转的角度，比如<code>30deg</code>。 正角度表示了顺时针的旋转，负角度表示逆时针的旋转。</angle></li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;rotated&quot;&gt;旋转45度&lt;/div&gt;&lt;div class=&quot;rotated2&quot;&gt;旋转90度&lt;/div&gt;</code></pre><pre><code class="language-css">div { width: 80px; height: 80px; background-color: skyblue;}.rotated { transform: rotate(45deg);  background-color: pink;}.rotated2 {   transform: rotate(90deg);    background-color: blue;   color: #ffffff;}</code></pre><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master//img/2.gif" alt="gif"></p><ul><li>缩放<br><code>scale(a,b,c)</code><br><em>单一数值</em><br>单一的数值即指定了一个缩放系数，同时作用于X轴和Y轴让该元素进行缩放，相当于指定了单个值的scale()(2D缩放)函数。<br><em>两个长度/百分比值</em><br>两个数值即分别指定了2D比例的X轴和Y轴的缩放系数，相当于指定了两个值的scale()（2D缩放）函数。<br><em>三个长度/百分比值</em><br>三个数值即分别指定了3D比例的X轴、Y轴和Z轴的缩放系数. 相当于一个scale3d()函数。<br>none<br>指定不进行缩放。</li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;scale&quot;&gt;大2倍&lt;/div&gt;&lt;div class=&quot;scale2&quot;&gt;水平1.5倍，垂直2倍&lt;/div&gt;</code></pre><pre><code class="language-css">div { width: 80px; height: 80px; background-color: skyblue; text-align: center; transform-origin: 0 0;}.scale { transform: scale(2); background-color: pink;}.scale2 {   transform: scale(1.5, 2);   background-color: blue;   color: #ffffff;}</code></pre><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master//img/3.gif" alt="gif"></p><ul><li>位移<br><code>translate(x,y)</code><br>x,y 分别是 x,y轴移动的距离。</li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;translate&quot;&gt;右，下移30px&lt;/div&gt;</code></pre><pre><code class="language-css">div { width: 80px; height: 80px; background-color: skyblue; text-align: center; transform-origin: 0 0;}.translate { transform: translate(30px, 30px); background-color: pink;}</code></pre><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master//img/4.gif" alt="gif"></p><ul><li>倾斜</li></ul><p><code>skew(x-angle,y-angle)</code><br>定义沿着 X 和 Y 轴的 2D 倾斜转换。</p><pre><code class="language-html">&lt;div&gt;Normal&lt;/div&gt;&lt;div class=&quot;skewed&quot;&gt;Skewed&lt;/div&gt;</code></pre><pre><code class="language-css">div {  width: 80px;  height: 80px;  background-color: skyblue;}.skewed {  transform: skew(10deg); /* Equal to skewX(10deg) */  background-color: pink;}</code></pre><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master//img/5.gif" alt="gif"></p><h4 id="3-animation"><a class="header-anchor" href="#3-animation">¶</a>3.<code>animation</code></h4><p>我们可以把<code>transition</code>和<code>transform</code> 结合在一起使用，就实现动感十足的html页面。<br>但是，<code>transition</code>只能实现开始和结束的状态，并且只能“动一次”。</p><p>还有更加强大的<code>animation</code>属性，可以制作不间断，存在中间状态的动画。</p><p>💥 这里穿插介绍一个<code>animation</code>动画库，<a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener">https://daneden.github.io/animate.css/</a></p><p><code>animate.css</code>里面实现了很多常见的淡入淡出，方向移动的动画，可以看下源码，然后自己实现动画的时候就有头绪了。</p><p>下面是一个简单的fadeout 效果的源代码</p><pre><code class="language-css">@keyframes fadeOutDown {  from {    opacity: 1;  }  to {    opacity: 0;    transform: translate3d(0, 100%, 0);  }}</code></pre><p>点击<code>animate.css</code>官网可以查看更多的效果哦。<img src="https://raw.githubusercontent.com/x1nes/imageUrl/master/img/6.gif" alt="gif"></p><p>理论上，任何单独的<code>css</code>属性都可以拿来做动画，但是注意一点🙉从无到有，不要用<code>display:none</code>,应该用<code>opacity</code>属性。</p><p>然后是<code>animate</code>的属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">CSS</a> <strong>animation</strong> 属性是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name" target="_blank" rel="noopener"><code>animation-name</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-duration" target="_blank" rel="noopener"><code>animation-duration</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-timing-function" target="_blank" rel="noopener"><code>animation-timing-function</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-delay" target="_blank" rel="noopener"><code>animation-delay</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-iteration-count" target="_blank" rel="noopener"><code>animation-iteration-count</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-direction" target="_blank" rel="noopener"><code>animation-direction</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-fill-mode" target="_blank" rel="noopener"><code>animation-fill-mode</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-play-state" target="_blank" rel="noopener"><code>animation-play-state</code></a> 属性的一个简写属性形式。</p><p>这里不一一介绍了。</p><h1></h1><h3 id="进入主题-transform的3d效果"><a class="header-anchor" href="#进入主题-transform的3d效果">¶</a>进入主题–<code>transform</code>的<code>3D</code>效果</h3><p>☑️ 网页的<code>3D</code>坐标系：</p><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master//img/1328957-20190425135458622-1593901679.jpg" alt></p><p>如上图，网格就是网页的坐标系。有了这张图，就可以很轻松的想到如何运用<code>css</code>的属性得到想要的效果。</p><h4 id="1-如何使用3d"><a class="header-anchor" href="#1-如何使用3d">¶</a>1.如何使用<code>3d</code></h4><p><code>transform</code>的<code>translate</code>,<code>scale</code>,<code>rotate</code>都有<code>3D</code>效果。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td>定义 3D 转化。</td></tr><tr><td>translateX(<em>x</em>)</td><td>定义 3D 转化，仅使用用于 X 轴的值。</td></tr><tr><td>translateY(<em>y</em>)</td><td>定义 3D 转化，仅使用用于 Y 轴的值。</td></tr><tr><td>translateZ(<em>z</em>)</td><td>定义 3D 转化，仅使用用于 Z 轴的值。</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td>定义 3D 缩放转换。</td></tr><tr><td>scaleX(<em>x</em>)</td><td>定义 3D 缩放转换，通过给定一个 X 轴的值。</td></tr><tr><td>scaleY(<em>y</em>)</td><td>定义 3D 缩放转换，通过给定一个 Y 轴的值。</td></tr><tr><td>scaleZ(<em>z</em>)</td><td>定义 3D 缩放转换，通过给定一个 Z 轴的值。</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td><td>定义 3D 旋转。</td></tr><tr><td>rotateX(<em>angle</em>)</td><td>定义沿 X 轴的 3D 旋转。</td></tr><tr><td>rotateY(<em>angle</em>)</td><td>定义沿 Y 轴的 3D 旋转。</td></tr><tr><td>rotateZ(<em>angle</em>)</td><td>定义沿 Z 轴的 3D 旋转。</td></tr></tbody></table><p>也可以用</p><table><thead><tr><th>属性</th><th>定义</th></tr></thead><tbody><tr><td>matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>, <em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td><td>定义 3D 转换，使用 16 个值的 4x4 矩阵。</td></tr></tbody></table><p>下面是3D变换的例子</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/x1nes/se45nykp/9//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>上面可以看出来，<code>div</code>脱离了平面，但是效果却仿佛还是平面的，因为我们缺少定义了一个关键的属性：</p><p>🏷<code>persspective</code>给元素加上<code>3D</code>透视(近大远小)的效果。</p><pre><code class="language-css">transform: perspective( 600px );// 加在子元素上，给单个元素添加透视/**或者**/perspective: 600px;// 加在父元素上，所有的子元素共享一个3D空间</code></pre><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/x1nes/oy0rwgh7/32//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>看上面的例子，我们可以看出，给单个元素添加，每个元素都有自己的透视空间。</p><p>🏷<code>perspective-orgin</code>默认的变换点都是元素的中心点，如果你想以其他的位置为变换点，那就可以用这个属性来做调整。</p><p>就像<code>transform-origin</code>在2D变换里面设置变换中心点一样。也可以认为是元素的底部位置。</p><p>🏷<code>transform-style</code>这个参数用来共享父元素的3D空间。</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">flat</td><td style="text-align:left">表示所有子元素在2D平面呈现。</td></tr><tr><td style="text-align:left">preserve-3d</td><td style="text-align:left">表示所有子元素在3D空间中呈现。</td></tr></tbody></table><p>🏷<code>backface-visibility</code>可用于隐藏内容的背面。默认情况下，背面可见，这意味着即使在翻转后，变换的内容仍然可见。但当 backface-visibility 设置为 hidden 时，旋转后内容将隐藏，因为旋转后正面将不再可见。</p><h4 id="2-3d和硬件加速"><a class="header-anchor" href="#2-3d和硬件加速">¶</a>2.<code>3d</code>和硬件加速</h4><p>动画卡顿是在移动web开发时经常遇到的问题，解决这个问题一般会用到<strong>css3硬件加速</strong>。</p><p>❔什么是硬件加速？</p><p>DOM树和CSS结合后形成渲染树。渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理。GPU中transform是不会触发 repaint 的，这一点非常类似3D绘图功能，最终这些使用 transform的图层都会由[独立的合成器进程进行处理]。<a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="noopener">https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p><p>因此，最简单的开启硬件加速的方法就是设置<code>translateZ(0)</code>。</p><p>但是，开启硬件加速后，会加快用电，并且不合适的使用硬件加速，会造成页面卡顿。</p><p>参考：<a href="https://div.io/topic/1348" target="_blank" rel="noopener">https://div.io/topic/1348</a> 看下<code>index</code>属性造成不该在复合层（composited layer）中的元素造成页面卡顿的例子。</p><h4 id="3-3d动画的一个实例"><a class="header-anchor" href="#3-3d动画的一个实例">¶</a>3. <code>3d</code>动画的一个实例</h4><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/x1nes/tj1of0m5//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>利用<code>translate</code> 和 <code>rotate</code> 制作的一个骰子。</p><p>代码来源：</p><p><a href="https://www.cnblogs.com/zhangnan35/p/10709876.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangnan35/p/10709876.html</a></p><p>参考：</p><p><a href="https://www.jianshu.com/p/f8b1d6e598db" target="_blank" rel="noopener">https://www.jianshu.com/p/f8b1d6e598db</a></p><p><a href="http://beiyuu.com/css3-animation" target="_blank" rel="noopener">http://beiyuu.com/css3-animation</a></p><p><a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="noopener">https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上古时代，当&lt;code&gt;html&lt;/code&gt;语言和&lt;code&gt;http&lt;/code&gt;协议刚被发明出来时，这些专家们也许怎么也想不到，当初发明来共享文本的技术如今统治了几乎整个互联网行业。当第一个网页被打开时，上面只有简陋的一个表单，甚至做一个简单
      
    
    </summary>
    
    
      <category term="css" scheme="https://x1nes.github.io/blog/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>使用一段时间react的总结</title>
    <link href="https://x1nes.github.io/blog/posts/1b7d8e2e/"/>
    <id>https://x1nes.github.io/blog/posts/1b7d8e2e/</id>
    <published>2019-07-25T01:05:17.000Z</published>
    <updated>2021-07-19T16:16:42.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近比较忙，先列下大纲，然后在逐渐补充</p></blockquote><h1>组件的几种常见形式</h1><h2 id="组合还是继承"><a class="header-anchor" href="#组合还是继承">¶</a>组合还是继承</h2><h2 id="state还是props"><a class="header-anchor" href="#state还是props">¶</a>state还是props</h2><h2 id="如何减少props传递的层级"><a class="header-anchor" href="#如何减少props传递的层级">¶</a>如何减少<code>props</code>传递的层级</h2><h2 id="受控组件和非受控组件"><a class="header-anchor" href="#受控组件和非受控组件">¶</a>受控组件和非受控组件</h2><h1>组件的生命周期</h1><h2 id="总览"><a class="header-anchor" href="#总览">¶</a>总览</h2><h2 id="react-17-新的生命周期和带来的影响"><a class="header-anchor" href="#react-17-新的生命周期和带来的影响">¶</a>react 17 新的生命周期和带来的影响</h2><h1>ref转发</h1><h1>render props</h1><h1>高阶组件的用法</h1><h1>pureComponent 和 不可变数据</h1><h1>好用的配套npm库</h1><h2 id="classnamse"><a class="header-anchor" href="#classnamse">¶</a>classnamse</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近比较忙，先列下大纲，然后在逐渐补充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;组件的几种常见形式&lt;/h1&gt;
&lt;h2 id=&quot;组合还是继承&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#组合还是继承&quot;&gt;¶&lt;/a&gt;组合还是继承
      
    
    </summary>
    
    
      <category term="react" scheme="https://x1nes.github.io/blog/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>装饰器的简单实现（下）</title>
    <link href="https://x1nes.github.io/blog/posts/72b1723d/"/>
    <id>https://x1nes.github.io/blog/posts/72b1723d/</id>
    <published>2019-07-03T20:15:02.000Z</published>
    <updated>2021-07-19T16:16:42.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上文介绍了装饰模式，装饰器语法，今天继续说一下怎么用javascript实现自定义装饰器。</p></blockquote><h3 id="启用装饰器语法"><a class="header-anchor" href="#启用装饰器语法">¶</a>启用装饰器语法</h3><p>目前<code>decorator</code>语法只是题案，想要使用装饰器，需要安装<code>babel</code>和<code>webpack</code>并结合<code>babel/plugin-proposal-decorators</code> 插件。</p><p>关于如何配置请参考<code>babel</code>插件的配置文档。</p><p>或者你也可以直接到 <a href="https://babeljs.io/repl/" target="_blank" rel="noopener">https://babeljs.io/repl/</a> 这个地址编写代码，它提供了一个在线的<code>repl</code>环境，可以直接运行<code>es6</code>代码,记得勾选左侧的<code>Experimental</code>来启用装饰器语法。</p><p>🔑 <code>es2015</code>,<code>es2016</code>,<code>es2017</code>和<code>es6</code>之间的关系：</p><blockquote><p>ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。</p></blockquote><h3 id="类装饰器-方法装饰器和属性装饰器"><a class="header-anchor" href="#类装饰器-方法装饰器和属性装饰器">¶</a>类装饰器，方法装饰器和属性装饰器</h3><h5 id="类装饰器"><a class="header-anchor" href="#类装饰器">¶</a>类装饰器</h5><p>类装饰器就是用来修改类的行为，它标注在类定义的上方。</p><pre><code class="language-javascript">@testableclass MyTestableClass {  // ...}function testable(target) { // target 就是被装饰的类  target.isTestable = true;}MyTestableClass.isTestable // true</code></pre><p>这是一个简单的类装饰器，它给被装饰的类添加了一个<code>isTestable</code>的静态属性。</p><p>上面是个简单的例子，下面来个稍微复杂的。<br>想一下，如果我们想给装饰器传参数，要怎么做？熟悉高阶函数的同学一定会立刻想到，函数可以返回函数，只要在装饰器函数外面再加一层函数就可以了。</p><pre><code class="language-javascript">function testable(isTrue) {return function(target) {target.isTestable = isTrue}}@testable(false)class MyTestableClass {}MyTestableClass.isTestable  // false</code></pre><p>上面是给类添加静态属性，如果想给实例添加属性，需要把属性添加在<code>prototype</code>上</p><pre><code class="language-javascript">function testable(isTrue) {return function(target) {target.prototype.isTestable = isTrue}}</code></pre><p>🔑 修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p><p>接下来来个稍微复杂一点的例子，用装饰器实现<code>mixin</code>,<br>🔑 mixin模式就是一些提供能够被一个或者一组子类简单继承功能的类,意在重用其功能。</p><pre><code class="language-javascript">function mixin(foo) {return function(target){Object.assign(target.prototype,foo) // Onject.assign 是es6里面的Object的新函数，用来把第二个参数的属性合并到第一个参数上 因为这里传入的是类（也就是构造函数），想要在实例上添加属性，需要合并到原型对象上。}}const Foo = {sayHi(){console.log('hi')}}@mixin(Foo)class Target{}new Target().sayHi()// Hi</code></pre><p>有了装饰器，之前那些烦人的样板函数就可以用装饰器代替了，比如我们用<code>redux</code>和<code>react</code>时，需要把<code>ui</code>组件和逻辑组件合并，经常需要写下面的代码：</p><pre><code class="language-javascript">class MyReactComponent extends React.Component {}export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</code></pre><p>有了装饰器，就可以改写上面的代码。</p><pre><code class="language-javascript">@connect(mapStateToProps, mapDispatchToProps)export default class MyReactComponent extends React.Component {}</code></pre><h5 id="方法和属性的装饰"><a class="header-anchor" href="#方法和属性的装饰">¶</a>方法和属性的装饰</h5><p>上面的装饰器定义函数我们只用到了一个参数，实际上，在装饰类的属性/方法时他有三个函数。</p><pre><code class="language-javascript">/*** target 被装饰的类的原型对象,需要注意，装饰class和class的属性，第一个参数是不一样的，装饰class时，是构造函数，也就是类本身* key 要修饰的属性名* descriptor 该属性的描述对象*/function decorator(target,key,descriptor){}</code></pre><p>🔑 关于描述对象，不熟悉的可以去看<code>js高级程序设计</code>关于 <code>defineProperty</code> 和 <code>defineProperties</code>的介绍，这两个方法就是用来定义和修改对象的内部属性。<br>举一个常见的例子，在每次函数执行前后，把函数的参数和结果打印出来</p><pre><code class="language-javascript">function log(target,key,descriptor) {var old = descriptor.valuedescriptor.value = function(...args) {console.log(`call ${key} with,`,...args)const result = old.call(this,...args)console.log(`result is ${result}`)return result}return descriptor}class Util {@logadd(a,b) {return a + b}}const util = new Util()util.add(1,2)// 这时，控制台会打印出日志// call add with, 1 2// result is 3</code></pre><p>来一个可缓存的装饰器</p><pre><code class="language-javascript">function cacheable(target,key,descriptor) {const old = descriptor.valueif( typeof old !== 'function' ) {throw new Error(&quot;must be a function&quot;)}const cache = {}descriptor.value = function(...args) {const key = JSON.stringify(args)if(cache[key]) {return cache[key]} else {cache[key] = old.call(this,...args)return cache[key]}}return descriptor}class Util {@cacheableadd(a,b) {console.log(&quot;add&quot;,a,b)return a + b}}const util = new Util()util.add(1,2)util.add(1,2)util.add(1,2)// 只有第一次运行会打印出 add 1 2</code></pre><p>同样的，我们也可以实现属性上的装饰器，比如实现一个类似<code>java</code>包装类</p><pre><code class="language-javascript">class Integer{constructor(num){this.value = num}display() {console.log(`this is a boxing value , the value is ${this.value}`)}}function boxing(target,key,descriptor) {    let v = descriptor.initializer &amp;&amp; descriptor.initializer.call(this);    v= new Integer(v)return {        enumerable: true,            configurable: true,            get: function() {                return v;            },            set: function(c) {                v = new Integer(c);            }    }} class Number {@boxinga=2}let number = new Number()number.a.display()// this is a boxing value , the value is 2number.a = 4number.a.display()// this is a boxing value , the value is 4</code></pre><p>这样，我们就实现了一个简单的包装<code>Integer</code>。</p><p>如果我们每次赋值的时候，都希望检查一下数据类型，可以这样做</p><pre><code class="language-javascript">function check(type) {return function(target,key,descriptor) {let v = descriptor.initializer &amp;&amp; descriptor.initializer.call(this)return {        enumerable: true,            configurable: true,            get: function() {                return v;            },            set: function(c) {if(typeof c !== type) {throw new Error(&quot;error type&quot;)}v = c}        }    }}</code></pre><h3 id="第三方库"><a class="header-anchor" href="#第三方库">¶</a>第三方库</h3><p><code>core-decorators.js</code>是一个第三方模块，提供了一些常见的装饰器<br>比如：</p><pre><code class="language-javascript">// @autobindimport { autobind } from 'core-decorators';class Person {  @autobind  getPerson() {    return this;  }}let person = new Person();let getPerson = person.getPerson;getPerson() === person;// true// @readonlyimport { readonly } from 'core-decorators';class Meal {  @readonly  entree = 'steak';}var dinner = new Meal();dinner.entree = 'salmon';// Cannot assign to read only property 'entree' of [object Object]</code></pre><p>还有更多不再阐述。</p><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>上文只是简单对装饰器模式做了基本原理的解释和简单demo，具体在实战中如何应用，还需要很多其他的经验，比如多个装饰器嵌套如何使用，如何利用<code>proxy</code>实现装饰器，在上文中都没提及，在接下来的博文里，会完整的实现一个具有实际意义的装饰器例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上文介绍了装饰模式，装饰器语法，今天继续说一下怎么用javascript实现自定义装饰器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;启用装饰器语法&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#启用装饰器语法&quot;&gt;¶&lt;
      
    
    </summary>
    
    
      <category term="javaScript" scheme="https://x1nes.github.io/blog/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>装饰器的简单实现（上）</title>
    <link href="https://x1nes.github.io/blog/posts/72b172aa/"/>
    <id>https://x1nes.github.io/blog/posts/72b172aa/</id>
    <published>2019-07-01T21:29:17.000Z</published>
    <updated>2021-07-19T16:16:42.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>es7</code>为<code>javascript</code>添加了激动人心的新特性----装饰器，不过<code>Typrscript</code>早就支持了装饰器了，装饰器也不是<code>ts</code>特有的语法，实际上<code>python</code>也有装饰器，在<code>oop</code>语言里面，一直都有装饰器模式，也称为<code>decorator</code>，不过都是从语言层面，通过继承和组合实现，现在，我们可以通过语法层面直接实现装饰器了。</p></blockquote><h3 id="什么是装饰器模式"><a class="header-anchor" href="#什么是装饰器模式">¶</a>什么是装饰器模式</h3><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p><code>java</code>里面的装饰器模式:</p><p>参考这个地址：<a href="https://github.com/iluwatar/java-design-patterns/tree/master/decorator" target="_blank" rel="noopener"><strong>decorator</strong></a></p><p>🔼上面的地址是<code>github</code>上一个很有名的各种设计模式的<code>java</code>实现。</p><blockquote><p>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p></blockquote><p>也就是说：动态的将附加职责添加到对象上。装饰器模式为子类化提供了灵活的代替和扩展的功能。</p><p>举个例子：</p><p>我们小时候都打过<code>cs</code>，每个警察或者劫匪都可以拿一把武器，或者是<code>AK47</code>，或者是<code>m16</code>，为了更换武器，我们没必要去创造新的角色实例，可以用装饰器动态的用武器装饰他。</p><pre><code class="language-java">// 创建一个角色接口public interface Person {  void attack();  int getAttackPower();}public class Police implements Person {    void attack(){        Systom.out.print(&quot;I'm attacking you&quot;);    }    int getAttackPower(){        return 5; // 战斗力只有5的渣渣    }}public class AkPolice implements Person {    // 提供构造函数来对目标进行包装    public AkPolice(Police decorted) {        this.decorted = decorted;     }    void attack(){        this.decorted.attack()        Systom.out.print(&quot;I'm attacking with a Ak!!&quot;);//awesome!    }    int getAttackPower(){        return this.decorted.getAttackPower()+100;    }}</code></pre><p>🔼就像上面的简单例子，一个包装类把基本类<code>warped</code>起来，形成了一个新的类，新的类不仅添加了新的动作，还保留了基本类的动作。</p><p>优点：</p><p>👍 装饰模式与继承关系的目的都是要拓展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者“除掉”一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</p><p>👍 通过不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出更多不同行为的组合。</p><p>缺点：</p><p>👎种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</p><p>装饰器语法最常见的应用就是我们熟悉的<code>java</code>里面的<code>AOP</code>(面向切面)编程，在不影响原有功能的情况下，增加新的处理逻辑，比如添加各种<code>filter</code>,这些<code>filter</code>就像洋葱一样层层包裹，最终执行原有的逻辑，但是在之前和之后，都可以随意添加新的行为，因此，特别适合安全检查，缓存，调试，日志记录等等行为。</p><h3 id="装饰器语法"><a class="header-anchor" href="#装饰器语法">¶</a>装饰器语法</h3><p>第一次看到装饰器语法是在使用<code>python</code>的时候，现在<code>es7</code>也实现了装饰器语法。</p><p>首次看到装饰器语法，用过<code>java</code>注解的也许会混到一起，其实这两个东西除了长得像外，原理完全不一样。</p><blockquote><p>Python decorators were inspired in part by Java annotations, and have a similar syntax</p><p>​                                                                                                                      --wikipedia</p></blockquote><p>根据<code>wikipedia</code>的说法，装饰器语法的灵感来源于<code>java</code>的注解，所以他们有类似的语法。</p><p>注解是利用反射，它本身不改变被注解对象的行为和性质，只有理解这些注解的处理器才会改变行为，在运行的时候起作用。</p><p>装饰器实际上是语法糖，利于了<code>python</code>,<code>javascript</code>函数可以赋值，传参的特性，函数是第一公民，函数是对象、是变量，可以作为参数、可以是返回值，对嵌套函数做了简化。</p><p>😋引申：如果想了解更多关于<code>javascript</code>函数式特性的知识，可以看下面⬇️</p><p>[<a href="https://www.bookstack.cn/books/mostly-adequate-guide-chinese" target="_blank" rel="noopener">JS 函数式编程指南中文版</a> ](<a href="https://www.bookstack.cn/read/mostly-adequate-guide-chinese/README.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/mostly-adequate-guide-chinese/README.md</a>)</p><p>相信看完，你会对<code>javascript</code>有新的认识。</p><p>下面重头戏来了，到底在<code>javascript</code>里，怎么实现自己的装饰器呢？</p><p>关键的<code>api</code>是<code>Object.defineProperty</code>。</p><pre><code class="language-javascript">Object.defineProperty(obj, prop, descriptor)</code></pre><p>参数：</p><p><strong>obj</strong> 要在其上定义属性的对象</p><p><strong>prop</strong> 要定义或修改的属性的名称。</p><p><strong>descriptor</strong> 将被定义或修改的属性描述符。</p><p>装饰器可以用到<code>类</code>，属性和类的<code>方法</code>上，不能用于<code>function</code>❔<a href="http://es6.ruanyifeng.com/#docs/decorator#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BF%AE%E9%A5%B0%E5%99%A8%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%EF%BC%9F" target="_blank" rel="noopener">为什么修饰器不能用于函数？</a></p><p>👍想详细了解装饰器语法，可以去看阮一峰老师的<code>es6</code>教程</p><p><a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">修饰器</a></p><p>下篇博文，我会用实例代码实现不同的装饰器（等我看完上面的教程先😄)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;es7&lt;/code&gt;为&lt;code&gt;javascript&lt;/code&gt;添加了激动人心的新特性----装饰器，不过&lt;code&gt;Typrscript&lt;/code&gt;早就支持了装饰器了，装饰器也不是&lt;code&gt;ts&lt;/code&gt;特有的语法，实际上
      
    
    </summary>
    
    
      <category term="javaScript" scheme="https://x1nes.github.io/blog/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>Performance--一个用来获取页面性能的接口</title>
    <link href="https://x1nes.github.io/blog/posts/94e1353c/"/>
    <id>https://x1nes.github.io/blog/posts/94e1353c/</id>
    <published>2019-06-25T14:29:02.000Z</published>
    <updated>2021-07-19T16:16:42.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近被问到一个问题，如何判断页面加载时间，我第一时间想到的是打开<code>devtool</code>看下<code>Network</code>下面</p><p><code>DOMContentLoaded</code>和<code>load</code>分别用了多久，如果自己写的话，要用到<code>window.onload</code>函数，但是实际上，web已经给出了<code>api</code>，获取页面性能，并且大部分现代浏览器也支持这个<code>api</code>.</p></blockquote><h3 id="performance简介"><a class="header-anchor" href="#performance简介">¶</a><strong>Performance</strong>简介</h3><p>根据<code>mdn</code>里面的说法:</p><blockquote><p><strong>Performance</strong> 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API" target="_blank" rel="noopener">Navigation Timing API</a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API" target="_blank" rel="noopener">User Timing API</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API" target="_blank" rel="noopener">Resource Timing API</a>。</p></blockquote><p>并且，这些数据是只读的。</p><p><code>preformance</code>对象有三个标准属性，和一个<code>chrome</code>添加的非标准库–<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/memory" target="_blank" rel="noopener"><code>performance.memory</code></a>，用来获取到基本内存的使用情况，一般来说不要用这个非标准的<code>api</code>。</p><p>👎<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/navigation" target="_blank" rel="noopener"><code>Performance.navigation</code></a> [只读]</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceNavigation" target="_blank" rel="noopener"><code>PerformanceNavigation</code></a> 对象提供了在指定的时间段里发生的操作相关信息，包括页面是加载还是刷新、发生了多少次重定向等等。Not available in workers.</p><p>👎<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/timing" target="_blank" rel="noopener"><code>Performance.timing</code></a> [只读]</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming" target="_blank" rel="noopener"><code>PerformanceTiming</code></a> 对象包含延迟相关的性能信息。Not available in workers.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/memory" target="_blank" rel="noopener"><code>performance.memory</code></a></p><p>其是 Chrome 添加的一个非标准扩展，这个属性提供了一个可以获取到基本内存使用情况的对象。<strong>不应该</strong>使用这个非标准的 API。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/timeOrigin" target="_blank" rel="noopener"><code>Performance.timeOrigin</code></a> [只读]</p><p>返回性能测量开始时的时间的高精度时间戳。</p><p>关于更精确的资料请查看<code>mdn</code>官方文档。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">Performance</a></p><h3 id="如何根据performance-timing获取加载时间"><a class="header-anchor" href="#如何根据performance-timing获取加载时间">¶</a>如何根据<code>Performance.timing</code>获取加载时间</h3><p>在此之前，读者需要明白一点浏览器工作的基本流程和原理，比如经常在面试时被问到的“从url输入到页面加载经过了什么流程？”</p><p>这里有几篇非常详细的文章（最起码是我遇到的最详细的，如果你看到过更详细的，或者还有其他补充，请在下方留言，万分感谢😙 ），介绍了这个流程。</p><p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">从输入URL到页面加载发生了什么</a><br><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p><p>也就是说，你最起码要知道<code>dns</code>解析，<code>http</code>请求，页面渲染等认识。</p><p><code>timing</code>就是从输入<code>url</code>到页面展示的全过程的时间统计，单位是毫秒，只读。</p><p>➕ 属性：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/navigationStart" target="_blank" rel="noopener"><code>PerformanceTiming.navigationStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了从同一个浏览器上下文的上一个文档卸载(unload)结束时的UNIX时间戳。如果没有上一个文档，这个值会和PerformanceTiming.fetchStart相同。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/unloadEventStart" target="_blank" rel="noopener"><code>PerformanceTiming.unloadEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了<code>unload</code>事件抛出时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/unloadEventEnd" target="_blank" rel="noopener"><code>PerformanceTiming.unloadEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了<code>unload</code>事件处理完成时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/redirectStart" target="_blank" rel="noopener"><code>PerformanceTiming.redirectStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了第一个HTTP重定向开始时的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/redirectEnd" target="_blank" rel="noopener"><code>PerformanceTiming.redirectEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/fetchStart" target="_blank" rel="noopener"><code>PerformanceTiming.fetchStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了浏览器准备好使用HTTP请求来获取(fetch)文档的UNIX时间戳。这个时间点会在检查任何应用缓存之前。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domainLookupStart" target="_blank" rel="noopener"><code>PerformanceTiming.domainLookupStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了域名查询开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 <code>PerformanceTiming.fetchStart一致。</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domainLookupEnd" target="_blank" rel="noopener"><code>PerformanceTiming.domainLookupEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了域名查询结束的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 <code>PerformanceTiming.fetchStart一致。</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/connectStart" target="_blank" rel="noopener"><code>PerformanceTiming.connectStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/connectEnd" target="_blank" rel="noopener"><code>PerformanceTiming.connectEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/secureConnectionStart" target="_blank" rel="noopener"><code>PerformanceTiming.secureConnectionStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/requestStart" target="_blank" rel="noopener"><code>PerformanceTiming.requestStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/responseStart" target="_blank" rel="noopener"><code>PerformanceTiming.responseStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/responseEnd" target="_blank" rel="noopener"><code>PerformanceTiming.responseEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domLoading" target="_blank" rel="noopener"><code>PerformanceTiming.domLoading</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前网页DOM结构开始解析时（即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState" target="_blank" rel="noopener"><code>Document.readyState</code></a>属性变为“loading”、相应的 <code>readystatechange</code>事件触发时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domInteractive" target="_blank" rel="noopener"><code>PerformanceTiming.domInteractive</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前网页DOM结构结束解析、开始加载内嵌资源时（即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState" target="_blank" rel="noopener"><code>Document.readyState</code></a>属性变为“interactive”、相应的<code>readystatechange</code>事件触发时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domContentLoadedEventStart" target="_blank" rel="noopener"><code>PerformanceTiming.domContentLoadedEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当解析器发送<code>DOMContentLoaded</code> 事件，即所有需要被执行的脚本已经被解析时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domContentLoadedEventEnd" target="_blank" rel="noopener"><code>PerformanceTiming.domContentLoadedEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当所有需要立即执行的脚本已经被执行（不论执行顺序）时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domComplete" target="_blank" rel="noopener"><code>PerformanceTiming.domComplete</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前文档解析完成，即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState" target="_blank" rel="noopener"><code>Document.readyState</code></a> 变为 <code>'complete'且相对应的``readystatechange</code> 被触发时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/loadEventStart" target="_blank" rel="noopener"><code>PerformanceTiming.loadEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回该文档下，<code>load</code>事件被发送时的Unix毫秒时间戳。如果这个事件还未被发送，它的值将会是0。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/loadEventEnd" target="_blank" rel="noopener"><code>PerformanceTiming.loadEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当<code>load</code>事件结束，即加载事件完成时的Unix毫秒时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0.</p><p>🔼 以上属性来自<code>mdn</code>文档。</p><p>根据上面的定义，可以得出下面的常用的时间计算公式：</p><p><strong>常用计算：</strong><br><code>DNS</code>查询耗时 ：<code>domainLookupEnd</code> - <code>domainLookupStart</code><br><code>TCP</code>链接耗时 ：<code>connectEnd</code> -<code>connectStart</code><br><code>request</code>请求耗时 ：<code>responseEnd</code> - <code>responseStart</code><br>解析<code>dom</code>树耗时 ： <code>domComplete</code> - <code>domInteractive</code><br>白屏时间 ：<code>responseStart</code> -<code>navigationStart</code><br><code>domready</code>时间(用户可操作时间节点) ：<code>domContentLoadedEventEnd</code> -<code>navigationStart</code><br><code>onload</code>时间(总下载时间) ：<code>loadEventEnd</code> - <code>navigationStart</code></p><h4 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h4><p>[<a href="https://www.cnblogs.com/bldxh/p/6857324.html" target="_blank" rel="noopener">Performance — 前端性能监控利器</a>](<a href="https://www.cnblogs.com/bldxh/p/6857324.html" target="_blank" rel="noopener">https://www.cnblogs.com/bldxh/p/6857324.html</a>)</p><p><a href="https://w3c.github.io/navigation-timing/#introduction" target="_blank" rel="noopener">w3c文档(<a href="https://w3c.github.io/navigation-timing/#introduction" target="_blank" rel="noopener">https://w3c.github.io/navigation-timing/#introduction</a>)</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming" target="_blank" rel="noopener">mdn文档(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming</a>)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近被问到一个问题，如何判断页面加载时间，我第一时间想到的是打开&lt;code&gt;devtool&lt;/code&gt;看下&lt;code&gt;Network&lt;/code&gt;下面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DOMContentLoaded&lt;/code&gt;和&lt;code&gt;load
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://x1nes.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
</feed>
