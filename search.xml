<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>几个有意思的智力题</title>
      <link href="/blog/posts/b998d6a0/"/>
      <url>/blog/posts/b998d6a0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了锻炼脑力，避免提前患上老年痴呆症，有必要做一些锻炼思维的智力题。🙂这里不给出答案，答案网上都有，只给一点提示。</p></blockquote><h2 id="1-1000瓶药水找毒药"><a class="header-anchor" href="#1-1000瓶药水找毒药">¶</a>1.1000瓶药水找毒药</h2><p>一道经典题，网上都说是微软面试题，但貌似这几年没见微软考过…</p><p>题目描述如下：</p><p>一共 1000 瓶药水，其中 1 瓶有毒药。<br>已知小白鼠喝毒药一天内死<br>若想在一天内找到毒药，最少需要几只小白鼠？</p><p><strong>关键字：二进制</strong></p><h2 id="2-抢30"><a class="header-anchor" href="#2-抢30">¶</a>2.抢30</h2><p>抢 30 是双人游戏<br>游戏规则是：第一个人喊 “ 1 ”或 “ 2 ”，第二个人要接着往下喊一个或两个数，然后再轮到第一个人。两人轮流进行下去。最后喊 30 的人获胜。问喊数字的最佳策略。</p><p><strong>关键字：bash博弈</strong></p><h2 id="3-三个空瓶子"><a class="header-anchor" href="#3-三个空瓶子">¶</a>3.三个空瓶子</h2><p>有三个空瓶子，一个8L，一个5L，一个3L，目前8L的瓶子装满了牛奶。试问，如果在不浪费一滴水和无刻度的情况下，如何测量出4L的牛奶？</p><p><strong>关键字: 模拟，反推</strong></p><h2 id="4-灯泡开关"><a class="header-anchor" href="#4-灯泡开关">¶</a>4.灯泡开关</h2><p>一个圆环上有 100 个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。 设计一种算法，对于任意初始状态，使所有灯泡全亮。</p><p><strong>关键字：模拟，反推，从全灭可以恢复到全亮。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> -智力题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给博客加上pwa</title>
      <link href="/blog/posts/b198188b/"/>
      <url>/blog/posts/b198188b/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给博客加上pwa，断网也可以打开</p></blockquote><h2 id="pwa简介"><a class="header-anchor" href="#pwa简介">¶</a><code>pwa</code>简介</h2><p><code>PWA</code>（<code>Progressive Web Apps</code>，渐进式 <code>Web</code> 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。这些应用无处不在、功能丰富，使其具有与原生应用相同的用户体验优势。这组文档和指南告诉您有关 <code>PWA</code> 的所有信息。</p><h2 id="过程"><a class="header-anchor" href="#过程">¶</a>过程</h2><p>用到了 <code>hexo-pwa</code> 这个插件，在<code>config.yml</code> 里加上配置，会自动生成<code>mainfest.json</code> ,再手动加上<code>sw.js</code>文件。</p><pre><code class="language-yml">pwa:  manifest:    path: manifest.json    body:      name: x1nes      short_name: x1nes      theme_color: white      background_color: white      display: standalone      orientation: portrait      scope: /      start_url: /blog/      icons:        - src: img/logo.png          type: image/png          sizes: 600x600        - src: img/icon-60@2x.png          type: image/png          sizes: 120x120        - src: img/icon-40@2x.png          type: image/png          sizes: 80x80        - src: img/icon-29@2x.png          type: image/png          sizes: 58x58        - src: img/icon-20@2x.png          type: image/png          sizes: 40x40     serviceWorker:    path: /sw.js    preload:      urls:        - /      posts: 5    opts:      networkTimeoutSeconds: 20    routes:      - pattern: !!js/regexp /hm.baidu.com/        strategy: networkOnly      - pattern: !!js/regexp /www.google-analytics.com/        strategy: networkOnly      - pattern: !!js/regexp /pagead2.googlesyndication.com/        strategy: networkOnly      - pattern: !!js/regexp /cdn.jsdelivr.net/        strategy: cacheFirst      - pattern: !!js/regexp /.*\.(js|css|jpg|jpeg|png|gif)$/        strategy: cacheFirst      - pattern: !!js/regexp /\//        strategy: networkFirst  priority: 5</code></pre><p>sw.js</p><pre><code class="language-js">importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js');if (workbox) {    workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' });    workbox.precaching.precache(['/', '/index.html']);    workbox.routing.registerRoute(new RegExp('^https?://x1nes.github.io/?$'), workbox.strategies.networkFirst());    workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst());    workbox.routing.registerRoute(new RegExp('.*.(?:js|css)'), workbox.strategies.staleWhileRevalidate());}</code></pre><p>完成！再次打开页面，就可以看见控制台里<code>application</code>里面的<code>Mainfest</code> 和 <code>service workers</code>里都成功加载了。现在可以把这个网页当作app一样添加到桌面使用了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>地球上还剩一个鸡蛋</title>
      <link href="/blog/posts/11ca1e89/"/>
      <url>/blog/posts/11ca1e89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近的内卷话题，突然想到小时候看到的一篇郑渊洁的小说，挺有意思的，这里转载一下。</p></blockquote><h2 id="地球上还剩一个鸡蛋"><a class="header-anchor" href="#地球上还剩一个鸡蛋">¶</a>地球上还剩一个鸡蛋</h2><p>一</p><p>整个鸡家族都不甘心自己在地球上的地位–任人宰割，供人食用。<br>从１００年前起，鸡家族的有识之士就试图摆脱鸡家族的困境。但每次行动都以鸡的失败告终。人类大获全胜，还不断完善着吃鸡的艺术：现代化养鸡场、填鸡、肯德鸡、扒鸡、烧鸡……真是到了炉火纯青的境界。<br>这还不算，鸡被人类吃得最多，可人类却发明出&quot;黄鼠狼给鸡拜年&quot;的成语嫁祸于黄鼠狼，鸡们确实咽不下这口气。<br>鸡王决定在本世纪末之前扭转鸡家族的处境，他召集幕僚想办法。<br>&quot;要想让人类放弃吃鸡很难。&quot;一位幕僚说。他曾经用１０斤鸡蛋收买了人类中一位写东西的人，让他在报上写文章说，吃鸡容易患癌症。人类照吃不误。<br>&quot;依我看，人吃咱们并不是因为恨咱们，而是说明他们离不开咱们。&quot;另一位年纪大一些的幕僚说，他曾经发明过鸡瘟，但被人类用药物治住了。<br>&quot;有道理。&quot;鸡王点头。示意这位慕僚继续往下说。<br>&quot;大王下一道圣旨，命令所有母鸡停止下蛋。保准人类不会再像现在这样对待咱们了。&quot;幕僚建议。<br>&quot;停止下蛋？&quot;鸡王吃了一惊，这可是断子绝孙的举动。<br>&quot;没有鸡蛋，就不会再有新的鸡出生，光这一点，就够人类伤脑筋的。&quot;幕僚说。<br>鸡王点点头。<br>５分钟后，鸡王向整个鸡家族下达了圣旨：停止下蛋。</p><p>二</p><p>当人类发现全世界所有的母鸡都不下蛋了时，地球上只剩下一个鸡蛋了。<br>人类意识到问题的严重性了，地球上的鸡将吃一只少一只，最终灭绝。人们将不再有鸡肉吃，不再有鸡蛋吃。<br>科学家们想尽一切方法动员母鸡们恢复下蛋，什么音乐刺激法啦，红外线紫外线这线那线照射啦，遗撼的是母鸡们不为所动，不管科学家们想出什么绝活儿，她们就是不下蛋。<br>人类专门为此召开了一个紧急会议，会议的结果是制定了一部关于保护珍贵动物–鸡的法律。鸡终于改变了卑微的地位，加入珍贵动物的行列。<br>人们以拥有一只鸡为荣，狗和猫的地位一落千丈。在公园里时常见到牵着鸡散步的达官贵人。一只鸡的售价已高达上千美元。<br>科学家们研制的延长鸡的寿命的药物刚一问世就被抢购一空。有几个国家的国旗上出现了鸡的图案。这一切都因为母鸡不下蛋了。<br>经营炸鸡的快餐店统统倒闭，老板不是跳楼就是离婚。<br>地球上唯一的的那个鸡蛋更是价值连城，光是守护它的军队就有两个旅之多。这个鸡蛋的妈妈是最后一个听到鸡王的圣旨的，当时她正在下蛋，想把这个蛋退回到肚子里已经不可能了，于是她成了地球上唯一的鸡蛋的母亲。<br>她因此身价百倍，人们将延续鸡的生命的期望寄托在她身上，人们把最好的食物给她吃，为她建造了超豪华住宅，还让她上报纸上电视上电影。<br>鸡王的臣民们不再被人类杀戮，不再供人类食用，人类视他们为珍宝。鸡王满意了。</p><p>三</p><p>那个唯一的鸡蛋的母亲的显赫地位渐渐引起了鸡家族成员的注意，他们羡慕她嫉妒她。同样是鸡，为什么她住的房子比同类的好？为什么她的食谱比同类的高级？为什么她能上电视还享有鸡皇后的称号？就因为她生了地球上最后一个鸡蛋！<br>没人甘心比同类活得差。<br>于是，在一个上午，一只母鸡违抗鸡王的圣旨，她公然下了一个蛋。<br>这只母鸡立刻成为全球新闻的焦点，她的待遇立即超过了那只&quot;鸡皇后&quot;。<br>鸡家族受到了强烈的震动。<br>第三个鸡蛋出生了。<br>第四个鸡蛋问世了。<br>第五个鸡蛋降临了。<br>第六个鸡蛋诞辰了。<br>鸡王感到大事不妙，他连降圣旨制止母鸡们下蛋，但他已经控制不了他的臣民了。<br>所有的母鸡都想当鸡皇后，所有的母鸡都想比别的鸡活得好，她们特玩命地下蛋。<br>当鸡蛋的数量多到派不过来军队保护时，人类醒悟到鸡不会灭绝了。人们嘴里出现了口水，他们仿佛又闻到炸鸡的香味了。<br>保护鸡的法律取消了。<br>鸡又重新出现在餐桌上。<br>没人牵着鸡逛公园了。<br>鸡王想再发一道不下蛋的圣旨，幕僚进谏劝住了他。幕僚告诉鸡王，人类已经有了对付鸡不下蛋的办法：他们留出一个鸡蛋，只要鸡们再不下蛋，他们就拼命抬举这个鸡蛋和它的妈妈。<br>鸡家族算是没有出头之日了。鸡王哀叹。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis常见的使用案例</title>
      <link href="/blog/posts/753a7543/"/>
      <url>/blog/posts/753a7543/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>redis</code>除了缓存，还有很多的使用方式，互联网项目的很多功能都是通过<code>redis</code>实现的，今天简单介绍一些。</p></blockquote><h2 id="简单回顾下redis是什么"><a class="header-anchor" href="#简单回顾下redis是什么">¶</a>简单回顾下redis是什么</h2><p><code>Redis</code>是一个使用<code>ANSI C</code>编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库。从2015年6月开始，<code>Redis</code>的开发由<code>Redis Labs</code>赞助，而2013年5月至2015年6月期间，其开发由<code>Pivotal</code>赞助。在2013年5月之前，其开发由<code>VMware</code>赞助。根据月度排行网站<code>DB-Engines.com</code>的数据，<code>Redis</code>是最流行的键值对存储数据库。</p><h2 id="redis的特点"><a class="header-anchor" href="#redis的特点">¶</a>redis的特点</h2><ol><li>高性能<br>性能极高 – <code>Redis</code>能读的速度是110000次/s,写的速度是81000次/s 。</li><li>和原生语言无缝的数据结构<br><code>Redis</code>支持二进制案例的 <code>Strings</code>, <code>Lists</code>, <code>Hashes</code>, <code>Sets</code> 及 <code>Ordered Sets</code> 数据类型操作。</li><li>丰富的特性<br>Redis还支持 <code>publish/subscribe</code>, 通知, <code>key</code> 过期等等特性。</li><li>支持持久化<br><code>Redis</code>支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>分布式<br><code>Redis</code>支持数据的备份，即<code>master-slave</code>模式的数据备份。</li><li>高可用<br><code>Redis Sentinel</code> 一个分布式架构，监控各个机器的状态及时作出调整，重新选取主节点。</li></ol><h2 id="五种数据类型和常见用法"><a class="header-anchor" href="#五种数据类型和常见用法">¶</a>五种数据类型和常见用法</h2><h3 id="1-string"><a class="header-anchor" href="#1-string">¶</a>1. <code>string</code></h3><p><code>string</code>在<code>redis</code>里是通过字符数组实现的。你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。value其实不仅是String，也可以是数字。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><h4 id="常见的场景"><a class="header-anchor" href="#常见的场景">¶</a>常见的场景</h4><ol><li><code>json</code>字符串储存缓存</li><li><code>string</code>也可以是一个数字，所以也可以作为计数器，使用<code>INCR</code>命令</li><li><code>redis</code>也支持二进制，所以可以当作一个<code>bitmap</code>,把固定长度的bit位储存数据。</li><li>布隆过滤器，一个很长的二进制向量，作为超大的包含关系的查询。详细点击<a href="https://www.huaweicloud.com/articles/cd70d43549f0a4c36641be61780ab66a.html" target="_blank" rel="noopener">这里</a></li><li>分布式锁，比较复杂，可以看下<a href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/" target="_blank" rel="noopener">这里</a>。</li></ol><p>常用命令：</p><pre><code class="language-bash">  APPEND key value  summary: Append a value to a key  since: 2.0.0  BITCOUNT key [start end]  summary: Count set bits in a string  since: 2.6.0  BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]  summary: Perform arbitrary bitfield integer operations on strings  since: 3.2.0  BITOP operation destkey key [key ...]  summary: Perform bitwise operations between strings  since: 2.6.0  BITPOS key bit [start] [end]  summary: Find first bit set or clear in a string  since: 2.8.7  DECR key  summary: Decrement the integer value of a key by one  since: 1.0.0  DECRBY key decrement  summary: Decrement the integer value of a key by the given number  since: 1.0.0  GET key  summary: Get the value of a key  since: 1.0.0  GETBIT key offset  summary: Returns the bit value at offset in the string value stored at key  since: 2.2.0  GETRANGE key start end  summary: Get a substring of the string stored at a key  since: 2.4.0  GETSET key value  summary: Set the string value of a key and return its old value  since: 1.0.0  INCR key  summary: Increment the integer value of a key by one  since: 1.0.0  INCRBY key increment  summary: Increment the integer value of a key by the given amount  since: 1.0.0  INCRBYFLOAT key increment  summary: Increment the float value of a key by the given amount  since: 2.6.0  MGET key [key ...]  summary: Get the values of all the given keys  since: 1.0.0  MSET key value [key value ...]  summary: Set multiple keys to multiple values  since: 1.0.1  MSETNX key value [key value ...]  summary: Set multiple keys to multiple values, only if none of the keys exist  since: 1.0.1  PSETEX key milliseconds value  summary: Set the value and expiration in milliseconds of a key  since: 2.6.0  SET key value [EX seconds] [PX milliseconds] [NX|XX]  summary: Set the string value of a key  since: 1.0.0  SETBIT key offset value  summary: Sets or clears the bit at offset in the string value stored at key  since: 2.2.0  SETEX key seconds value  summary: Set the value and expiration of a key  since: 2.0.0  SETNX key value  summary: Set the value of a key, only if the key does not exist  since: 1.0.0  SETRANGE key offset value  summary: Overwrite part of a string at key starting at the specified offset  since: 2.2.0  STRLEN key  summary: Get the length of the value stored in a key  since: 2.2.0</code></pre><h3 id="2-hash"><a class="header-anchor" href="#2-hash">¶</a>2. hash</h3><p>Hash 是一个键值(key =&gt; value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。比如储存用户信息。用户id作为key，姓名，年龄，生日等信息可以维护序列化的对象。</p><h4 id="使用场景"><a class="header-anchor" href="#使用场景">¶</a>使用场景</h4><ol><li>存储对象类数据，因此可以存一些结构化的数据，比如购物车，用户基本信息。</li></ol><pre><code class="language-bash">  HDEL key field [field ...]  summary: Delete one or more hash fields  since: 2.0.0  HEXISTS key field  summary: Determine if a hash field exists  since: 2.0.0  HGET key field  summary: Get the value of a hash field  since: 2.0.0  HGETALL key  summary: Get all the fields and values in a hash  since: 2.0.0  HINCRBY key field increment  summary: Increment the integer value of a hash field by the given number  since: 2.0.0  HINCRBYFLOAT key field increment  summary: Increment the float value of a hash field by the given amount  since: 2.6.0  HKEYS key  summary: Get all the fields in a hash  since: 2.0.0  HLEN key  summary: Get the number of fields in a hash  since: 2.0.0  HMGET key field [field ...]  summary: Get the values of all the given hash fields  since: 2.0.0  HMSET key field value [field value ...]  summary: Set multiple hash fields to multiple values  since: 2.0.0  HSCAN key cursor [MATCH pattern] [COUNT count]  summary: Incrementally iterate hash fields and associated values  since: 2.8.0  HSET key field value  summary: Set the string value of a hash field  since: 2.0.0  HSETNX key field value  summary: Set the value of a hash field, only if the field does not exist  since: 2.0.0  HSTRLEN key field  summary: Get the length of the value of a hash field  since: 3.2.0  HVALS key  summary: Get all the values in a hash  since: 2.0.0</code></pre><h3 id="3-list"><a class="header-anchor" href="#3-list">¶</a>3. list</h3><p>list 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>可以作为一个简单的消息队列。</p><h4 id="使用场景-v2"><a class="header-anchor" href="#使用场景-v2">¶</a>使用场景</h4><ol><li>简易消息队列，右(左)边进左(右)边出，用来消费队列里的信息。但是ack机制麻烦，复杂场景还是使用专业的mq。</li><li>作为栈使用，支持右(左)边进右(左)边出。</li><li>用于储存线性数据，比如某个人的关注列表。文章点赞的人的id。</li></ol><pre><code class="language-bash">  BLPOP key [key ...] timeout  summary: Remove and get the first element in a list, or block until one is available  since: 2.0.0  BRPOP key [key ...] timeout  summary: Remove and get the last element in a list, or block until one is available  since: 2.0.0  BRPOPLPUSH source destination timeout  summary: Pop a value from a list, push it to another list and return it; or block until one is available  since: 2.2.0  LINDEX key index  summary: Get an element from a list by its index  since: 1.0.0  LINSERT key BEFORE|AFTER pivot value  summary: Insert an element before or after another element in a list  since: 2.2.0  LLEN key  summary: Get the length of a list  since: 1.0.0  LPOP key  summary: Remove and get the first element in a list  since: 1.0.0  LPUSH key value [value ...]  summary: Prepend one or multiple values to a list  since: 1.0.0  LPUSHX key value  summary: Prepend a value to a list, only if the list exists  since: 2.2.0  LRANGE key start stop  summary: Get a range of elements from a list  since: 1.0.0  LREM key count value  summary: Remove elements from a list  since: 1.0.0  LSET key index value  summary: Set the value of an element in a list by its index  since: 1.0.0  LTRIM key start stop  summary: Trim a list to the specified range  since: 1.0.0  RPOP key  summary: Remove and get the last element in a list  since: 1.0.0  RPOPLPUSH source destination  summary: Remove the last element in a list, prepend it to another list and return it  since: 1.2.0  RPUSH key value [value ...]  summary: Append one or multiple values to a list  since: 1.0.0  RPUSHX key value  summary: Append a value to a list, only if the list exists  since: 2.2.0</code></pre><h3 id="4-set"><a class="header-anchor" href="#4-set">¶</a>4. set</h3><p>set 是string类型的无序集合。集合是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。所以添加，删除，查找的复杂度都是O(1)。</p><h3 id="使用场景-v3"><a class="header-anchor" href="#使用场景-v3">¶</a>使用场景</h3><ol><li>去重，多台服务可以放在一个set里去重。</li><li>redis 提供了求交集、并集、差集的操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能。</li></ol><pre><code class="language-bash">  SADD key member [member ...]  summary: Add one or more members to a set  since: 1.0.0  SCARD key  summary: Get the number of members in a set  since: 1.0.0  SDIFF key [key ...]  summary: Subtract multiple sets  since: 1.0.0  SDIFFSTORE destination key [key ...]  summary: Subtract multiple sets and store the resulting set in a key  since: 1.0.0  SINTER key [key ...]  summary: Intersect multiple sets  since: 1.0.0  SINTERSTORE destination key [key ...]  summary: Intersect multiple sets and store the resulting set in a key  since: 1.0.0  SISMEMBER key member  summary: Determine if a given value is a member of a set  since: 1.0.0  SMEMBERS key  summary: Get all the members in a set  since: 1.0.0  SMOVE source destination member  summary: Move a member from one set to another  since: 1.0.0  SPOP key [count]  summary: Remove and return one or multiple random members from a set  since: 1.0.0  SRANDMEMBER key [count]  summary: Get one or multiple random members from a set  since: 1.0.0  SREM key member [member ...]  summary: Remove one or more members from a set  since: 1.0.0  SSCAN key cursor [MATCH pattern] [COUNT count]  summary: Incrementally iterate Set elements  since: 2.8.0  SUNION key [key ...]  summary: Add multiple sets  since: 1.0.0  SUNIONSTORE destination key [key ...]  summary: Add multiple sets and store the resulting set in a key  since: 1.0.0</code></pre><h3 id="5-sorted-set"><a class="header-anchor" href="#5-sorted-set">¶</a>5. sorted_set</h3><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 *zadd 命令：*添加元素到集合，元素在集合中存在则更新对应score。set是有序的，根据<code>score</code>排序。</p><h3 id="使用场景-v4"><a class="header-anchor" href="#使用场景-v4">¶</a>使用场景</h3><ol><li>因为自带排序，显示最新的项目列表 ，排行榜相关。</li><li>处理过期项目，比如处理没付款的订单。根据下单时间放进<code>sorted_set</code>，后台任务根据<code>ZRANGE</code>查最近的几条数据，如果过期再回写到数据库。</li></ol><pre><code class="language-bash">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]  summary: Add one or more members to a sorted set, or update its score if it already exists  since: 1.2.0  ZCARD key  summary: Get the number of members in a sorted set  since: 1.2.0  ZCOUNT key min max  summary: Count the members in a sorted set with scores within the given values  since: 2.0.0  ZINCRBY key increment member  summary: Increment the score of a member in a sorted set  since: 1.2.0  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]  summary: Intersect multiple sorted sets and store the resulting sorted set in a new key  since: 2.0.0  ZLEXCOUNT key min max  summary: Count the number of members in a sorted set between a given lexicographical range  since: 2.8.9  ZRANGE key start stop [WITHSCORES]  summary: Return a range of members in a sorted set, by index  since: 1.2.0  ZRANGEBYLEX key min max [LIMIT offset count]  summary: Return a range of members in a sorted set, by lexicographical range  since: 2.8.9  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]  summary: Return a range of members in a sorted set, by score  since: 1.0.5  ZRANK key member  summary: Determine the index of a member in a sorted set  since: 2.0.0  ZREM key member [member ...]  summary: Remove one or more members from a sorted set  since: 1.2.0  ZREMRANGEBYLEX key min max  summary: Remove all members in a sorted set between the given lexicographical range  since: 2.8.9  ZREMRANGEBYRANK key start stop  summary: Remove all members in a sorted set within the given indexes  since: 2.0.0  ZREMRANGEBYSCORE key min max  summary: Remove all members in a sorted set within the given scores  since: 1.2.0  ZREVRANGE key start stop [WITHSCORES]  summary: Return a range of members in a sorted set, by index, with scores ordered from high to low  since: 1.2.0  ZREVRANGEBYLEX key max min [LIMIT offset count]  summary: Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.  since: 2.8.9  ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]  summary: Return a range of members in a sorted set, by score, with scores ordered from high to low  since: 2.2.0  ZREVRANK key member  summary: Determine the index of a member in a sorted set, with scores ordered from high to low  since: 2.0.0  ZSCAN key cursor [MATCH pattern] [COUNT count]  summary: Incrementally iterate sorted sets elements and associated scores  since: 2.8.0  ZSCORE key member  summary: Get the score associated with the given member in a sorted set  since: 1.2.0  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]  summary: Add multiple sorted sets and store the resulting sorted set in a new key  since: 2.0.0</code></pre><h2 id="其他功能"><a class="header-anchor" href="#其他功能">¶</a>其他功能</h2><ol><li>Pub/Sub<br>Redis的Pub/Sub非常非常简单，运行稳定并且快速。可以作为发布订阅使用。<br>2.<code>geo</code><br>储存地理坐标数据，用来实现附近的人功能。</li><li>HyperLogLog<br><code>Redis HyperLogLog</code> 是用来做基数统计的算法，<code>HyperLogLog</code> 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。<br>在 <code>Redis</code> 里面，每个 <code>HyperLogLog</code> 键只需要花费 <code>12 KB</code> 内存，就可以计算接近 <code>2^64</code> 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷到500题，我决定从头开始学习算法</title>
      <link href="/blog/posts/cec8bc39/"/>
      <url>/blog/posts/cec8bc39/</url>
      
        <content type="html"><![CDATA[<blockquote><p>算法刷到500道，我决定暂停一下</p></blockquote><h2 id="截图留念"><a class="header-anchor" href="#截图留念">¶</a>截图留念</h2><p><img src="./1.PNG" alt="截图纪念"></p><h2 id="几个周赛题-我被虐了"><a class="header-anchor" href="#几个周赛题-我被虐了">¶</a>几个周赛题，我被虐了</h2><p>刷了这么多，我感觉自己膨胀了，可以参加周赛了，于是打了几场，结果惨不忍睹，最好的一次做了三道题，平均两道题，有时只能做出来一道。<br>让我伤心的是不是题目有多难，而是结束后看了下别人的答案，原来这么简单，一点都不难，都是很简单的逻辑，但是我就是没想到，这些题有些甚至是我做过的原题，只是换了一个表达方式，把他应用到了实际的场景中，我就想不到怎么解决了😭。但是一旦想明白要干什么，才发现原来是做过的原题。</p><h2 id="我缺乏什么"><a class="header-anchor" href="#我缺乏什么">¶</a>我缺乏什么</h2><p>第一：透过现象看本质，这一点我十分确认和智商有关系，数学家可以把复杂的显示世界用公式描述，编程高手可以用代码实现复杂的系统设计。著名的物理学家、电机专家斯坦门茨的画一条线，1美元；<br>知道在哪儿画线，9999美元的故事大家也都清楚，天赋固然重要，但是大部分人的努力程度还不到拼天赋的的地步，智商也许可以决定上限，努力和勤奋更能决定下限，只有不断的练习，激发自己对未知领域的试探，我相信自己也能解开层层面纱，看到题目纷繁条件下的细枝末节🧐。</p><p>第二：对数据结构的理解和使用场景不到位。日常工作中，使用复杂数据结构的场景其实不多，前端业务代码往往并不复杂，因此很多数据结构还没熟悉到，下一步定个目标，一周真正学会一个数据结构。</p><p>第三：我想，刷力扣，高中的数学知识应该差不多了，但其实，离散和线性代数如果熟练的话，更好。现在要再复习下一些基本的数学知识。</p><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>每日一题还要坚持下去，但是不会花大时间漫无目的的刷题了，接下来的目标是学习以下的数据结构。目前在看的一本书是《算法》第四版。</p><p>栈/单调栈，队列/单调队列，链表，哈希表，堆，二叉树/二叉搜索树/平衡树，跳表。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨页面通信的几种方法</title>
      <link href="/blog/posts/97160c27/"/>
      <url>/blog/posts/97160c27/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原来，跨页面通信有这这么多方法</p></blockquote><h2 id="同源页面之间的通信"><a class="header-anchor" href="#同源页面之间的通信">¶</a>同源页面之间的通信</h2><h3 id="localstorage"><a class="header-anchor" href="#localstorage">¶</a>localStorage</h3><p>这个大家都很熟悉了，但是他还有一个storage事件，之前没接触过<br>当 LocalStorage 变化时，会触发storage事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听storage事件即可收到通知。</p><pre><code class="language-js">// 一个页面监听事件window.addEventListener('storage', function (e) {    if (e.key === 'ctc-msg') {        const data = JSON.parse(e.newValue);        const text = '[receive] ' + data.msg + ' —— tab ' + data.from;        console.log('[Storage I] receive message:', text);    }});// 另外一个页面set数据，这里加上事件戳是因为只有真正改变才会触发storagemydata.st = +(new Date);window.localStorage.setItem('ctc-msg', JSON.stringify(mydata));</code></pre><h3 id="indexeddb"><a class="header-anchor" href="#indexeddb">¶</a>IndexedDB</h3><p>不多介绍了，就是简单的轮询</p><h3 id="service-worker"><a class="header-anchor" href="#service-worker">¶</a>Service Worker</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service workers</a> 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用采取来适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。<br>Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们会使用轮询的方式，来拉取最新的数据。思路如下：<br>让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过postMessage传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：<br>首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：</p><pre><code class="language-JS">// 构造函数的第二个参数是 Shared Worker 名称，也可以留空const sharedWorker = new SharedWorker('../util.shared.js', 'ctc');</code></pre><p>然后，在该 Shared Worker 中支持 get 与 post 形式的消息：</p><pre><code class="language-js">/* ../util.shared.js: Shared Worker 代码 */let data = null;self.addEventListener('connect', function (e) {    const port = e.ports[0];    port.addEventListener('message', function (event) {        // get 指令则返回存储的消息数据        if (event.data.get) {            data &amp;&amp; port.postMessage(data);        }        // 非 get 指令则存储该消息数据        else {            data = event.data;        }    });    port.start();});</code></pre><p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：</p><pre><code class="language-js">// 定时轮询，发送 get 指令的消息setInterval(function () {    sharedWorker.port.postMessage({get: true});}, 1000);// 监听 get 消息的返回数据sharedWorker.port.addEventListener('message', (e) =&gt; {    const data = e.data;    const text = '[receive] ' + data.msg + ' —— tab ' + data.from;    console.log('[Shared Worker] receive message:', text);}, false);sharedWorker.port.start();</code></pre><p>最后，当要跨页面通信时，只需给 Shared Worker postMessage即可：</p><pre><code class="language-js">sharedWorker.port.postMessage(mydata);</code></pre><p>注意，如果使用addEventListener来添加 Shared Worker 的消息监听，需要显式调用MessagePort.start方法，即上文中的sharedWorker.port.start()；如果使用onmessage绑定监听则不需要。</p><h3 id="broadcast-channel"><a class="header-anchor" href="#broadcast-channel">¶</a>BroadCast Channel</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Broadcast_Channel_API" target="_blank" rel="noopener">Broadcast Channel API</a> 可以实现同 源 下浏览器不同窗口，Tab页，frame或者 iframe 下的 浏览器上下文 (通常是同一个网站下不同的页面)之间的简单通讯。</p><p>简单的api展示：</p><pre><code class="language-js">// 连接到广播频道,在多个页面注册同一个频道var bc = new BroadcastChannel('test_channel');// 发送简单消息的示例bc.postMessage('This is a test message.');// 简单示例，用于将事件打印到控制台bc.onmessage = function (ev) { console.log(ev); }// 断开频道连接bc.close()</code></pre><h2 id="非同源页面之间的通信"><a class="header-anchor" href="#非同源页面之间的通信">¶</a>非同源页面之间的通信</h2><h3 id="利用中间iframe作为brideg"><a class="header-anchor" href="#利用中间iframe作为brideg">¶</a>利用中间iframe作为brideg</h3><p>使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定origin来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：<a href="http://sample.com/bridge.html%EF%BC%89%EF%BC%8C%E8%80%8C%E8%BF%99%E4%BA%9B" target="_blank" rel="noopener">http://sample.com/bridge.html），而这些</a> iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。</p><pre><code class="language-js">/* 业务页面代码 */window.addEventListener('message', function (e) {    // …… do something});/* 业务页面代码发信息 */window.frames[0].window.postMessage(mydata, '*');</code></pre><h3 id="利用websocket"><a class="header-anchor" href="#利用websocket">¶</a>利用websocket</h3><p>利用后端新开一个websocket服务，多个页面都接受服务端的推送，也可以实现同步状态。</p><hr><p>原文地址，本文稍作删改：<br><a href="https://juejin.cn/post/6844903811232825357" target="_blank" rel="noopener">https://juejin.cn/post/6844903811232825357</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch使用</title>
      <link href="/blog/posts/5e47ac86/"/>
      <url>/blog/posts/5e47ac86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一次将千万级别的数据库表迁移到Elasticsearch 的过程</p></blockquote><h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2><p>我们有一张千万级别，并且每天都新增将近万条数据，更新也在十几万的业务表，这个业务表可以说是我们的核心业务，因为历史问题，表字段除了基本的字段外，还存了json， 一个字符串可代表多业务， 甚至存了二进制的对象， 同时，我们的运营页面需要根据将近20个查询条件对这个表进行查询，一方面因为数据量大，多个查询条件组合起来，查出数据有时也要十几秒，甚至在一些极端情况下，页面直接超时，用户体验很不好，另一方面，有些字段隐藏在json内部，或者二进制的对象里面，限制了其作为查询条件。</p><h2 id="预研"><a class="header-anchor" href="#预研">¶</a>预研</h2><p>于是我花了两天的时间了解了Elasticsearch 是什么，可以做什么，大概的操作步骤，查询api，以及配套的生态，又花了一天在测试环境搭建了一套elk，就开始了迁移的测试。<br>ps：在这里说明一下<br>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。<br>Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。<br>Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志<br>elk当然就是这三部分的组合了。</p><h2 id="用logstash-同步数据"><a class="header-anchor" href="#用logstash-同步数据">¶</a>用logstash 同步数据</h2><p>logstash 本身的配置也不复杂，分为<code>input</code>，<code>filter</code>，<code>output</code> 三部分。<br><code>input</code> 和 <code>output</code>支持各种插件。<br>比如<code>input</code> 支持 <code>mysql</code>，<code>file</code>，<code>http</code>，等等，最新的<code>input</code> 甚至支持<code>Twitter</code>。<br><code>output</code> 支持 <code>elasticsearch</code>，<code>email</code>，<code>rabbitmq</code>等等。<br>查看所有支持的插件可以点击<a href="https://www.elastic.co/guide/en/logstash/7.12/introduction.html" target="_blank" rel="noopener">这里</a></p><p>这一步本来是很简单的，因为logstash 本身就支持同步mysql数据到es，只需要简单的配置，加上json的中间filter，就可以完成了，但是就是二进制的数据对象要解析出来有点麻烦，还好logstash支持用ruby作为脚本，于是就需要编写一个ruby脚本，把从mysql里读出来的二进制转化成对象，我们存的二进制是protobuf转化的对象，因此，需要用一个protobuf的库 把二进制转成ruby对象，然后在解析这个对象，分割成不同的字段存入es。<br>首先，我从内部的平台，下载了原始的protobuf文件，然后在公司的编译机上，便成ruby的class文件，但是怎么从二进制解码到对象呢？我又翻看了下logstash的文档，发现他有一个codec的插件是直接支持解码pb对象的，但是这个插件只支持每次解析一行，但是我从mysql读出来的数据，是一行sql插叙结果，里面只有几个字段是二进制的，于是我找到了这个插件<code>logstash-codec-protobuf</code>的github<a href="https://github.com/logstash-plugins/logstash-codec-protobuf" target="_blank" rel="noopener">地址</a>，简单看了下源码和<code>api</code>，源码不多加上注释也才700多行，虽然没学过ruby但也大概看出来一些逻辑，看了下他的依赖，</p><pre><code class="language-ruby">require 'logstash/codecs/base'require 'logstash/util/charset'require 'google/protobuf' # for protobuf3require 'protocol_buffers' # https://github.com/codekitchen/ruby-protocol-buffers, for protobuf2</code></pre><p>主要起作用的应该是</p><pre><code class="language-ruby">require 'google/protobuf' # for protobuf3require 'protocol_buffers</code></pre><p>整个代码是一个面向对象的语法， 定义了一个class</p><pre><code class="language-ruby">class LogStash::Codecs::Protobuf &lt; LogStash::Codecs::Base</code></pre><p>里面有<code>register</code>,<code>decode</code>,<code>encode</code> 等方法，看来起作用的就是<code>decode</code> 了，马上拿来放在脚本里面跑了一下，成功从二进制解析得到了ruby对象。</p><p>接下来就简单了，注意细节，对照字段开始同步。大概花了25个小时，就把所有的数据同步到了es,增量的数据，我用<code>updatetime</code>作为查询条件更新。</p><h2 id="用php客户端查询数据"><a class="header-anchor" href="#用php客户端查询数据">¶</a>用php客户端查询数据</h2><p>最后，我用php客户端，通过http调用的形式，使用es查询语法，对数据进行查询，果然快了很多，复杂的查询条件，也能在1s左右查询出来。</p><p>这里要说明的是<code>kibana</code>里面有个devtool的页面，可以在里面写查询语句验证结果，使用起来十分方便。</p><h2 id="遇到的坑"><a class="header-anchor" href="#遇到的坑">¶</a>遇到的坑</h2><p>主要是分页查询的时候，很大的数据量下不能以一般的查询语法，即from to 这种，因为在深度分页的情况下，这种使用方式效率是非常低的，比如from = 5000, size=10， es 需要在各个分片上匹配排序并得到5000*10条有效数据，然后在结果集中取最后10条数据返回。</p><p>我们就遇到了这个问题，先把<code>max_result_window</code>调大了一些，后来用深度分页代替：<br>es 提供了 <code>Scroll API</code> 的方式进行分页读取。原理上是对某次查询生成一个游标 scroll_id ， 后续的查询只需要根据这个游标去取数据，直到结果集中返回的 hits 字段为空，就表示遍历结束。scroll_id 的生成可以理解为建立了一个临时的历史快照，在此之后的增删改查等操作不会影响到这个快照的结果。<br>但是这个也不允许随机跳页，适合类似微博那种下拉翻页的场景。</p><p>ps: 关于深度分页优化可以看下<a href="https://juejin.cn/post/6850037275456339975" target="_blank" rel="noopener">这里</a></p><h2 id="elk很复杂的"><a class="header-anchor" href="#elk很复杂的">¶</a>elk很复杂的</h2><p>虽然基本符合了使用场景，但是关于elk我感觉还是只了解了皮毛，如何优化，怎么关联查询，怎么设置索引结构更高效，更复杂的查询语句，这些都还没接触到。<br>ps: 网上很多关于性能优化的文章，比如<a href="https://zhuanlan.zhihu.com/p/67362440" target="_blank" rel="noopener">这篇</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2道算法题的优化过程</title>
      <link href="/blog/posts/7e570359/"/>
      <url>/blog/posts/7e570359/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近刷了那么多的算法,感觉自己刚刚有点进步,又被两道简单题搞晕了🙃🙃,彻底暴露了自己对时间复杂度掌握不足的遗漏,因此在这里记录下优化的过程.</p></blockquote><h3 id="第一题"><a class="header-anchor" href="#第一题">¶</a>第一题</h3><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1：</p><p>输入：nums = [1,1,1,2,2,3]<br>输出：5, nums = [1,1,2,2,3]<br>解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p><p>输入：nums = [0,0,1,1,1,1,2,3,3]<br>输出：7, nums = [0,0,1,1,2,3,3]<br>解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。<br>一看到题目,觉得不难,马上开始写代码,就模拟整个过程,几分钟搞定.</p><pre><code class="language-javaScript">var removeDuplicates = function(nums) {        let len = nums.length    let last = nums[len-1]    let count = 1    for(let i = nums.length-2;i&gt;=0;i--) {        if(nums[i] === last) {            count++            if(count&gt;2) {                len--                for(let j = i;j&lt;len;j++) {                    nums[j] = nums[j+1]                }            }        }else {            count = 1            last = nums[i]        }       }    return len};</code></pre><p>刚好这几天几个同事都在打卡每日一题,我们交流了一下,我把自己的代码给同事看了看,一个同事立马说,你这个时间复杂度太高了,我仔细看了看代码,确实,循环里面移动数组,大概复杂度O(n^2).</p><p>听了同事的的解法,我顿悟了,原来双指针就好了,快慢指针,慢指针保持长度,快指针每次+1用来检查后面的元素,遇到不同的元素,并且前方已经出现了两个重复的,就覆盖前方慢指针的元素,然后慢指针继续+1</p><p>下面是代码:</p><pre><code class="language-javaScript">var removeDuplicates = function(nums) {    let n = nums.length    if(n&lt;2) {        return n    }    let slow = 2    let fast = 2        while(fast&lt;n) {        if(nums[slow-2] !== nums[fast]) {            nums[slow] = nums[fast]            slow++        }        fast++    }        return slow};</code></pre><p>这样时间复杂度就被优化到了O(n),只遍历了一边.<br>经过自己的测试,在长度为999999,三个一组相同的数组的运行测试下,第二种花费大概3ms,而第一种,居然用了100000+ms,相差了3万倍!!!🤯 🤯 🤯 🤯 🤯</p><h3 id="第二题"><a class="header-anchor" href="#第二题">¶</a>第二题</h3><p>小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。</p><p>注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1<br>示例 1：</p><p>输入：nums = [2,5,3,5], target = 6</p><p>输出：1</p><p>解释：预算内仅能购买 nums[0] 与 nums[2]。</p><p>示例 2：</p><p>输入：nums = [2,2,1,9], target = 10</p><p>输出：4</p><p>解释：符合预算的采购方案如下：<br>nums[0] + nums[1] = 4<br>nums[0] + nums[2] = 3<br>nums[1] + nums[2] = 3<br>nums[2] + nums[3] = 10</p><p>第一眼看到这个题,心想这么简单的吗?<br>立马又是双层循环遍历一边,果不其然超时了,一看给的测试用例,长度 <code>2 &lt;= nums.length &lt;= 10^5</code><br>考虑到没有负数,于是加了个判断第一个数的长度是否大于target,然而还是超时.<br>想了想,先排下顺序吧,然后二分找到小于target的部分,在这个范围内判断,后来又想,如果target很大怎么办?不还是要遍历很多次吗?<br>想啊想,死掉n个脑细胞,m根头发后,我明白了,在一个顺序的数组里,如果下标i和下标j满足小于target,那么i和其他小于j的其他组合都满足,这个个数是(j-i)个,然后i++继续判断就行了,如果大于target了,就大数的下标,j 向左移动j-- 就行了. 想明白后,才发现已经过去1个小时了.马上动手写代码</p><pre><code class="language-javaScript">var purchasePlans = function(nums, target) {    const MOD = 1000000007    nums.sort((a,b) =&gt; a-b)    let i = 0    let  j = nums.length-1    let res = 0    while(i&lt;j) {        if(nums[i] + nums[j] &lt;= target) {            res+=j-i            res = res%MOD            i++        }else {            j--        }    }    return res};</code></pre><p>这样就O(n)了,同时,不要忘了模MOD.</p><p>注意时间复杂度,不要再写低效率的代码了💪💪💪💪💪</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器兼容性问题</title>
      <link href="/blog/posts/fe80343/"/>
      <url>/blog/posts/fe80343/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个记录日常结局浏览器兼容问题的备忘录</p></blockquote><ol><li>如何查看某个javaScript 对象或者css 属性的兼容性</li></ol><p>到MND搜索需要查看的内容,页面底部提供一份不同平台(比如PC端,手机端,node端)以及不同浏览器进行和其各个历史版本的兼容表格,可以很直观的看到你要用的技术是否支持业务覆盖的浏览器或者平台.</p><ol start="2"><li>浏览器强制用webkit内核<br>国内部分双核浏览器如：360极速浏览器、搜狗浏览器、百度浏览器等等，这些浏览器都号称拥有两个内核，用户可以根据需要自由切换。双核浏览器的2个内个分别为极速内核（webkit内核），兼容内核（trident内核）。使用极速内核浏览器会按照w3c的新标准渲染页面，其结果是渲染速度更快，规范性更好。而兼容内核也并非一无是处，国内很多政府、银行类网站在编写之初考虑了兼容旧版本ie的trident内核，其代码并非为w3c规范的标准，而是浏览器厂商自定义的模式，这类网站则必须使用兼容模式打开，如果使用极速模式打开就会产生布局错乱等问题。</li></ol><p>可以用下面的标签强制浏览器使用极速内核:</p><meta name="renderer" content="webkit"><p>也可以使用兼容的写法:</p><meta name="renderer" content="webkit|ie-comp|ie-stand">这里会根据先后顺序,启用支持的内核,不支持也不会<ol start="3"><li>重置样式<br>不同的浏览器之间基本样式很不一样，比如IE浏览器使用ie盒子模型，现代浏览器大多使用标准盒子模型。他们之间的宽度计算很不一样。<br>这个时候就需要用reset.css重置一下样式了</li></ol><pre><code class="language-css">@charset &quot;utf-8&quot;;/* CSS Document */html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, font, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td {    margin: 0;    padding: 0;    border: 0;    outline: 0;    font-size: 100%;    vertical-align: baseline;    background: transparent;}body {    line-height: 1;}ol, ul {    list-style: none;}blockquote, q {    quotes: none;}blockquote:before, blockquote:after,q:before, q:after {    content: '';    content: none;}/* remember to define focus styles! */:focus {    outline: 0;}/* remember to highlight inserts somehow! */ins {    text-decoration: none;}del {    text-decoration: line-through;}/* tables still need 'cellspacing=&quot;0&quot;' in the markup */table {    border-collapse: collapse;    border-spacing: 0;}/* 清除浮动 */.clearfloat:after{display:block;clear:both;content:&quot;&quot;;visibility:hidden; height:0;} .clearfloat{zoom:1} </code></pre><ol start="4"><li>浏览器类型判断</li></ol><pre><code class="language-javaScript">// 浏览器类型判断function browserType () {    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串    var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器    var isIE = window.ActiveXObject || &quot;ActiveXObject&quot; in window    var isEdge = userAgent.indexOf(&quot;Edge&quot;) &gt; -1; //判断是否IE的Edge浏览器    var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器    var isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Chrome&quot;) == -1; //判断是否Safari浏览器    var isChrome = userAgent.indexOf(&quot;Chrome&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; !isEdge; //判断Chrome浏览器    if (isIE) {        var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;);        reIE.test(userAgent);        var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]);        if (userAgent.indexOf('MSIE 6.0') != -1) {            return &quot;IE6&quot;;        } else if (fIEVersion == 7) {            return &quot;IE7&quot;;        }        else if (fIEVersion == 8) {            return &quot;IE8&quot;;        }        else if (fIEVersion == 9) {            return &quot;IE9&quot;;        }        else if (fIEVersion == 10) {            return &quot;IE10&quot;;        }        else if (userAgent.toLowerCase().match(/rv:([\d.]+)\) like gecko/)) {            return &quot;IE11&quot;;        }        else {            return &quot;0&quot;        }//IE版本过低    }    if (isFF) {        return &quot;FF&quot;;    }    if (isOpera) {        return &quot;Opera&quot;;    }    if (isSafari) {        return &quot;Safari&quot;;    }    if (isChrome) {        return &quot;Chrome&quot;;    }    if (isEdge) {        return &quot;Edge&quot;;    }}</code></pre><ol start="5"><li>html if 判断浏览器ie版本</li></ol><pre><code class="language-html">&lt;!--[if !IE]&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt;</code></pre><p>~~未完待续</p>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promiseA+</title>
      <link href="/blog/posts/d721f59f/"/>
      <url>/blog/posts/d721f59f/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JavaScript Promise A+ 规范</p></blockquote><p>译者序：一年前曾译过 Promise/A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知这样一篇拙译，一年之间竟然点击数千，成为谷歌搜索的头条。今日在理解之后重译此规范，以飨读者。</p><p>一个开放、健全且通用的 JavaScript Promise 标准。由开发者制定，供开发者参考。</p><p>译文术语:</p><p>解决（fulfill）：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。</p><p>拒绝（reject）：指一个 promise 失败时进行的一系列操作。</p><p>终值（eventual value）：所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</p><p>据因（reason）：也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。</p><p>实现:</p><pre><code class="language-javaScript">/** * Promise 实现 遵循promise/A+规范 * Promise/A+规范译文: * https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4 */// promise 三个状态const PENDING = &quot;pending&quot;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;function Promise(excutor) {    let that = this; // 缓存当前promise实例对象    that.status = PENDING; // 初始状态    that.value = undefined; // fulfilled状态时 返回的信息    that.reason = undefined; // rejected状态时 拒绝的原因    that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数    that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数    function resolve(value) { // value成功态时接收的终值        if (value instanceof Promise) {            return value.then(resolve, reject);        }        // 为什么resolve 加setTimeout?        // 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行.        // 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。        setTimeout(() =&gt; {            // 调用resolve 回调对应onFulfilled函数            if (that.status === PENDING) {                // 只能由pedning状态 =&gt; fulfilled状态 (避免调用多次resolve reject)                that.status = FULFILLED;                that.value = value;                that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value));            }        });    }    function reject(reason) { // reason失败态时接收的拒因        setTimeout(() =&gt; {            // 调用reject 回调对应onRejected函数            if (that.status === PENDING) {                // 只能由pedning状态 =&gt; rejected状态 (避免调用多次resolve reject)                that.status = REJECTED;                that.reason = reason;                that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason));            }        });    }    // 捕获在excutor执行器中抛出的异常    // new Promise((resolve, reject) =&gt; {    //     throw new Error('error in excutor')    // })    try {        excutor(resolve, reject);    } catch (e) {        reject(e);    }}/** * resolve中的值几种情况： * 1.普通值 * 2.promise对象 * 3.thenable对象/函数 *//** * 对resolve 进行改造增强 针对resolve中不同值情况 进行处理 * @param  {promise} promise2 promise1.then方法返回的新的promise对象 * @param  {[type]} x         promise1中onFulfilled的返回值 * @param  {[type]} resolve   promise2的resolve方法 * @param  {[type]} reject    promise2的reject方法 */function resolvePromise(promise2, x, resolve, reject) {    if (promise2 === x) { // 如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错        return reject(new TypeError('循环引用'));    }    let called = false; // 避免多次调用    // 如果x是一个promise对象 （该判断和下面 判断是不是thenable对象重复 所以可有可无）    if (x instanceof Promise) { // 获得它的终值 继续resolve        if (x.status === PENDING) { // 如果为等待态需等待直至 x 被执行或拒绝 并解析y值            x.then(y =&gt; {                resolvePromise(promise2, y, resolve, reject);            }, reason =&gt; {                reject(reason);            });        } else { // 如果 x 已经处于执行态/拒绝态(值已经被解析为普通值)，用相同的值执行传递下去 promise            x.then(resolve, reject);        }        // 如果 x 为对象或者函数    } else if (x != null &amp;&amp; ((typeof x === 'object') || (typeof x === 'function'))) {        try { // 是否是thenable对象（具有then方法的对象/函数）            let then = x.then;            if (typeof then === 'function') {                then.call(x, y =&gt; {                    if (called) return;                    called = true;                    resolvePromise(promise2, y, resolve, reject);                }, reason =&gt; {                    if (called) return;                    called = true;                    reject(reason);                })            } else { // 说明是一个普通对象/函数                resolve(x);            }        } catch (e) {            if (called) return;            called = true;            reject(e);        }    } else {        resolve(x);    }}/** * [注册fulfilled状态/rejected状态对应的回调函数] * @param  {function} onFulfilled fulfilled状态时 执行的函数 * @param  {function} onRejected  rejected状态时 执行的函数 * @return {function} newPromsie  返回一个新的promise对象 */Promise.prototype.then = function (onFulfilled, onRejected) {    const that = this;    let newPromise;    // 处理参数默认值 保证参数后续能够继续执行    onFulfilled =        typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value;    onRejected =        typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; {            throw reason;        };    // then里面的FULFILLED/REJECTED状态时 为什么要加setTimeout ?    // 原因:    // 其一 2.2.4规范 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout    // 其二 2.2.6规范 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected    // 其二 2.2.6规范 也是resolve函数里加setTimeout的原因    // 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行    // 如下面这种情景 多次调用p1.then    // p1.then((value) =&gt; { // 此时p1.status 由pedding状态 =&gt; fulfilled状态    //     console.log(value); // resolve    //     // console.log(p1.status); // fulfilled    //     p1.then(value =&gt; { // 再次p1.then 这时已经为fulfilled状态 走的是fulfilled状态判断里的逻辑 所以我们也要确保判断里面onFuilled异步执行    //         console.log(value); // 'resolve'    //     });    //     console.log('当前执行栈中同步代码');    // })    // console.log('全局执行栈中同步代码');    //    if (that.status === FULFILLED) { // 成功态        return newPromise = new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                try {                    let x = onFulfilled(that.value);                    resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值                } catch (e) {                    reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);                }            });        })    }    if (that.status === REJECTED) { // 失败态        return newPromise = new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                try {                    let x = onRejected(that.reason);                    resolvePromise(newPromise, x, resolve, reject);                } catch (e) {                    reject(e);                }            });        });    }    if (that.status === PENDING) { // 等待态        // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中        return newPromise = new Promise((resolve, reject) =&gt; {            that.onFulfilledCallbacks.push((value) =&gt; {                try {                    let x = onFulfilled(value);                    resolvePromise(newPromise, x, resolve, reject);                } catch (e) {                    reject(e);                }            });            that.onRejectedCallbacks.push((reason) =&gt; {                try {                    let x = onRejected(reason);                    resolvePromise(newPromise, x, resolve, reject);                } catch (e) {                    reject(e);                }            });        });    }};/** * Promise.all Promise进行并行处理 * 参数: promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。 */Promise.all = function (promises) {    return new Promise((resolve, reject) =&gt; {        let done = gen(promises.length, resolve);        promises.forEach((promise, index) =&gt; {            promise.then((value) =&gt; {                done(index, value)            }, reject)        })    })}function gen(length, resolve) {    let count = 0;    let values = [];    return function (i, value) {        values[i] = value;        if (++count === length) {            console.log(values);            resolve(values);        }    }}/** * Promise.race * 参数: 接收 promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快) */Promise.race = function (promises) {    return new Promise((resolve, reject) =&gt; {        promises.forEach((promise, index) =&gt; {            promise.then(resolve, reject);        });    });}// 用于promise方法链时 捕获前面onFulfilled/onRejected抛出的异常Promise.prototype.catch = function (onRejected) {    return this.then(null, onRejected);}Promise.resolve = function (value) {    return new Promise(resolve =&gt; {        resolve(value);    });}Promise.reject = function (reason) {    return new Promise((resolve, reject) =&gt; {        reject(reason);    });}/** * 基于Promise实现Deferred的 * Deferred和Promise的关系 * - Deferred 拥有 Promise * - Deferred 具备对 Promise的状态进行操作的特权方法（resolve reject） * *参考jQuery.Deferred *url: http://api.jquery.com/category/deferred-object/ */Promise.deferred = function () { // 延迟对象    let defer = {};    defer.promise = new Promise((resolve, reject) =&gt; {        defer.resolve = resolve;        defer.reject = reject;    });    return defer;}/** * Promise/A+规范测试 * npm i -g promises-aplus-tests * promises-aplus-tests Promise.js */try {    module.exports = Promise} catch (e) {}</code></pre><p>来源:<br><a href="https://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">https://www.ituring.com.cn/article/66566</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蝙蝠侠：黑暗骑士</title>
      <link href="/blog/posts/48fde4e8/"/>
      <url>/blog/posts/48fde4e8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我心目中最好的一步蝙蝠侠电影，没有之一。</p></blockquote><p>分享豆瓣热评。</p><p>大片中很有内涵的一部，不管是人们心中暗自涌动的对小丑疯狂灭世主义的不安的共鸣，还是对蝙蝠侠孤独暗夜行走的英雄惜英雄般同情，其实都是人们对这个世界失望的一种情绪释放。其实小丑说的很对，他和蝙蝠侠很像，都是异类，只不过蝙蝠侠把痛苦留给自己，顽固地去坚守一丝信仰，而小丑把痛苦还给世界。<br>–<strong>fishlee 看过   2009-07-28</strong></p><p>赞誉众口一致夸上了天，百闻不如一见，这种连环画超级英雄故事居然能扯到第六集真是要把编剧逼跳楼了，最后呈现的暗夜骑士全然超越了原著，悲怆到迷人的境界，着实是个奇迹。剧本确实很卓越，导演确实很出色，还有演技真是不得不叹服一下太tmd震撼<br>–<strong>37°2 看过  2008-11-21</strong></p><p>对于这么优秀的电影来说，再多的赞美都是多余的。<br>–<strong>Jin 看过  2008-09-15</strong></p><p>“有些人并不喜欢那些常人偏爱的东西，比如金钱，他们不被收买、不会被恐吓、不可理喻、更不接受谈判，有些人就想看人间地狱。” 也只有蝙蝠侠，才能让小丑变得完整。无尽的黑暗。<br>–<strong>影志 看过  2008-12-14</strong></p><h2 id="影评"><a class="header-anchor" href="#影评">¶</a>影评</h2><p>作者:武志红<br>来源：<br><a href="https://movie.douban.com/review/1629723/" target="_blank" rel="noopener">https://movie.douban.com/review/1629723/</a></p><p>【22日，美国第81届奥斯卡奖的提名名单公布，令人们大跌眼镜的是，2008年全球票房冠军、好莱坞历史上第二卖座的《蝙蝠侠·暗夜骑士》只拿到了数项无关痛痒的提名。<br>不过，评委们可以轻视这部影片，但却不能轻视影片中的反角小丑，饰演小丑的演员希斯·莱杰众望所归获得了最佳配角提名，而分析者们也普遍认为，这一奖项铁定是希斯·莱杰的，这不是因为曾在《断臂山》等影片中有上佳表现的希斯·莱杰多么有影响力，而仅仅是因为小丑在《蝙蝠侠·暗夜骑士》中的表现是无以伦比的，这注定将是电影史最有名的反角之一。<br>22日也是希斯·莱杰去世一周年的纪念日。2008年的这一天，年仅29岁的他被发现猝死纽约曼哈顿租住的公寓中。<br>在这一特殊的日子，我写下了对《暗夜骑士》这部影片的心理分析文章，以此来纪念这位演艺界不多见的奇才。】</p><p>在生活中，我听到见到无数这样的故事，两个相爱的人，一个不断去突破另一个人的底线。<br>这个人的潜在的逻辑是，你说你爱我，这是真的吗？我不信，所谓爱我只是给你的生活添加光彩罢了，如果你真的爱我，你就会不顾一切地爱我，你真的能做到这一点吗？<br>这也是电影《蝙蝠侠·暗夜骑士》（也即《蝙蝠侠》系列影片之六）中隐藏的核心逻辑。</p><p>这部影片的背景是，在黑帮和毒贩横行的高谭市，蝙蝠侠不断神出鬼没地打击罪犯，而他有一个众所周知的规则——不杀人。<br>在蝙蝠侠这位“暗夜骑士”的帮助下，高谭市警长戈登将黑社会老大们一网打尽，而高谭市检察长、有“光明骑士”之称的哈维·邓特试图将他们全部送上法庭，证据确凿，看来他们注定要住在监狱了，而高谭市似乎终于可以恢复平静和光明了。<br>就在这时，小丑出现了，他阴险狡诈，没有任何底线，头脑中也没有任何教条，他以杀死蝙蝠侠为由而将黑帮团结在自己周围，并带领他们和他招募来的精神分裂症患者们随心所欲地杀人，以此向市民们施加压力，让他们迫使蝙蝠侠脱下面具公布身份。<br>这只是影片一条表面的脉络，而影片核心的脉络是，小丑不断刺激哈维·邓特和蝙蝠侠这两个“正义的化身”，甚至希望哈维·邓特将自己击毙，蝙蝠侠将自己杀死。因为这样一来，他们就和他一样了，他们所信奉的正义不过是一个表面上的表演而已，而真正掌握这个世界的，还是小丑的逻辑——“没有迫不得已的时候，谁不想正义凛然？”<br>每个人都以为，他的逻辑是正确的，这个世界在按照他相信的那一套逻辑运转，如果这个世界不是这样的，我们就会以为，这不过是表面现象而已，真正的深层逻辑一定是自己掌握的那一套逻辑，要证明这一点，只需要将别人“轻轻推一下”，这些人就会陷入在自己的逻辑中。<br>例如，假若一个美女相信，男人都不是好东西，男人只是对她的身体感兴趣而根本不会爱她。那么，她会使用她的身体去勾引男人，而她会发现，她只需要这样将男人们“轻轻推一下”，这些男人就会变成贪婪的色鬼。<br>例如，假若一个富人相信，每个人都是贪婪的，有钱能使鬼推磨。那么，他会使用他的金钱将无数人“轻轻推一下”，这些人就会陷入他的掌握中。<br>小丑则认为，每个人都是邪恶的，没有信任可以的，他只需要将人们“轻轻推一下”，每个人都会放弃正义，变得很自私和丑恶，于是出卖别人甚至亲自杀死战友。在影片中，小丑“轻轻推一下”的武器是人们心中的恐惧，他认为，每个人爱的都是自己和自己的亲人，只要你去威胁他们的生命，那么每个人都会放弃原有的底线，而变成恶魔。</p><p>影片一开始就展示了小丑的逻辑。他引诱几个戴着小丑面具的匪徒打劫黑帮的银行，并对他们说，杀死你的同伴，这样你分到的钱更多。于是，这些匪徒果真在抢劫过程中相互屠杀，那些稍有犹豫的人，立即会被同伙干掉，而小丑自己在这个过程中是最果断的，所以他是唯一生存的。<br>对此，这个黑帮银行的头目说：“这座城市的匪徒向来有信念。”他是说，他们是有底线的，这就是“盗亦有道”的意思了，但小丑证明，他只需要“轻轻推一下”，就可以破掉黑帮们的底线。<br>在小丑带领下，他的爪牙们打劫了多个黑帮银行，抢劫了6800万美元，但他竟然堂而皇之地闯进了黑帮老大们的聚会所。因为他明白，只要他“轻轻推一下”，这些黑帮老大们就会团结在他周围。<br>果不其然，当他说，他可以杀死蝙蝠侠时，大多数黑帮老大都被打动了。这既是诱惑，也是利用了恐惧的力量。这个时候，黑帮老大们被蝙蝠侠、哈维·邓特和戈登等光明力量逼到了绝路上，所以当他抛出这个诱饵后，高谭市黑社会很快整个投靠了他。<br>整个影片中，小丑经常利用人性的弱点给出选择题，令我印象深刻的选择题有三个，第一个是他抛给黑社会的。一个黑帮头子讨厌他而发出追杀令，结果被他所杀，而他扔给了活着的两个黑社会爪牙各自一截棍子，说你们只有一个可以活命，你们相互厮杀吧。“盗亦有道”中的一个很重要的“道”是不得内讧，但这个底线，小丑轻易就令他们突破了。<br>黑社会的“盗亦有道”毕竟是不大可靠的，被突破似乎不算什么。那么，那些最光明的正人君子呢？他们的底线能突破吗？接下来的故事显示，这并不是非常难。<br>获得了黑帮的支持后，小丑向哈维·邓特、高谭市警察局长和即将审判黑帮老大们的女法官三人同时发出了死亡威胁，并几乎在同时炸死了女法官和毒死了警察局长。警察局长是在和戈登对话时喝了一杯毒酒被毒死的，当时戈登说，你的周围已有内鬼，你要小心。但此时警察局长毒酒已落肚。<br>显然是内鬼给了警察局长毒酒，但内鬼为什么会听从小丑指挥？影片没给出直接回答，但不难推测的是，小丑向这些警察本人及其亲人发出了死亡威胁，这是小丑一直在使用的手段。<br>要杀死哈维·邓特就没有那么容易了，因为哈维·邓特的未婚妻瑞秋是蝙蝠侠的前女友，蝙蝠侠是哈维·邓特的偶像，而哈维·邓特则是蝙蝠侠心目中的救星。</p><p>两个男人被一个女人爱上，这通常意味着，这两个男人要么很像，要么截然不同。这两点综合起来还有更复杂的情形，即他们要么看上去很像但其实完全不同，或看上去不像但其实本质一样。<br>蝙蝠侠和哈维·邓特又有什么相同和不同呢？<br>蝙蝠侠的真名叫布卢斯·韦恩，是韦恩企业集团的董事长，全世界最富有的男人。他第一次和哈维·邓特相遇是在他的一个餐厅。高谭市检察官想和自己的同事未婚妻瑞秋约会，托了人才在这个餐厅定了一个位子，而恰好遇见了胳膊上挽着俄罗斯芭蕾舞演员的布卢斯·韦恩。不知道布卢斯·韦恩就是蝙蝠侠的哈维·邓特谈起了蝙蝠侠，言辞中充满着崇拜，他认为蝙蝠侠是英雄，而这个混乱的城市需要蝙蝠侠的看护，并担心蝙蝠侠的压力太大，“或是作为英雄战死，或是苟活道目睹自己被逼成坏人。”<br>哈维·邓特是布卢斯·韦恩的情敌，但韦恩还是被哈维·邓特打动了，他想用他的财富帮助这位“光明骑士”，让高谭市民彻底“相信哈维·邓特（这是哈维·邓特的竞选口号）”，他也渴望哈维·邓特愿望实现，将“看护高谭市”的责任交给他。<br>当然，这种无私藏着极大的自私。因为，布卢斯·韦恩仍然爱着瑞秋，而瑞秋不希望嫁给“蝙蝠侠”，过着担惊受怕的生活，她希望和布卢斯·韦恩过平淡而幸福的生活，所以此前对·布卢斯韦恩说过，如果你不再做蝙蝠侠，我就嫁给我。<br>所以，“暗夜骑士”是想将看护高谭市的重担交给“光明骑士”，那样他就可以和心爱的人过幸福生活了。<br>女人是矛盾的，女人常做这样的事情：爱上一个英雄，但对英雄说，你要变成平凡人我才嫁你。然而，这是真的吗？</p><p>因为有蝙蝠侠保护，哈维·邓特一直是安全的，但别人就没那么幸运了，高谭市市长都险些丧命于小丑的阴谋下，其他血腥的杀戮则不断刺激高谭人脆弱的灵魂。<br>最终，蝙蝠侠决定屈从小丑的要求。小丑说，只要蝙蝠侠自首（高谭市警方一直在追捕这位“暴力义警”），他就停止杀戮。这其实是在离间蝙蝠侠和高谭市民的关系。<br>大众比较容易被离间，他们纷纷呼吁蝙蝠侠现身。哈维·邓特质问民众：“你们真地要牺牲这位一直保护你们的英雄吗？”他们纷纷回答说，是的。<br>这时，哈维·邓特说，他就是蝙蝠侠。<br>也就在这一刻，瑞秋第一次真心痛恨起布卢斯·韦恩来，她斥责他让检察长背黑锅，并决定嫁给哈维·邓特。然而，她到底想嫁给谁呢？<br>显然，她是决定嫁给那个最英雄的人，那个最正确的人。那么，她是真的想让蝙蝠侠变成平凡人吗？<br>被捕的哈维·邓特要被送进监狱，小丑则在路上设计杀死他。自然，“暗夜骑士”会来保护“光明骑士”。经过一番激烈的大战后，小丑最后剩下了孤家寡人，而蝙蝠侠则开着高科技摩托车向他撞去。<br>但小丑并不躲闪，而是狞笑着自语：“撞我啊！撞我啊！”<br>一开始，对这一情节我有不解，但随即明白，他是想用自我牺牲来引诱蝙蝠侠突破自己“不杀人”的底线，以此来证明，他才是唯一正确的。<br>“只有我才是正确的”，这种感觉的诱惑力真是强大，为了“捍卫”这种感觉，小丑不惜一死。<br>蝙蝠侠也明白了这一点，在千钧一发时刻，他躲闪，并被摔晕，但小丑还是诈死的戈登被捕了。<br>孰料，被捕也是小丑的一个精心设计的圈套。他知道，戈登没死，而且戈登一定会把他送进戈登自己的特别牢房，那里还关着一个掌握着黑帮所有财富的特殊人物。围绕着这一点，他还设计了许多圈套。<br>但蝙蝠侠和警方不知道这一圈套，他们以为逮捕小丑就可以万事大吉了。但他们很快发现，这是幻觉，小丑的人抓走了哈维·邓特和瑞秋。而在监狱里，小丑给蝙蝠侠出了影片中的第二道选择题：一个地方关着哈维·邓特，另一个地方关着瑞秋，时间有限，你只能救一个，你救谁？<br>蝙蝠侠选择了救瑞秋，这恰恰中了小丑的圈套，小丑故意说错了地点，他说关瑞秋的地点其实关的是哈维·邓特。所以，蝙蝠侠救出的是哈维·邓特，而瑞秋葬身于火海中。<br>对此，布卢斯·韦恩反思，他做了一次“不正确的决定”，终于知道了“蝙蝠侠也有力不能及的事”。这一次也仿佛验证了小丑的逻辑“没到迫不得已的时候，谁不想正义凛然？”</p><p>这不只是蝙蝠侠“力不能及的事”，也是影片中所有好人变坏的原因。小丑的人没拉一个警察下水，都是通过胁迫警察亲人的生命而实现的。譬如瑞秋之所以被绑架，是因为戈登属下的一个女警察受到了这种威胁，而哈维·邓特被绑架也是如此，小丑能够肆无忌惮地制造炸死女法官、毒死警察局长、枪击市长、炸掉高谭综合医院等一系列事情，也都是因为他利用这一威胁突破了一个又一个好人的底线。<br>影片的高潮中，小丑将这一招数发挥到极致。他威胁整个城市的人，要么“成为我的人”，要么离开这个城市。最后一批逃离这个城市的人乘坐了两条船，一条船上是好人，一条船上是那些黑社会老大及其属下。<br>等这两条船开到河中时，突然停下了，并传来了小丑的威胁：每条船上都装有大量炸药，还有一个起爆器，但起爆器控制的是另一条船，只有一条船上的人可以生还，条件是12点前必须引爆另一条船。<br>这是小丑在影片中出的第三道选择题，而且选择范围是民众。民众曾经选择抛弃蝙蝠侠，他们还会选择抛弃别人吗？<br>结果，小丑失败了。载有普通人的船，通过投票决定不引爆起爆器，而载有罪犯的船，起爆器被一个黑社会老大扔到了河里。<br>基督教传说中，魔鬼撒旦赢得世界的方式是捕获人类的灵魂，而小丑使用的是同一逻辑，他对金钱丝毫不感兴趣，他曾将堆积如山的钱付之一炬，说“这个城市配得上一个有品味的罪犯”。他还对蝙蝠侠说：“你应该知道，我对钱没有兴趣，我不是那种人，你不要把我降格成那种人。”<br>小丑感兴趣的是，将他的逻辑——“没有迫不得已的时候，谁不想正义凛然？”——强加给周围的世界。对这一点，布卢斯·韦恩的管家阿尔弗雷德一开始就发现了，他给蝙蝠侠举例说，曾经有匪徒劫走了他们的宝石，但他们却将这些宝石随处丢弃，他们其实对宝石并不感兴趣，他们这么做，仅仅是因为“他们觉得有意思。他们不会被收买，不会被恐吓，不会讲道理，也不会接受谈判，有些人就是想看着这个世界燃烧。”<br>在我看来，这也是所有最邪恶罪犯的共同欲望，他们感兴趣的不是钱权名利等看得见摸得着的事物，他们要的是影响力，他们想将他们的意志强加给这个世界，让这个世界随着他们的欲望而战栗，用普通的逻辑看待他们是行不通的。</p><p>在这一点上，匪徒和英雄也常常是一个硬币的两面，他们要的其实都是影响力，而不是正义、公平、普世道理或“绝对正确的事”。<br>哈维·邓特就是这样的例子。影片的高潮是第三个选择，在这个选择上，小丑输了，但小丑仍哈哈大笑，因为认为他在“高谭灵魂之战”上赢了。<br>小丑的意思是，他用他的逻辑击败了哈维·邓特，最终让这位“光明骑士”服膺了他的逻辑。<br>这是真的。瑞秋丧生后，哈维·邓特绝望了。尽管蝙蝠侠救了他，但他的左半边脸被汽油烧烂了，皮肤脱落，肌肉和牙齿裸露，无比疼痛，但他拒绝接受任何去痛治疗。<br>这可以理解，因为，比起失去爱人的心痛来，这种肉体的痛更容易承受，而且它可以让自己的注意力从心痛上转到肉体的痛上来。<br>双重的痛让哈维·邓特放弃了“对公正的狂热追求”，转而变成了一个彻底的机会主义者，他追踪并拷问所有牵涉到瑞秋之死的人，并通过抛硬币来决定对方的生死。<br>“光明骑士”变成“双面骑士”，这看起来令人心痛，但这并非偶然。影片显示，他很早就有一个绰号“双面人”，而他一直喜欢抛硬币，他表现出的“对公正的狂热追求”不过是一面而已，而他的另一面早就存在，小丑的逻辑“没有迫不得已的时候，谁不想正义凛然？”可以不折不扣地用在他身上。<br>可以说，哈维·邓特并不是在追求“光明”，而是他发现，他可以通过追求光明来追求影响力，他通过“对公正的狂热追求”成为高谭市民的偶像，他也通过替蝙蝠侠背黑锅而终于获得了瑞秋的爱。这是极大的好处。<br>然而，瑞秋死了，他的生存逻辑也随之一下子被颠覆了。<br>从这一点看来，他与蝙蝠侠只是“形似而神离”，通俗说来，就是他看上去与蝙蝠侠很像，但本质上有根本差异。<br>这一差异是，蝙蝠侠对影响力没有兴趣，他追求的是正义。影片最后，他甘愿替哈维·邓特背黑锅，将这位“光明骑士”的杀业承担在自己身上，不惜令人们以为他已破了杀戒。但他愿意承担这一切，而让高谭人去迎接光明，这不是一个表现出来的英雄，而是一个真实的英雄。<br>重要的不是形式，重要的是灵魂，这是小丑和蝙蝠侠的共同之处。<br>并且，尽管小丑似乎没有任何底线，并说自己是“混乱的代理人”，说他憎恨秩序，但他想营造的世界仍然是有秩序的。<br>他想让世界恐惧，这不过是他的“内在的暴虐的父亲”折磨他的“内在的受虐的小男孩”的外化而已。他曾服膺于父亲的逻辑，认同了那个“内在的暴虐的父亲”，而他也希望整个世界和曾经的他一样，屈从于这种暴力之下。<br>但是，他的内心深处的那个小男孩又惧怕这一点的实现，因为这意味着他的所有世界都将陷入黑暗，将不再有任何光亮。所以，当有人真的想暴露蝙蝠侠的真实身份时，他却向这个人发出了追杀令。<br>甚至，我想，即便蝙蝠侠真的没有了抵抗能力，任他宰割时，他会放弃。或者，他会杀掉这个蝙蝠侠，然后再去找一个蝙蝠侠去杀。如果这个世界上只有一个蝙蝠侠的话，他会舍不得杀的。这不只是为了不断斗下去而活在“一个不那么无聊的世界”，也是他内心深处那个小男孩的一点微弱而坚定的呼声。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷完300道leetcode的感想</title>
      <link href="/blog/posts/3d49f50c/"/>
      <url>/blog/posts/3d49f50c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近几个月刷了将近300道力扣题，这里记录下。</p></blockquote><p>首先，我想说的是，这种东西应该早点开始刷，可惜因为自己并非计算机科班出身，大学也对编程没产生兴趣，一直到参加工作，误打误撞接触到程序员这个行业，才开始真正的学习计算机基础，网络，算法之类的，但是现在开始也还行，毕竟，开始做一件事的最好时间点是十年前，另一个是现在。</p><h2 id="留个截图"><a class="header-anchor" href="#留个截图">¶</a>留个截图</h2><p><img src="./arfreafd.PNG" alt></p><p>刚开始刷的感受，很绝望</p><p><img src="./sdafths.jpg" alt></p><p>后来多刷，找到了一点感觉</p><p><img src="./1dguygffs.jpg" alt></p><h2 id="一点点收获"><a class="header-anchor" href="#一点点收获">¶</a>一点点收获</h2><p>第一，我发现自己对于边际的考虑变得更加完善了，每写一段代码都要考虑到边际问题。数组长度是否为0？对象的属性有没有可能为null，各种特殊情况下的考虑和兼容处理。<br>第二，写代码的逻辑也渐渐清晰起来，每个if都要考虑else怎么处理，对于不能处理的入参即使的return，使得整体的代码看起来更加容易。<br>第三，对性能上的考虑，每一步都要考虑有没有必要这样做，能不能空间换时间，能不能加上记忆化备忘录，能不能减少对象的创建和销毁，能不能用下标的移动代替数组切割等等。<br>第四，学到了之前没接触过或者深入了解的数据结构，比如单调栈的使用，优先级队列的使用和原理（可以用堆实现），并查集处理“家族”问题，前缀和的使用，了解了哈希表的实现原理。</p><h2 id="从二叉树中吸取的经验"><a class="header-anchor" href="#从二叉树中吸取的经验">¶</a>从二叉树中吸取的经验</h2><p>刷题我建议从二叉树开始刷，培养递归的意识，毕竟仔细想一下，其实代码块就是一个树型的结构，代码会被编译成AST语法树，进行解析运行，所以，多了解二叉树对培养逻辑思考很有帮助。</p><p>比如这道题：</p><blockquote><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p></blockquote><blockquote><p>例如：</p></blockquote><blockquote><p>给定二叉树 [3,9,20,null,null,15,7]，</p></blockquote><pre><code>    3   / \  9  20    /  \   15   7</code></pre><blockquote><p>返回它的最大深度 3 。</p></blockquote><p>一个答案是：</p><pre><code class="language-javascript">/** * @param {TreeNode} root * @return {number} */var maxDepth = function(root) {    if(!root) {        return 0    }    return Math.max(maxDepth(root.left),maxDepth(root.right)) +1};</code></pre><p>这里就用到了递归的思想。</p><h2 id="数学上的归纳和总结"><a class="header-anchor" href="#数学上的归纳和总结">¶</a>数学上的归纳和总结</h2><p>很多题表面上是编程题，其实是数学题，比如有些动态规划，总结出状态转移方程就可以很轻松AC，否则暴力解决必定超时。</p><p>但是，动态规划不同题型，不同场景下的变化很大，有时候很难找出对应的动态转移方程。这里真的需要大量的练习才能好好的理解其中的道理。动态规划我自己感觉是最难，变化最灵活的题型了。<br>分享下动态规划的类型，这也是我下一步需要重点练习的内容。</p><p>1.背包 DP。<br>2.区间 DP。<br>3.DAG 上的 DP。<br>4.树形 DP。<br>5.状压 DP。<br>6.数位 DP。<br>7.插头 DP。<br>8.计数 DP。<br>9.动态 DP。<br>10.概率 DP。</p><h2 id="多利用题目给的前提条件"><a class="header-anchor" href="#多利用题目给的前提条件">¶</a>多利用题目给的前提条件</h2><p>比如有些给的数组是有序的，或者给的二叉树是二叉搜索数，利用好给的前提条件，才能写出更高效率的代码。<br>这里要有一些肌肉反应。<br>顺序数组 —&gt; 二分搜索<br>二叉搜索数 —&gt; 中序遍历</p><h2 id="发现自己的薄弱部分"><a class="header-anchor" href="#发现自己的薄弱部分">¶</a>发现自己的薄弱部分</h2><p>对很多算法没研究，比如并查集，图的算法，稍微变形的动态规划题，一直没有思路，以后要先系统学习一遍这些内容，在开始进行练习。</p><p>以后每日一题要坚持下去，关键是要真的搞懂，不能单纯背答案。</p><p>over~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript实现优先级队列</title>
      <link href="/blog/posts/5d46f50c/"/>
      <url>/blog/posts/5d46f50c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>鉴于javascript 没有实现优先级队列，这里记录一个用堆实现的代码</p></blockquote><pre><code class="language-javascript">class Heap {    constructor(data = [], cmp = (lhs, rhs) =&gt; lhs - rhs) {        if (typeof data === 'function') {            cmp = data            data = []        }        this.data = [null, ...data]        this.size = data.length        this.lt = (i, j) =&gt; cmp(this.data[i], this.data[j]) &lt; 0        for(let i = this.size; i &gt; 0; i--) this.heapify(i)    }    push(v) {        this.data.push(v)        let i = ++this.size        while(i &gt;&gt; 1 &amp;&amp; this.lt(i, i &gt;&gt; 1)) this.swap(i, i &gt;&gt;= 1)    }    pop() {        this.swap(1, this.size)        const top = this.data.pop()        this.size--        this.heapify(1)        return top    }    top() { return this.data[1] }    heapify(i) {        while (true) {            let min = i            const [l, r, n] = [i * 2, i * 2 + 1, this.data.length]            if (l &lt; n &amp;&amp; this.lt(l, min)) min = l            if (r &lt; n &amp;&amp; this.lt(r, min)) min = r            if (min !== i) this.swap(i, min), i = min            else break        }    }    swap(i, j) {        const d = this.data;        [d[i], d[j]] = [d[j], d[i]]    }}let queue = new Heap((l, r) =&gt; l - r) queue.push(1)queue.push(43)queue.push(13)queue.push(99)queue.push(-23)console.log(queue.top())// -21queue.pop()console.log(queue.top())// 1</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是真正的兴趣爱好</title>
      <link href="/blog/posts/5d7d167c/"/>
      <url>/blog/posts/5d7d167c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>来源网络</p></blockquote><p>★哪些东西【不能算】兴趣和爱好？</p><p>在本文的开头，俺想从【反面】来陈述这个话题——点评一下那些“容易跟兴趣爱好混为一谈的东西”。（对这些东西，俺称之为“伪兴趣”）<br>　　通过识别“伪兴趣”，有助于你去伪存真，识别出真正的兴趣。</p><p>◇三分钟热度，不是真正的兴趣</p><p>如果你留意观察儿童的行为，就会明白何为“三分钟热度”？比如当某个小孩得到自己喜欢的玩具，会很开心很兴奋。但是几天（甚至几小时）之后，这种开心兴奋状态就消失了——他/她的兴趣点已经转移到其它地方。<br>　　显然，“三分钟热度”不是真正的兴趣。这个很好理解，俺就不多说了。</p><p>◇动机带有【功利】因素，不是真正的兴趣</p><p>关于这点，就以今年（2015）的股灾为例。<br>　　在咱们天朝，每当牛市的时候，就有很多股民成天盯着电脑上的炒股软件，片刻不停。<br>　　如果你以为他们对“炒股”感兴趣，那就错了。大部分股民其实对“炒股”这个行为本身并【没有】兴趣——他们这么做是为了【赚钱】。换句话说，他们的行为带有“功利因素”，因此不能算是真正的兴趣。<br>　　（另外，确实有一小撮股民是真正喜欢“炒股”这个行为本身。但是这类人非常之少）</p><p>◇来自【外在】的动机，不是真正的兴趣</p><p>所谓“外在的动机”，大致包括如下：</p><ol><li>被别人强迫去做某事<br>（比如很多小孩被父母强迫去学钢琴）</li><li>受到社会观念的约束而去做某事<br>（比如大学填志愿的时候，报考热门专业）</li><li>为了得到他人的认可而去做某事<br>（比如某些人为了出名而去做某事）</li><li>受到法律的约束而去做某事<br>（比如很多国家的义务兵役制）<br>…<br>　　以上只是列出几种典型的情形，未必全面。欢迎大伙儿补充。<br>　　关于“外在的动机”，显然不是真正的兴趣。这个也比较好理解，俺就不深入聊了。</li></ol><p>◇【纯感官】的刺激导致的行为，不是真正的兴趣</p><p>所谓“真正的兴趣”，显然是人类独有的（其它动物不会有）。而“纯感官的刺激”导致的行为，不光人类会有，其它动物也会有。<br>　　所以，纯感官的刺激导致的行为，【不能算】真正的兴趣。对这类行为，俺更愿意称之为“本能的驱使”。<br>　　为了便于理解，举几个例子：吃顿美餐、泡个温泉…</p><p>◇【被动】的行为，不是真正的兴趣</p><p>请注意，本小节所说的“被动”，【不是】指他人的强迫。（“他人的强迫”已经在前面的小节分析过了）<br>　　本小节所说的“被动”，指的是【行为本身的特性】。换句话说，当某个行为【不】需要依靠你的主观意识，【不】需要发挥你的主动性，那么，俺就称之为“被动的行为”。<br>　　为了便于理解，同样举个例子：<br>　　有很多人喜欢一边工作一边听音乐。在这种情况下，“听音乐”这个行为是被动的。</p><p>◇始终停留在【心理舒适区】，不是真正的兴趣</p><p>首先来解释一下，何为“心理舒适区”。这玩意儿，洋文称之为“Comfort Zone”，用来描述一种“心理状态”。处于这种状态，你会感觉到放松，没有压力和焦虑。<br>　　如果你处于某个环境中，在该环境下所需要的行为你都可以轻松搞定。那么，你就处于“心理舒适区”。<br>　　举例：<br>　　俺曾经问过周围的一些人，他们业余时间有啥兴趣和爱好。在俺听到的反馈中，如下这几种很常见：<br>上网闲逛<br>看视频（短视频、影片、连续剧）<br>看八卦新闻<br>　　在俺看来，上述这几种行为都属于“让自己停留在心理舒适区”。这类行为，很多都是为了打发时间，【不能】算是真正的兴趣。</p><p>★【真正的】兴趣和爱好，具有哪些特征？</p><p>前面说了一大堆“反例”，接下来开始进入正题。</p><p>◇动机的【内在性】</p><p>真正的兴趣，其动机完全来自于内心，而不是外部世界。<br>　　只有这样产生的兴趣，才是纯粹的。换句话说，这样的动机，【不会】随着外部世界的改变而改变。</p><p>◇时间的【持久性】</p><p>对于真正的兴趣，通常能持续很长时间（至少几年，多达几十年）。<br>　　为啥“真正的兴趣”能持续这么久捏？在本文下面的章节，俺会分析。</p><p>◇思维的高度参与</p><p>前面提到了两种反例，分别是“纯感官刺激的行为”和“被动行为”。<br>　　与这两种相对应的是：真正的兴趣，其行为通常需要思维的高度参与。<br>　　举例：<br>　　下面这些活动都需要思维的高度参与，也都【有可能】成为真正的兴趣。</p><pre><code>  1.写程序  2.写作  3.作曲  4.绘画  5.摄影  6.电子游戏  7.棋牌游戏......</code></pre><p>◇快感的【内在性】</p><p>前面的小节提到了“动机的【内在性】”。这里所说的“快感的【内在性】”，也类似滴。通俗地说：真正的兴趣所导致的快感，【不需要】依赖外部环境。<br>　　举例：<br>　　数学史上很牛逼的费马（又称“费尔马”，洋文是“Fermat”），完全是凭兴趣研究数学，而且他的很多研究成果都【没】发表。比如他最有名的那个“费马大定理”，是他儿子整理遗物的时候发现的；再比如“费马小定理”是他与朋友的往来书信中顺便提及的。<br>　　也就是说，他的快乐【不是】依赖“荣誉感”之类的外在因素。<br>　　顺便说一下：费马严格来说连“数学家”都不是。他的正式职业是律师和法官，数学只是他的业余爱好。</p><p>◇不一样的快感</p><p>当你从事自己真正感兴趣的活动，通常会体验到不一样的快感——这快感就是你的动力。前面俺提到说，真正的兴趣可以持续很多年，原因也在于这快感。<br>　　兴趣与爱好导致的快感，大致可以分为两类：“过程性的快感”和“结果性的快感”。<br>　　这两种快感的差别在于：“过程性的快感”持久但是强度不高；“结果性的快感”只在短暂时间段发生，但是强度很高。<br>　　举例：<br>　　就拿俺的老本行来说事儿。当俺在写程序的时候，（不管是在公司里写还是在业余时间写）总是乐在其中。也就是说，单单是“写代码的过程”就可以让俺觉得快乐——这是“过程性的快感”；当连续几个月，终于完成了某个软件，这时候体验到的是“结果性的快感”。<br>　　“过程性的快感”虽然强度不高，但也很重要——这类快感使得你可以【持久地】从事感兴趣的活动（即便在你尚未获得成果的阶段，它也在起作用）。</p><p>◇成瘾性</p><p>如前一个小节所说，真正的兴趣会给你带来快感。因此，真正的兴趣通常也会带来【成瘾性】。<br>　　（关于“快感”与“成瘾性”的关系，这是心理学和脑神经学的重要研究话题。但是这个话题与本文的主题无关，所以俺就不展开了）<br>　　再拿俺自己举例：<br>　　比如俺连续几周没有写代码，就会手痒。虽然在许多年前已经转为管理岗位，不需要亲自写代码，但俺还是尽量找机会亲自操刀——在公司开发的软件中，挑一两个有难度的模块来写。<br>　　另外，在没有开博客之前，俺也会在业余时间写点小工具啥的练练手（可惜近几年维护博客耗费了太多时间）</p><p>◇愿意付出较高的代价</p><p>从事自己真正感兴趣的活动，你会愿意付出其它的代价。为啥捏？因为前面提及的“快感”会给予你补偿。换句话说：快感会抵消掉“付出代价”所导致的负面情绪。<br>　　举例：<br>　　某个摄影爱好者为了拍摄到火山喷发的镜头，愿意冒生命危险待在火山口附近。</p><p>◇持续的自我提升（走出心理舒适区）</p><p>如果某个活动是你真正的兴趣，那你不会满足于“只停留在该领域的心理舒适区”。你会不断尝试去突破自己的心理舒适区。通过不断地突破自己的心理舒适区，你在这个领域的能力就会得到提升；同时，你的心理舒适区的范围也扩大了。<br>　　当然，突破心理舒适区不一定容易，有的时候甚至是很困难的。但是在突破的过程中，“过程性的快感”会伴随着你；一旦实现突破，你会获得“结果性的快感”。</p><p>突破心理舒适区导致的能力提升，大致有两类：“深度”的提升 ＆“广度”的提升。对这两类，分别举例如下：<br>　　举例1：<br>　　假设有个热衷于编程的 C++ 程序员，通过不断学习，让自己从 C++ 的新手变成老手——这属于“深度的提升”。<br>　　举例2：<br>　　假设有个热衷于编程的 C++ 程序员，通过不断学习，又学会了另一门编程语言 Lisp——这属于“广度的提升”。</p><p>◇存在【心流】（物我两忘）的现象</p><p>当你从事自己真正感兴趣的活动，有时候你会进入到【心流】的状态。这词儿可不是俺杜撰滴，而是心理学的专门术语，洋文称之为“flow”，相关的维基词条在“这里”。<br>　　这种状态大概就是传说中的“物我两忘”。在这种状态下，你会忘记了时间的存在，甚至忘记自己的存在，全身心都融入到你感兴趣的活动当中。<br>　　举例：<br>　　某些非常热衷围棋的爱好者，在对弈或打谱的时候，就会进入到这种状态。此时他们的眼中只有棋盘，周围的世界仿佛都不存在了。</p><p>★【真正的】兴趣爱好对人生的影响</p><p>如果你能找到自己真正的兴趣爱好，对你的人生至少会产生如下一些影响：</p><p>◇更多的快乐</p><p>这是最显著的一个影响，也是俺在前面章节多次提及的“快感”。</p><p>◇更充实的生活</p><p>有了真正的兴趣爱好，通常就不需要找一些事情来“打发时间”。反之，你可以把所有的闲暇时间都用在你感兴趣的领域和活动。<br>　　相比之下，那些经常感叹生活空虚的人，通常都缺乏真正的兴趣和爱好。</p><p>◇兴趣与工作的结合</p><p>如果你够幸运的话，还可以让“自己的兴趣”成为“自己的职业”——这是很幸福的事情 😃 如此一来，就把“工作”和“娱乐”合为一体。你将不再有“工作时间”和“业余时间”的差异——不论是“工作时间”还是“业余时间”，对你而言都是【娱乐时间】。这当然很爽！<br>　　当这两者统一之后，还有更多其它的好处。比如说，你在自己的工作中，更有可能比别人走得更远，因此也就更有可能成为该领域的【优秀】者。（请注意，“优秀”和“卓越”是完全不同滴，别混淆了。在《成功学批判——简述其危害性及各种谬误》一文中，俺澄清了这两者的差异）<br>　　一旦你成为某个领域的优秀者，你就具备了【个人竞争优势】。这种情况下，你通常不至于太缺钱（当然，也会有极少数例外）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3-new-feature</title>
      <link href="/blog/posts/20a24eb5/"/>
      <url>/blog/posts/20a24eb5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>总结一下最近一段时间学习 vue3 的收获</p></blockquote><h2 id="功能方面"><a class="header-anchor" href="#功能方面">¶</a>功能方面</h2><h4 id="composition-api-组合api"><a class="header-anchor" href="#composition-api-组合api">¶</a>Composition API (组合API)</h4><p>Composition API 的灵感来自于 React Hooks ，是比 mixin 更强大的存在。它可以提高代码逻辑的可复用性，从而实现与模板的无关性；同时函数式的编程使代码的可压缩性更强。另外，把 Reactivity 模块独立开来，意味着 Vue3.0 的响应式模块可以与其他框架相组合。<br>官方例子</p><pre><code class="language-javascript">    // 鼠标位置侦听逻辑     function useMouse() {            const state = reactive({                x: 0,                y: 0            })            const update = e =&gt; {                state.x = e.pageX                state.y = e.pageY            }            onMounted(() =&gt; {                window.addEventListener('mousemove', update)            })            onUnmounted(() =&gt; {                window.removeEventListener('mousemove', update)            })            return toRefs(state)        }</code></pre><p>总的来说，就是把相关的逻辑单独拿出来提高代码复用</p><h4 id="全局挂载-配置api更改"><a class="header-anchor" href="#全局挂载-配置api更改">¶</a>全局挂载/配置API更改</h4><p>vue2 使用 new Vue 创建实例，通过全局设置config配置vue的可选配置。<br>vue3 使用 createApp 定义的某个 Vue 程序。它可以使你的代码更易于理解，并且不易出现由第三方插件引发的意外问题。目前，如果某些第三方解决方案正在修改 Vue 对象，那么它可能会以意想不到的方式（尤其是全局混合）影响你的程序，而 Vue 3 则没有这个问题.</p><pre><code class="language-javascript">import { createApp } from 'vue'import App from './App.vue'const app = createApp(App)app.config.ignoredElements = [/^app-/]app.use(/* ... */)app.mixin(/* ... */)app.component(/* ... */)app.directive(/* ... */)app.mount('#app')</code></pre><h4 id="fragments-片段"><a class="header-anchor" href="#fragments-片段">¶</a>Fragments(片段)</h4><p>在书写vue2时，由于组件必须只有一个根节点，很多时候会添加一些没有意义的节点用于包裹。Fragment组件就是用于解决这个问题的（这和React中的Fragment组件是一样的）。</p><h4 id="suspense"><a class="header-anchor" href="#suspense">¶</a>Suspense</h4><p>同样的，这和React中的Supense是一样的。Suspense 让你的组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容。</p><pre><code class="language-html">&lt;Suspense&gt;  &lt;template &gt;    &lt;Suspended-component /&gt;  &lt;/template&gt;  &lt;template #fallback&gt;    Loading...  &lt;/template&gt;&lt;/Suspense&gt;</code></pre><h4 id="v-model-支持多个"><a class="header-anchor" href="#v-model-支持多个">¶</a>v-model 支持多个</h4><p>在 3.x 版本中，在自定义组件上使用 v-model 相当于传递了一个 modelValue 属性以及触发一个 update:modelValue 事件。<br>如果要改变绑定的属性名，只需要给 v-model 传递一个参数就好了：</p><pre><code class="language-html">&lt;KyrieInput v-model:title=&quot;name&quot; /&gt;&lt;!-- 等同于 --&gt;&lt;KyrieInput :title=&quot;name&quot; @update:title=&quot;name = $event&quot; /&gt;</code></pre><p>这个写法还彻底代替了 .sync 修饰符，并且支持统一组件绑定多个 v-model</p><h4 id="portals"><a class="header-anchor" href="#portals">¶</a>Portals</h4><p>Teleport其实就是React中的Portal。Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。</p><h2 id="实现逻辑重大更改"><a class="header-anchor" href="#实现逻辑重大更改">¶</a>实现逻辑重大更改</h2><h4 id="响应式原理"><a class="header-anchor" href="#响应式原理">¶</a>响应式原理</h4><p>Object.defineProperty -&gt; Proxy<br>Object.defineProperty是一个相对比较昂贵的操作，因为它直接操作对象的属性，颗粒度比较小。将它替换为es6的Proxy，在目标对象之上架了一层拦截，代理的是对象而不是对象的属性。这样可以将原本对对象属性的操作变为对整个对象的操作，颗粒度变大。</p><p>javascript引擎在解析的时候希望对象的结构越稳定越好，如果对象一直在变，可优化性降低，proxy不需要对原始对象做太多操作。</p><p>同时，有了Proxy，就不用考虑新增属性的响应行为了，是时候要跟$set说声再见了。</p><h2 id="性能方面"><a class="header-anchor" href="#性能方面">¶</a>性能方面</h2><p>双向响应原理由Object.defineProperty改为基于ES6的Proxy，使其颗粒度更大，速度更快，且消除了之前存在的警告；<br>重写了 Vdom ，突破了 Vdom 的性能瓶颈<br>进行了模板编译的优化<br>进行了更加高效的组件初始化</p><h4 id="支持tree-shaking-更加解耦的代码结构"><a class="header-anchor" href="#支持tree-shaking-更加解耦的代码结构">¶</a>支持tree-shaking , 更加解耦的代码结构</h4><p>支持了 tree-shaking （剪枝）：像修剪树叶一样把不需要的东西给修剪掉，使 Vue3 的体积更小。</p><p>需要的模块才会打入到包里，优化后的 Vue3.0 的打包体积只有原来的一半（13kb）。哪怕把所有的功能都引入进来也只有23kb，依然比 Vue2.x 更小。像 keep-alive 、 transition 甚至 v-for 等功能都可以按需引入。</p><h4 id="模板性能提升"><a class="header-anchor" href="#模板性能提升">¶</a>模板性能提升</h4><p>在之前的VDOM中，如果msg值发生改变，整个模版中的所有元素都需要重新渲染。但在Vue3.0中，在这个模版编译时，编译器会在动态标签末尾加上 /* Text*/ PatchFlag。只能带patchFlag 的 Node 才被认为是动态的元素，会被追踪属性的修改。并且 PatchFlag 会标识动态的属性类型有哪些，比如这里 的TEXT 表示只有节点中的文字是动态的。<br>每一个Block中的节点，就算很深，也是直接跟Block一层绑定的，可以直接跳转到动态节点而不需要逐个逐层遍历。<br>既有VDOM的灵活性，又有性能保证。<br>vue3 使用 hoistStatic 静态节点提升<br>当使用hoistStatic时，所有 静态的节点都被提升到render方法之外。这意味着，他们只会在应用启动的时候被创建一次，而后随着每次的渲染被不停的复用。</p><h4 id="时间分片"><a class="header-anchor" href="#时间分片">¶</a>时间分片</h4><p>在动态节点和数据的量都很大时，那么在数据更新时，js线程就会用很长的时间来执行vdom的相关计算，如果超过了16ms，造成交互或动画等等卡顿现象。而时间分片就是把vdom的大量计算分成多个小任务，保证每个小任务在16ms内执行完，从而不会阻塞用户交互，避免卡顿现象。<br>然鹅，此功能还未包含在vue3的更新中。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/147022323" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/147022323</a><br><a href="https://www.jianshu.com/p/1d2846f2a855" target="_blank" rel="noopener">https://www.jianshu.com/p/1d2846f2a855</a><br><a href="https://v3.vuejs.org/" target="_blank" rel="noopener">https://v3.vuejs.org/</a><br><a href="https://segmentfault.com/a/1190000024580501" target="_blank" rel="noopener">https://segmentfault.com/a/1190000024580501</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启网页3D效果之旅</title>
      <link href="/blog/posts/3d46f50c/"/>
      <url>/blog/posts/3d46f50c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上古时代，当<code>html</code>语言和<code>http</code>协议刚被发明出来时，这些专家们也许怎么也想不到，当初发明来共享文本的技术如今统治了几乎整个互联网行业。当第一个网页被打开时，上面只有简陋的一个表单，甚至做一个简单的过渡变色效果，都要借用<code>java Applet</code>，后来要借助<code>javascript</code>。短短十几年过去，现在有了<code>css3</code>，你只需定义简单的<code>transition</code>,就可以实现各种神奇的过渡效果。</p></blockquote><p>本文不是介绍<code>css3</code>动画以及用法的，因此需要读者预先了<code>transition</code>,<code>transform</code>等属性。</p><p>###　回顾下<code>CSS3</code>的基础属性</p><h4 id="1-transition"><a class="header-anchor" href="#1-transition">¶</a>1.<code>transition</code></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition" target="_blank" rel="noopener">Transition</a>是被用到最多的也是最简单的<code>CSS3</code>动画类型，如果你想实现鼠标划过更改背景色的功能，用<code>transition</code>是最简单的方式。</p><pre><code class="language-html">&lt;button&gt;会变色的按钮&lt;/button&gt;</code></pre><pre><code class="language-css">button {    transition: all 0.8s ease;     background-color: red;}button:hover {    background-color: #EEEEEE;}</code></pre><p>下面是效果：</p><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master/img/1.gif" alt="gif"></p><p><strong>transition</strong> <a href="https://developer.mozilla.org/en/CSS" target="_blank" rel="noopener">CSS</a> 属性是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-property" target="_blank" rel="noopener"><code>transition-property</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-duration" target="_blank" rel="noopener"><code>transition-duration</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function" target="_blank" rel="noopener"><code>transition-timing-function</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-delay" target="_blank" rel="noopener"><code>transition-delay</code></a> 的一个<a href="https://developer.mozilla.org/en-US/docs/CSS/Shorthand_properties" target="_blank" rel="noopener">简写属性</a>。分别是可变换属性，持续时间，变换的过度函数(就是变换的加速度曲线)，效果生效的延时。</p><p>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition" target="_blank" rel="noopener">Transition</a>的更多<code>API</code>，请查看<code>MDN</code>的文档。</p><h4 id="2-transform"><a class="header-anchor" href="#2-transform">¶</a>2.<code>transform</code></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform" target="_blank" rel="noopener">transform</a>是执行元素旋转，缩放，位移，倾斜的<code>css</code>属性，它是通过修改视觉上的坐标空间实现的。</p><p>⚠️ 只能转换盒子模型定位的元素。</p><ul><li>旋转<br><code>rotate(a)</code><br>a是一种<angle>，表示旋转的角度，比如<code>30deg</code>。 正角度表示了顺时针的旋转，负角度表示逆时针的旋转。</angle></li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;rotated&quot;&gt;旋转45度&lt;/div&gt;&lt;div class=&quot;rotated2&quot;&gt;旋转90度&lt;/div&gt;</code></pre><pre><code class="language-css">div { width: 80px; height: 80px; background-color: skyblue;}.rotated { transform: rotate(45deg);  background-color: pink;}.rotated2 {   transform: rotate(90deg);    background-color: blue;   color: #ffffff;}</code></pre><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master//img/2.gif" alt="gif"></p><ul><li>缩放<br><code>scale(a,b,c)</code><br><em>单一数值</em><br>单一的数值即指定了一个缩放系数，同时作用于X轴和Y轴让该元素进行缩放，相当于指定了单个值的scale()(2D缩放)函数。<br><em>两个长度/百分比值</em><br>两个数值即分别指定了2D比例的X轴和Y轴的缩放系数，相当于指定了两个值的scale()（2D缩放）函数。<br><em>三个长度/百分比值</em><br>三个数值即分别指定了3D比例的X轴、Y轴和Z轴的缩放系数. 相当于一个scale3d()函数。<br>none<br>指定不进行缩放。</li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;scale&quot;&gt;大2倍&lt;/div&gt;&lt;div class=&quot;scale2&quot;&gt;水平1.5倍，垂直2倍&lt;/div&gt;</code></pre><pre><code class="language-css">div { width: 80px; height: 80px; background-color: skyblue; text-align: center; transform-origin: 0 0;}.scale { transform: scale(2); background-color: pink;}.scale2 {   transform: scale(1.5, 2);   background-color: blue;   color: #ffffff;}</code></pre><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master//img/3.gif" alt="gif"></p><ul><li>位移<br><code>translate(x,y)</code><br>x,y 分别是 x,y轴移动的距离。</li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;translate&quot;&gt;右，下移30px&lt;/div&gt;</code></pre><pre><code class="language-css">div { width: 80px; height: 80px; background-color: skyblue; text-align: center; transform-origin: 0 0;}.translate { transform: translate(30px, 30px); background-color: pink;}</code></pre><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master//img/4.gif" alt="gif"></p><ul><li>倾斜</li></ul><p><code>skew(x-angle,y-angle)</code><br>定义沿着 X 和 Y 轴的 2D 倾斜转换。</p><pre><code class="language-html">&lt;div&gt;Normal&lt;/div&gt;&lt;div class=&quot;skewed&quot;&gt;Skewed&lt;/div&gt;</code></pre><pre><code class="language-css">div {  width: 80px;  height: 80px;  background-color: skyblue;}.skewed {  transform: skew(10deg); /* Equal to skewX(10deg) */  background-color: pink;}</code></pre><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master//img/5.gif" alt="gif"></p><h4 id="3-animation"><a class="header-anchor" href="#3-animation">¶</a>3.<code>animation</code></h4><p>我们可以把<code>transition</code>和<code>transform</code> 结合在一起使用，就实现动感十足的html页面。<br>但是，<code>transition</code>只能实现开始和结束的状态，并且只能“动一次”。</p><p>还有更加强大的<code>animation</code>属性，可以制作不间断，存在中间状态的动画。</p><p>💥 这里穿插介绍一个<code>animation</code>动画库，<a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener">https://daneden.github.io/animate.css/</a></p><p><code>animate.css</code>里面实现了很多常见的淡入淡出，方向移动的动画，可以看下源码，然后自己实现动画的时候就有头绪了。</p><p>下面是一个简单的fadeout 效果的源代码</p><pre><code class="language-css">@keyframes fadeOutDown {  from {    opacity: 1;  }  to {    opacity: 0;    transform: translate3d(0, 100%, 0);  }}</code></pre><p>点击<code>animate.css</code>官网可以查看更多的效果哦。<img src="https://raw.githubusercontent.com/x1nes/imageUrl/master/img/6.gif" alt="gif"></p><p>理论上，任何单独的<code>css</code>属性都可以拿来做动画，但是注意一点🙉从无到有，不要用<code>display:none</code>,应该用<code>opacity</code>属性。</p><p>然后是<code>animate</code>的属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">CSS</a> <strong>animation</strong> 属性是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name" target="_blank" rel="noopener"><code>animation-name</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-duration" target="_blank" rel="noopener"><code>animation-duration</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-timing-function" target="_blank" rel="noopener"><code>animation-timing-function</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-delay" target="_blank" rel="noopener"><code>animation-delay</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-iteration-count" target="_blank" rel="noopener"><code>animation-iteration-count</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-direction" target="_blank" rel="noopener"><code>animation-direction</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-fill-mode" target="_blank" rel="noopener"><code>animation-fill-mode</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-play-state" target="_blank" rel="noopener"><code>animation-play-state</code></a> 属性的一个简写属性形式。</p><p>这里不一一介绍了。</p><h1></h1><h3 id="进入主题-transform的3d效果"><a class="header-anchor" href="#进入主题-transform的3d效果">¶</a>进入主题–<code>transform</code>的<code>3D</code>效果</h3><p>☑️ 网页的<code>3D</code>坐标系：</p><p><img src="https://raw.githubusercontent.com/x1nes/imageUrl/master//img/1328957-20190425135458622-1593901679.jpg" alt></p><p>如上图，网格就是网页的坐标系。有了这张图，就可以很轻松的想到如何运用<code>css</code>的属性得到想要的效果。</p><h4 id="1-如何使用3d"><a class="header-anchor" href="#1-如何使用3d">¶</a>1.如何使用<code>3d</code></h4><p><code>transform</code>的<code>translate</code>,<code>scale</code>,<code>rotate</code>都有<code>3D</code>效果。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td>定义 3D 转化。</td></tr><tr><td>translateX(<em>x</em>)</td><td>定义 3D 转化，仅使用用于 X 轴的值。</td></tr><tr><td>translateY(<em>y</em>)</td><td>定义 3D 转化，仅使用用于 Y 轴的值。</td></tr><tr><td>translateZ(<em>z</em>)</td><td>定义 3D 转化，仅使用用于 Z 轴的值。</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td>定义 3D 缩放转换。</td></tr><tr><td>scaleX(<em>x</em>)</td><td>定义 3D 缩放转换，通过给定一个 X 轴的值。</td></tr><tr><td>scaleY(<em>y</em>)</td><td>定义 3D 缩放转换，通过给定一个 Y 轴的值。</td></tr><tr><td>scaleZ(<em>z</em>)</td><td>定义 3D 缩放转换，通过给定一个 Z 轴的值。</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td><td>定义 3D 旋转。</td></tr><tr><td>rotateX(<em>angle</em>)</td><td>定义沿 X 轴的 3D 旋转。</td></tr><tr><td>rotateY(<em>angle</em>)</td><td>定义沿 Y 轴的 3D 旋转。</td></tr><tr><td>rotateZ(<em>angle</em>)</td><td>定义沿 Z 轴的 3D 旋转。</td></tr></tbody></table><p>也可以用</p><table><thead><tr><th>属性</th><th>定义</th></tr></thead><tbody><tr><td>matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>, <em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td><td>定义 3D 转换，使用 16 个值的 4x4 矩阵。</td></tr></tbody></table><p>下面是3D变换的例子</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/x1nes/se45nykp/9//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>上面可以看出来，<code>div</code>脱离了平面，但是效果却仿佛还是平面的，因为我们缺少定义了一个关键的属性：</p><p>🏷<code>persspective</code>给元素加上<code>3D</code>透视(近大远小)的效果。</p><pre><code class="language-css">transform: perspective( 600px );// 加在子元素上，给单个元素添加透视/**或者**/perspective: 600px;// 加在父元素上，所有的子元素共享一个3D空间</code></pre><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/x1nes/oy0rwgh7/32//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>看上面的例子，我们可以看出，给单个元素添加，每个元素都有自己的透视空间。</p><p>🏷<code>perspective-orgin</code>默认的变换点都是元素的中心点，如果你想以其他的位置为变换点，那就可以用这个属性来做调整。</p><p>就像<code>transform-origin</code>在2D变换里面设置变换中心点一样。也可以认为是元素的底部位置。</p><p>🏷<code>transform-style</code>这个参数用来共享父元素的3D空间。</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">flat</td><td style="text-align:left">表示所有子元素在2D平面呈现。</td></tr><tr><td style="text-align:left">preserve-3d</td><td style="text-align:left">表示所有子元素在3D空间中呈现。</td></tr></tbody></table><p>🏷<code>backface-visibility</code>可用于隐藏内容的背面。默认情况下，背面可见，这意味着即使在翻转后，变换的内容仍然可见。但当 backface-visibility 设置为 hidden 时，旋转后内容将隐藏，因为旋转后正面将不再可见。</p><h4 id="2-3d和硬件加速"><a class="header-anchor" href="#2-3d和硬件加速">¶</a>2.<code>3d</code>和硬件加速</h4><p>动画卡顿是在移动web开发时经常遇到的问题，解决这个问题一般会用到<strong>css3硬件加速</strong>。</p><p>❔什么是硬件加速？</p><p>DOM树和CSS结合后形成渲染树。渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理。GPU中transform是不会触发 repaint 的，这一点非常类似3D绘图功能，最终这些使用 transform的图层都会由[独立的合成器进程进行处理]。<a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="noopener">https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p><p>因此，最简单的开启硬件加速的方法就是设置<code>translateZ(0)</code>。</p><p>但是，开启硬件加速后，会加快用电，并且不合适的使用硬件加速，会造成页面卡顿。</p><p>参考：<a href="https://div.io/topic/1348" target="_blank" rel="noopener">https://div.io/topic/1348</a> 看下<code>index</code>属性造成不该在复合层（composited layer）中的元素造成页面卡顿的例子。</p><h4 id="3-3d动画的一个实例"><a class="header-anchor" href="#3-3d动画的一个实例">¶</a>3. <code>3d</code>动画的一个实例</h4><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/x1nes/tj1of0m5//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>利用<code>translate</code> 和 <code>rotate</code> 制作的一个骰子。</p><p>代码来源：</p><p><a href="https://www.cnblogs.com/zhangnan35/p/10709876.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangnan35/p/10709876.html</a></p><p>参考：</p><p><a href="https://www.jianshu.com/p/f8b1d6e598db" target="_blank" rel="noopener">https://www.jianshu.com/p/f8b1d6e598db</a></p><p><a href="http://beiyuu.com/css3-animation" target="_blank" rel="noopener">http://beiyuu.com/css3-animation</a></p><p><a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="noopener">https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用一段时间react的总结</title>
      <link href="/blog/posts/1b7d8e2e/"/>
      <url>/blog/posts/1b7d8e2e/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近比较忙，先列下大纲，然后在逐渐补充</p></blockquote><h1>组件的几种常见形式</h1><h2 id="组合还是继承"><a class="header-anchor" href="#组合还是继承">¶</a>组合还是继承</h2><h2 id="state还是props"><a class="header-anchor" href="#state还是props">¶</a>state还是props</h2><h2 id="如何减少props传递的层级"><a class="header-anchor" href="#如何减少props传递的层级">¶</a>如何减少<code>props</code>传递的层级</h2><h2 id="受控组件和非受控组件"><a class="header-anchor" href="#受控组件和非受控组件">¶</a>受控组件和非受控组件</h2><h1>组件的生命周期</h1><h2 id="总览"><a class="header-anchor" href="#总览">¶</a>总览</h2><h2 id="react-17-新的生命周期和带来的影响"><a class="header-anchor" href="#react-17-新的生命周期和带来的影响">¶</a>react 17 新的生命周期和带来的影响</h2><h1>ref转发</h1><h1>render props</h1><h1>高阶组件的用法</h1><h1>pureComponent 和 不可变数据</h1><h1>好用的配套npm库</h1><h2 id="classnamse"><a class="header-anchor" href="#classnamse">¶</a>classnamse</h2>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器的简单实现（下）</title>
      <link href="/blog/posts/72b1723d/"/>
      <url>/blog/posts/72b1723d/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上文介绍了装饰模式，装饰器语法，今天继续说一下怎么用javascript实现自定义装饰器。</p></blockquote><h3 id="启用装饰器语法"><a class="header-anchor" href="#启用装饰器语法">¶</a>启用装饰器语法</h3><p>目前<code>decorator</code>语法只是题案，想要使用装饰器，需要安装<code>babel</code>和<code>webpack</code>并结合<code>babel/plugin-proposal-decorators</code> 插件。</p><p>关于如何配置请参考<code>babel</code>插件的配置文档。</p><p>或者你也可以直接到 <a href="https://babeljs.io/repl/" target="_blank" rel="noopener">https://babeljs.io/repl/</a> 这个地址编写代码，它提供了一个在线的<code>repl</code>环境，可以直接运行<code>es6</code>代码,记得勾选左侧的<code>Experimental</code>来启用装饰器语法。</p><p>🔑 <code>es2015</code>,<code>es2016</code>,<code>es2017</code>和<code>es6</code>之间的关系：</p><blockquote><p>ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。</p></blockquote><h3 id="类装饰器-方法装饰器和属性装饰器"><a class="header-anchor" href="#类装饰器-方法装饰器和属性装饰器">¶</a>类装饰器，方法装饰器和属性装饰器</h3><h5 id="类装饰器"><a class="header-anchor" href="#类装饰器">¶</a>类装饰器</h5><p>类装饰器就是用来修改类的行为，它标注在类定义的上方。</p><pre><code class="language-javascript">@testableclass MyTestableClass {  // ...}function testable(target) { // target 就是被装饰的类  target.isTestable = true;}MyTestableClass.isTestable // true</code></pre><p>这是一个简单的类装饰器，它给被装饰的类添加了一个<code>isTestable</code>的静态属性。</p><p>上面是个简单的例子，下面来个稍微复杂的。<br>想一下，如果我们想给装饰器传参数，要怎么做？熟悉高阶函数的同学一定会立刻想到，函数可以返回函数，只要在装饰器函数外面再加一层函数就可以了。</p><pre><code class="language-javascript">function testable(isTrue) {return function(target) {target.isTestable = isTrue}}@testable(false)class MyTestableClass {}MyTestableClass.isTestable  // false</code></pre><p>上面是给类添加静态属性，如果想给实例添加属性，需要把属性添加在<code>prototype</code>上</p><pre><code class="language-javascript">function testable(isTrue) {return function(target) {target.prototype.isTestable = isTrue}}</code></pre><p>🔑 修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p><p>接下来来个稍微复杂一点的例子，用装饰器实现<code>mixin</code>,<br>🔑 mixin模式就是一些提供能够被一个或者一组子类简单继承功能的类,意在重用其功能。</p><pre><code class="language-javascript">function mixin(foo) {return function(target){Object.assign(target.prototype,foo) // Onject.assign 是es6里面的Object的新函数，用来把第二个参数的属性合并到第一个参数上 因为这里传入的是类（也就是构造函数），想要在实例上添加属性，需要合并到原型对象上。}}const Foo = {sayHi(){console.log('hi')}}@mixin(Foo)class Target{}new Target().sayHi()// Hi</code></pre><p>有了装饰器，之前那些烦人的样板函数就可以用装饰器代替了，比如我们用<code>redux</code>和<code>react</code>时，需要把<code>ui</code>组件和逻辑组件合并，经常需要写下面的代码：</p><pre><code class="language-javascript">class MyReactComponent extends React.Component {}export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</code></pre><p>有了装饰器，就可以改写上面的代码。</p><pre><code class="language-javascript">@connect(mapStateToProps, mapDispatchToProps)export default class MyReactComponent extends React.Component {}</code></pre><h5 id="方法和属性的装饰"><a class="header-anchor" href="#方法和属性的装饰">¶</a>方法和属性的装饰</h5><p>上面的装饰器定义函数我们只用到了一个参数，实际上，在装饰类的属性/方法时他有三个函数。</p><pre><code class="language-javascript">/*** target 被装饰的类的原型对象,需要注意，装饰class和class的属性，第一个参数是不一样的，装饰class时，是构造函数，也就是类本身* key 要修饰的属性名* descriptor 该属性的描述对象*/function decorator(target,key,descriptor){}</code></pre><p>🔑 关于描述对象，不熟悉的可以去看<code>js高级程序设计</code>关于 <code>defineProperty</code> 和 <code>defineProperties</code>的介绍，这两个方法就是用来定义和修改对象的内部属性。<br>举一个常见的例子，在每次函数执行前后，把函数的参数和结果打印出来</p><pre><code class="language-javascript">function log(target,key,descriptor) {var old = descriptor.valuedescriptor.value = function(...args) {console.log(`call ${key} with,`,...args)const result = old.call(this,...args)console.log(`result is ${result}`)return result}return descriptor}class Util {@logadd(a,b) {return a + b}}const util = new Util()util.add(1,2)// 这时，控制台会打印出日志// call add with, 1 2// result is 3</code></pre><p>来一个可缓存的装饰器</p><pre><code class="language-javascript">function cacheable(target,key,descriptor) {const old = descriptor.valueif( typeof old !== 'function' ) {throw new Error(&quot;must be a function&quot;)}const cache = {}descriptor.value = function(...args) {const key = JSON.stringify(args)if(cache[key]) {return cache[key]} else {cache[key] = old.call(this,...args)return cache[key]}}return descriptor}class Util {@cacheableadd(a,b) {console.log(&quot;add&quot;,a,b)return a + b}}const util = new Util()util.add(1,2)util.add(1,2)util.add(1,2)// 只有第一次运行会打印出 add 1 2</code></pre><p>同样的，我们也可以实现属性上的装饰器，比如实现一个类似<code>java</code>包装类</p><pre><code class="language-javascript">class Integer{constructor(num){this.value = num}display() {console.log(`this is a boxing value , the value is ${this.value}`)}}function boxing(target,key,descriptor) {    let v = descriptor.initializer &amp;&amp; descriptor.initializer.call(this);    v= new Integer(v)return {        enumerable: true,            configurable: true,            get: function() {                return v;            },            set: function(c) {                v = new Integer(c);            }    }} class Number {@boxinga=2}let number = new Number()number.a.display()// this is a boxing value , the value is 2number.a = 4number.a.display()// this is a boxing value , the value is 4</code></pre><p>这样，我们就实现了一个简单的包装<code>Integer</code>。</p><p>如果我们每次赋值的时候，都希望检查一下数据类型，可以这样做</p><pre><code class="language-javascript">function check(type) {return function(target,key,descriptor) {let v = descriptor.initializer &amp;&amp; descriptor.initializer.call(this)return {        enumerable: true,            configurable: true,            get: function() {                return v;            },            set: function(c) {if(typeof c !== type) {throw new Error(&quot;error type&quot;)}v = c}        }    }}</code></pre><h3 id="第三方库"><a class="header-anchor" href="#第三方库">¶</a>第三方库</h3><p><code>core-decorators.js</code>是一个第三方模块，提供了一些常见的装饰器<br>比如：</p><pre><code class="language-javascript">// @autobindimport { autobind } from 'core-decorators';class Person {  @autobind  getPerson() {    return this;  }}let person = new Person();let getPerson = person.getPerson;getPerson() === person;// true// @readonlyimport { readonly } from 'core-decorators';class Meal {  @readonly  entree = 'steak';}var dinner = new Meal();dinner.entree = 'salmon';// Cannot assign to read only property 'entree' of [object Object]</code></pre><p>还有更多不再阐述。</p><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>上文只是简单对装饰器模式做了基本原理的解释和简单demo，具体在实战中如何应用，还需要很多其他的经验，比如多个装饰器嵌套如何使用，如何利用<code>proxy</code>实现装饰器，在上文中都没提及，在接下来的博文里，会完整的实现一个具有实际意义的装饰器例子。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器的简单实现（上）</title>
      <link href="/blog/posts/72b172aa/"/>
      <url>/blog/posts/72b172aa/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>es7</code>为<code>javascript</code>添加了激动人心的新特性----装饰器，不过<code>Typrscript</code>早就支持了装饰器了，装饰器也不是<code>ts</code>特有的语法，实际上<code>python</code>也有装饰器，在<code>oop</code>语言里面，一直都有装饰器模式，也称为<code>decorator</code>，不过都是从语言层面，通过继承和组合实现，现在，我们可以通过语法层面直接实现装饰器了。</p></blockquote><h3 id="什么是装饰器模式"><a class="header-anchor" href="#什么是装饰器模式">¶</a>什么是装饰器模式</h3><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p><code>java</code>里面的装饰器模式:</p><p>参考这个地址：<a href="https://github.com/iluwatar/java-design-patterns/tree/master/decorator" target="_blank" rel="noopener"><strong>decorator</strong></a></p><p>🔼上面的地址是<code>github</code>上一个很有名的各种设计模式的<code>java</code>实现。</p><blockquote><p>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p></blockquote><p>也就是说：动态的将附加职责添加到对象上。装饰器模式为子类化提供了灵活的代替和扩展的功能。</p><p>举个例子：</p><p>我们小时候都打过<code>cs</code>，每个警察或者劫匪都可以拿一把武器，或者是<code>AK47</code>，或者是<code>m16</code>，为了更换武器，我们没必要去创造新的角色实例，可以用装饰器动态的用武器装饰他。</p><pre><code class="language-java">// 创建一个角色接口public interface Person {  void attack();  int getAttackPower();}public class Police implements Person {    void attack(){        Systom.out.print(&quot;I'm attacking you&quot;);    }    int getAttackPower(){        return 5; // 战斗力只有5的渣渣    }}public class AkPolice implements Person {    // 提供构造函数来对目标进行包装    public AkPolice(Police decorted) {        this.decorted = decorted;     }    void attack(){        this.decorted.attack()        Systom.out.print(&quot;I'm attacking with a Ak!!&quot;);//awesome!    }    int getAttackPower(){        return this.decorted.getAttackPower()+100;    }}</code></pre><p>🔼就像上面的简单例子，一个包装类把基本类<code>warped</code>起来，形成了一个新的类，新的类不仅添加了新的动作，还保留了基本类的动作。</p><p>优点：</p><p>👍 装饰模式与继承关系的目的都是要拓展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者“除掉”一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</p><p>👍 通过不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出更多不同行为的组合。</p><p>缺点：</p><p>👎种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</p><p>装饰器语法最常见的应用就是我们熟悉的<code>java</code>里面的<code>AOP</code>(面向切面)编程，在不影响原有功能的情况下，增加新的处理逻辑，比如添加各种<code>filter</code>,这些<code>filter</code>就像洋葱一样层层包裹，最终执行原有的逻辑，但是在之前和之后，都可以随意添加新的行为，因此，特别适合安全检查，缓存，调试，日志记录等等行为。</p><h3 id="装饰器语法"><a class="header-anchor" href="#装饰器语法">¶</a>装饰器语法</h3><p>第一次看到装饰器语法是在使用<code>python</code>的时候，现在<code>es7</code>也实现了装饰器语法。</p><p>首次看到装饰器语法，用过<code>java</code>注解的也许会混到一起，其实这两个东西除了长得像外，原理完全不一样。</p><blockquote><p>Python decorators were inspired in part by Java annotations, and have a similar syntax</p><p>​                                                                                                                      --wikipedia</p></blockquote><p>根据<code>wikipedia</code>的说法，装饰器语法的灵感来源于<code>java</code>的注解，所以他们有类似的语法。</p><p>注解是利用反射，它本身不改变被注解对象的行为和性质，只有理解这些注解的处理器才会改变行为，在运行的时候起作用。</p><p>装饰器实际上是语法糖，利于了<code>python</code>,<code>javascript</code>函数可以赋值，传参的特性，函数是第一公民，函数是对象、是变量，可以作为参数、可以是返回值，对嵌套函数做了简化。</p><p>😋引申：如果想了解更多关于<code>javascript</code>函数式特性的知识，可以看下面⬇️</p><p>[<a href="https://www.bookstack.cn/books/mostly-adequate-guide-chinese" target="_blank" rel="noopener">JS 函数式编程指南中文版</a> ](<a href="https://www.bookstack.cn/read/mostly-adequate-guide-chinese/README.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/mostly-adequate-guide-chinese/README.md</a>)</p><p>相信看完，你会对<code>javascript</code>有新的认识。</p><p>下面重头戏来了，到底在<code>javascript</code>里，怎么实现自己的装饰器呢？</p><p>关键的<code>api</code>是<code>Object.defineProperty</code>。</p><pre><code class="language-javascript">Object.defineProperty(obj, prop, descriptor)</code></pre><p>参数：</p><p><strong>obj</strong> 要在其上定义属性的对象</p><p><strong>prop</strong> 要定义或修改的属性的名称。</p><p><strong>descriptor</strong> 将被定义或修改的属性描述符。</p><p>装饰器可以用到<code>类</code>，属性和类的<code>方法</code>上，不能用于<code>function</code>❔<a href="http://es6.ruanyifeng.com/#docs/decorator#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BF%AE%E9%A5%B0%E5%99%A8%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%EF%BC%9F" target="_blank" rel="noopener">为什么修饰器不能用于函数？</a></p><p>👍想详细了解装饰器语法，可以去看阮一峰老师的<code>es6</code>教程</p><p><a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">修饰器</a></p><p>下篇博文，我会用实例代码实现不同的装饰器（等我看完上面的教程先😄)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Performance--一个用来获取页面性能的接口</title>
      <link href="/blog/posts/94e1353c/"/>
      <url>/blog/posts/94e1353c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近被问到一个问题，如何判断页面加载时间，我第一时间想到的是打开<code>devtool</code>看下<code>Network</code>下面</p><p><code>DOMContentLoaded</code>和<code>load</code>分别用了多久，如果自己写的话，要用到<code>window.onload</code>函数，但是实际上，web已经给出了<code>api</code>，获取页面性能，并且大部分现代浏览器也支持这个<code>api</code>.</p></blockquote><h3 id="performance简介"><a class="header-anchor" href="#performance简介">¶</a><strong>Performance</strong>简介</h3><p>根据<code>mdn</code>里面的说法:</p><blockquote><p><strong>Performance</strong> 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API" target="_blank" rel="noopener">Navigation Timing API</a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API" target="_blank" rel="noopener">User Timing API</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API" target="_blank" rel="noopener">Resource Timing API</a>。</p></blockquote><p>并且，这些数据是只读的。</p><p><code>preformance</code>对象有三个标准属性，和一个<code>chrome</code>添加的非标准库–<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/memory" target="_blank" rel="noopener"><code>performance.memory</code></a>，用来获取到基本内存的使用情况，一般来说不要用这个非标准的<code>api</code>。</p><p>👎<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/navigation" target="_blank" rel="noopener"><code>Performance.navigation</code></a> [只读]</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceNavigation" target="_blank" rel="noopener"><code>PerformanceNavigation</code></a> 对象提供了在指定的时间段里发生的操作相关信息，包括页面是加载还是刷新、发生了多少次重定向等等。Not available in workers.</p><p>👎<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/timing" target="_blank" rel="noopener"><code>Performance.timing</code></a> [只读]</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming" target="_blank" rel="noopener"><code>PerformanceTiming</code></a> 对象包含延迟相关的性能信息。Not available in workers.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/memory" target="_blank" rel="noopener"><code>performance.memory</code></a></p><p>其是 Chrome 添加的一个非标准扩展，这个属性提供了一个可以获取到基本内存使用情况的对象。<strong>不应该</strong>使用这个非标准的 API。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/timeOrigin" target="_blank" rel="noopener"><code>Performance.timeOrigin</code></a> [只读]</p><p>返回性能测量开始时的时间的高精度时间戳。</p><p>关于更精确的资料请查看<code>mdn</code>官方文档。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">Performance</a></p><h3 id="如何根据performance-timing获取加载时间"><a class="header-anchor" href="#如何根据performance-timing获取加载时间">¶</a>如何根据<code>Performance.timing</code>获取加载时间</h3><p>在此之前，读者需要明白一点浏览器工作的基本流程和原理，比如经常在面试时被问到的“从url输入到页面加载经过了什么流程？”</p><p>这里有几篇非常详细的文章（最起码是我遇到的最详细的，如果你看到过更详细的，或者还有其他补充，请在下方留言，万分感谢😙 ），介绍了这个流程。</p><p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">从输入URL到页面加载发生了什么</a><br><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p><p>也就是说，你最起码要知道<code>dns</code>解析，<code>http</code>请求，页面渲染等认识。</p><p><code>timing</code>就是从输入<code>url</code>到页面展示的全过程的时间统计，单位是毫秒，只读。</p><p>➕ 属性：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/navigationStart" target="_blank" rel="noopener"><code>PerformanceTiming.navigationStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了从同一个浏览器上下文的上一个文档卸载(unload)结束时的UNIX时间戳。如果没有上一个文档，这个值会和PerformanceTiming.fetchStart相同。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/unloadEventStart" target="_blank" rel="noopener"><code>PerformanceTiming.unloadEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了<code>unload</code>事件抛出时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/unloadEventEnd" target="_blank" rel="noopener"><code>PerformanceTiming.unloadEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了<code>unload</code>事件处理完成时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/redirectStart" target="_blank" rel="noopener"><code>PerformanceTiming.redirectStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了第一个HTTP重定向开始时的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/redirectEnd" target="_blank" rel="noopener"><code>PerformanceTiming.redirectEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/fetchStart" target="_blank" rel="noopener"><code>PerformanceTiming.fetchStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了浏览器准备好使用HTTP请求来获取(fetch)文档的UNIX时间戳。这个时间点会在检查任何应用缓存之前。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domainLookupStart" target="_blank" rel="noopener"><code>PerformanceTiming.domainLookupStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了域名查询开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 <code>PerformanceTiming.fetchStart一致。</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domainLookupEnd" target="_blank" rel="noopener"><code>PerformanceTiming.domainLookupEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了域名查询结束的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 <code>PerformanceTiming.fetchStart一致。</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/connectStart" target="_blank" rel="noopener"><code>PerformanceTiming.connectStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/connectEnd" target="_blank" rel="noopener"><code>PerformanceTiming.connectEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/secureConnectionStart" target="_blank" rel="noopener"><code>PerformanceTiming.secureConnectionStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/requestStart" target="_blank" rel="noopener"><code>PerformanceTiming.requestStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/responseStart" target="_blank" rel="noopener"><code>PerformanceTiming.responseStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/responseEnd" target="_blank" rel="noopener"><code>PerformanceTiming.responseEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domLoading" target="_blank" rel="noopener"><code>PerformanceTiming.domLoading</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前网页DOM结构开始解析时（即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState" target="_blank" rel="noopener"><code>Document.readyState</code></a>属性变为“loading”、相应的 <code>readystatechange</code>事件触发时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domInteractive" target="_blank" rel="noopener"><code>PerformanceTiming.domInteractive</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前网页DOM结构结束解析、开始加载内嵌资源时（即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState" target="_blank" rel="noopener"><code>Document.readyState</code></a>属性变为“interactive”、相应的<code>readystatechange</code>事件触发时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domContentLoadedEventStart" target="_blank" rel="noopener"><code>PerformanceTiming.domContentLoadedEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当解析器发送<code>DOMContentLoaded</code> 事件，即所有需要被执行的脚本已经被解析时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domContentLoadedEventEnd" target="_blank" rel="noopener"><code>PerformanceTiming.domContentLoadedEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当所有需要立即执行的脚本已经被执行（不论执行顺序）时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domComplete" target="_blank" rel="noopener"><code>PerformanceTiming.domComplete</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前文档解析完成，即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState" target="_blank" rel="noopener"><code>Document.readyState</code></a> 变为 <code>'complete'且相对应的``readystatechange</code> 被触发时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/loadEventStart" target="_blank" rel="noopener"><code>PerformanceTiming.loadEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回该文档下，<code>load</code>事件被发送时的Unix毫秒时间戳。如果这个事件还未被发送，它的值将会是0。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/loadEventEnd" target="_blank" rel="noopener"><code>PerformanceTiming.loadEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当<code>load</code>事件结束，即加载事件完成时的Unix毫秒时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0.</p><p>🔼 以上属性来自<code>mdn</code>文档。</p><p>根据上面的定义，可以得出下面的常用的时间计算公式：</p><p><strong>常用计算：</strong><br><code>DNS</code>查询耗时 ：<code>domainLookupEnd</code> - <code>domainLookupStart</code><br><code>TCP</code>链接耗时 ：<code>connectEnd</code> -<code>connectStart</code><br><code>request</code>请求耗时 ：<code>responseEnd</code> - <code>responseStart</code><br>解析<code>dom</code>树耗时 ： <code>domComplete</code> - <code>domInteractive</code><br>白屏时间 ：<code>responseStart</code> -<code>navigationStart</code><br><code>domready</code>时间(用户可操作时间节点) ：<code>domContentLoadedEventEnd</code> -<code>navigationStart</code><br><code>onload</code>时间(总下载时间) ：<code>loadEventEnd</code> - <code>navigationStart</code></p><h4 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h4><p>[<a href="https://www.cnblogs.com/bldxh/p/6857324.html" target="_blank" rel="noopener">Performance — 前端性能监控利器</a>](<a href="https://www.cnblogs.com/bldxh/p/6857324.html" target="_blank" rel="noopener">https://www.cnblogs.com/bldxh/p/6857324.html</a>)</p><p><a href="https://w3c.github.io/navigation-timing/#introduction" target="_blank" rel="noopener">w3c文档(<a href="https://w3c.github.io/navigation-timing/#introduction" target="_blank" rel="noopener">https://w3c.github.io/navigation-timing/#introduction</a>)</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming" target="_blank" rel="noopener">mdn文档(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming</a>)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加法模拟器</title>
      <link href="/blog/posts/909f226/"/>
      <url>/blog/posts/909f226/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不用 “+” 怎么实现加法呢？相信大家看到第一时间就会想到用位运算，特别是计算机基础好的同学，立马想到计算机本质不就是2进制做位运算实现计算的吗？</p></blockquote><h3 id="先复习下位运算"><a class="header-anchor" href="#先复习下位运算">¶</a>先复习下位运算</h3><p>与运算<code>&amp;</code><br><code>2&amp;3</code><br>2的2进制是<code>10</code><br>3的2进制是<code>11</code><br>所以就是<code>10</code>和<code>11</code>做与运算,只有双方都是<code>true</code>的时候，结果才为<code>true</code>。</p><p>注意：如果是负数，需要计算补码来做位运算，正数的补码和本身相等。比如<code>-1</code></p><p>源码 1000 0001</p><p>反码 1111 1110</p><p>补码 1111 1111</p><table><thead><tr><th>与运算</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>true</td><td>true</td><td>false</td></tr><tr><td>false</td><td>false</td><td>false</td></tr></tbody></table><table><thead><tr><th>或运算</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>true</td><td>true</td><td>true</td></tr><tr><td>false</td><td>true</td><td>false</td></tr></tbody></table><table><thead><tr><th>异或运算</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>true</td><td>false</td><td>true</td></tr><tr><td>false</td><td>true</td><td>false</td></tr></tbody></table><h3 id="异或和与运算"><a class="header-anchor" href="#异或和与运算">¶</a>异或和与运算</h3><p>异或</p><pre><code class="language-python">a = 10   # 1010b = 5    # 0101a^b = 15 # 1111c = 10    #1010d = 6     #0110c^b = 12  #1100</code></pre><p>与</p><pre><code class="language-python">a = 10  # 1010b = 5   # 0101a&amp;b = 0 # 0000c = 10   #1010d = 6    #0110c&amp;b = 2  #0010</code></pre><p>看出点眉目没有？<br>异或，得到的是两个数没进位的和；而与。得到的是需要进位的位置（这里的位置并不是一一对应，需要向左移动一位，）</p><p>算法</p><pre><code class="language-python">def add(a,b):    res = 0    while b != 0:        res = a^b        b = (a&amp;b)&lt;&lt;1        a = res        print(bin(a)[2:],bin(b)[2:])    return a  # 计算 10 加 6    add(10,6)#output 1100     100 1000    1000    0   1000010000       0# 结果16</code></pre><p>原理<br>a，b先用异或获取不进位的结果，在用与运算获取进位，这个称为进位补偿，然后把这两个结果相加就是a+b了，<br>但是不然用加法啊，怎么办呢？ 可以把前面的流程再走一次，直到进位补偿为0，这时候，上个异或结果就是最终相加的结果了。</p><p>根据上面的原理<br>1.a + b 的问题拆分为 (a 和 b 的无进位结果) + (a 和 b 的进位结果)<br>2.无进位加法使用异或运算计算得出<br>3.进位结果使用与运算和移位运算计算得出<br>4.循环此过程，直到进位为 0</p><p>用一个公式就是</p><pre><code class="language-python">a + b = a^b + (a&amp;b)&lt;&lt;1</code></pre><p>不过其实还有更简单的方法,毕竟<br><strong>人生苦短，我选python</strong></p><pre><code class="language-python">def add(self, a, b):    return sum([a, b])</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout和setInterval的区别</title>
      <link href="/blog/posts/64e435bc/"/>
      <url>/blog/posts/64e435bc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们再前端开发中需要实现定时任务或者<code>js</code>动画，都要用到<code>setTimeout</code>和<code>setInterval</code>z这两个函数，但是对于他们的原理，如果不清楚，往往会造成一些意想不到的问题。</p></blockquote><h3 id="settimeout"><a class="header-anchor" href="#settimeout">¶</a><code>setTimeout</code></h3><p><code>setTimeout</code>方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码。</p><p>语法</p><pre><code class="language-javascript">var id = setTimeout(function[,delay,param1...])var id = setTimeout(function[,delay])var id = setTimeout(code[,delay])</code></pre><h4 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h4><p><code>function</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/function" target="_blank" rel="noopener"><code>function</code></a> 是你想要在到期时间(<code>delay</code>毫秒)之后执行的<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noopener">函数</a>。</p><p><code>code</code></p><p>这是一个可选语法，你可以使用字符串而不是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/function" target="_blank" rel="noopener"><code>function</code></a> ，在<code>delay</code>毫秒之后编译和执行字符串 (使用该语法是<strong>不推荐的,</strong> 原因和使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener"><code>eval()</code></a>一样，有安全风险)。</p><p><code>delay</code>可选</p><p>延迟的毫秒数 (一秒等于1000毫秒)，函数的调用会在该延迟之后发生。如果省略该参数，delay取默认值0，意味着“马上”执行，或者尽快执行。不管是哪种情况，实际的延迟时间可能会比期待的(delay毫秒数) 值长，原因请查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout#Reasons_for_delays_longer_than_specified" target="_blank" rel="noopener">Reasons for delays longer than specified</a>。</p><p><code>param1, ..., paramN</code> 可选</p><p>附加参数，一旦定时器到期，它们会作为参数传递给<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/function" target="_blank" rel="noopener"><code>function</code></a></p><h4 id="返回值"><a class="header-anchor" href="#返回值">¶</a>返回值</h4><p>返回值<code>timeoutID</code>是一个正整数，表示定时器的编号。这个值可以传递给<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/clearTimeout" target="_blank" rel="noopener"><code>clearTimeout()</code></a>来取消该定时器。</p><h4 id="用途"><a class="header-anchor" href="#用途">¶</a>用途</h4><p>举个例子，三秒后跳转新页面</p><pre><code class="language-javascript">setTimeout(function() {    location.href = &quot;url&quot;},3000)</code></pre><p>在函数执行前取消</p><pre><code class="language-javascript">var key;function myFunction() {    key = setTimeout(function(){ console.log(&quot;fn&quot;) }, 3000);}function myStopFunction() {    clearTimeout(key);}</code></pre><p>如果你只是掌握了上面的用法，不了解它的原理，就会犯一些错误</p><p>比如一个常见的面试题</p><pre><code class="language-javas">for (var i = 1;i &lt;= 5;i ++) {  setTimeout(function timer() {      console.log(i)  },i * 1000)}</code></pre><p>问打印出来的是什么？</p><p>如果对闭包和作用域不了解的同学会以为是每隔一秒就输出1,2,3,4,5。但实际上是每隔一秒输出了6。</p><p>原因就是作用域，在<code>javascript</code>里面没有块作用域，因此，当<code>setTimeout</code>里面的函数执行的时候，所有的i都是<code>for</code>循环里面的<code>i</code>，此时，<code>i</code>是6。</p><p>另外，说到<code>setTimeout</code>就一定要说一下事件循环，这个概念比较复杂，下面简单说一下，</p><p><code>setTimeout</code>运行后，会把第一个参数的函数在第二个参数设置的时间之后，将其放入异步队列里面，然后等到主线程函数栈为空，在执行这个函数。</p><p>这里有个需要注意的地方，</p><blockquote><p>HTML5 标准规定了<code>setTimeout()</code>的第二个参数的最小值，即最短间隔，不得低于4毫秒。如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。</p></blockquote><p>这意味着，即使你把第二个参数设置为0，也要最少等个4ms才能进入异步队列。另外，就算进入异步队列,也要等队列里面其他未执行的函数执行完，因此，可不要以为只要设置一个时间，就一定可以准时执行这个函数。</p><p>那么，怎么让上面的代码打印出0,1,2,3,4,5呢？</p><p>可以用下面的方法。</p><p>1.<code>es6</code>的<code>let</code>关键词</p><p><code>let</code>是<code>es6</code>的块作用域的声明关键词。</p><pre><code class="language-javascript">for(let i = 0;i&lt;5;i++) {  setTimeout(function timer(){    console.log(i);  }, i * 1000);}</code></pre><p>2.利用闭包</p><pre><code class="language-javascript">for(var i = 0;i&lt;5;i ++) {  (function(i){    setTimeout(function timer() {      console.log(i)    }, i * 1000);  })(i);}</code></pre><p>3.利用第三个参数</p><pre><code class="language-javascript">for (var i=1; i&lt;=5; i++) {  setTimeout( function timer(i) {    console.log(i);       }, i*1000,i );}</code></pre><p>tips:</p><p><code>setTimeout</code>第一个参数函数里面的<code>this</code>是<code>window</code>。</p><p>###　setInterval</p><p><strong>setInterval()</strong> 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间延迟。</p><p>语法</p><pre><code class="language-javascript">let intervalID = window.setInterval(func, delay[, param1, param2, ...]);let intervalID = window.setInterval(code, delay);</code></pre><p>参数</p><ul><li><code>intervalID</code> 是此重复操作的唯一辨识符，可以作为参数传给<code>clearInterval``()</code>。</li><li><code>func</code> 是你想要重复调用的函数。</li><li><code>code</code> 是另一种语法的应用，是指你想要重复执行的一段字符串构成的代码(使用该语法是<strong>不推荐</strong>的，不推荐的原因和<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/eval#Don't_use_eval!" target="_blank" rel="noopener">eval()</a>一样)。</li><li><code>delay</code> 是每次延迟的毫秒数 (一秒等于1000毫秒)，函数的每次调用会在该延迟之后发生。和<a href="https://developer.mozilla.org/en-US/docs/DOM/window.setTimeout#Minimum_delay_and_timeout_nesting" target="_blank" rel="noopener">setTimeout</a>一样，实际的延迟时间可能会稍长一点。</li></ul><p>返回值</p><p>返回一个 intervalID。可以用clearInterval函数来取消定时任务。</p><p><strong>这里需要注意，于setTimeout返回的id公用一个id池</strong></p><p>通常，这个函数用来执行周期执行的函数，比如动画之类的效果。</p><p>mdn里面有个打字机效果的例子。</p><p><a href="https://mdn.mozillademos.org/files/3997/typewriter.html" target="_blank" rel="noopener">打字机效果</a></p><p>和<code>setTimeout</code>一样，也是加入到异步队列里，等待合适的时机运行。</p><blockquote><p>当使用<code>setInterval</code>时,仅当(在队列中)没有该定时器的任何其他代码实例时,才将定时器代码添加到队列中,引用JavaScript高级程序设计第三版书中语句</p></blockquote><p>(即：当前一个定时器代码执行时,紧跟后面的第一个定时器代码将添加到队列中,等待执行,再后面的定时器代码不会添加到队列中)</p><p>所以，如果你的函数（第一个参数）执行时间比较长，但是你的执行间隔时间设置的比较短，可不要以为可以精准的在预料的时间点会执行设置的函数。</p><p>此外，第二个参数也有一个最短的默认参数，在<code>chrome</code>里面是7ms。</p><p>当定时器代码执行时间超过指定间隔,那么某些定时器代码就会被跳过(即后面的定时器代码不会被添加到队列中),前一个定时器代码执行完毕后,队列中的定时器代码立刻执行,各定时器之间的代码执行没有间隔。这时，需要使用链式<code>setTimeout</code>。</p><pre><code class="language-javas">setTimeout(function(){    //要执行的代码     setTimeout(arguments.callee,2000);                   },2000);</code></pre><p>上面的代码就是用<code>setTimeout</code>来模拟<code>setInterval</code>,如果面试官问你怎么用<code>setTimeout</code>来解决定时器问题，可以用上面的代码来回答哦。</p><p>如果要求在每隔一个固定的时间间隔后就精确地执行某动作，那么最好使用<code>setInterval</code>，</p><p>比如函数执行的时间比较短的，用来实现动画效果。</p><p>如果每次函数的调用需要繁重的计算以及很长的处理时间，而且不希望他们之间互相干扰，那么最好使用<code>setTimeout</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐数</title>
      <link href="/blog/posts/9ba82001/"/>
      <url>/blog/posts/9ba82001/</url>
      
        <content type="html"><![CDATA[<blockquote><p>快乐就完事了。</p></blockquote><h3 id="快乐数是什么"><a class="header-anchor" href="#快乐数是什么">¶</a>快乐数是什么</h3><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><p>示例:</p><pre><code class="language-javascript">    输入: 19    输出: true    解释:     1^2 + 9^2 = 82    8^2 + 2^2 = 68    6^2 + 8^2 = 100    1^2 + 0^2 + 0^2 = 1</code></pre><h3 id="编写一个算法来判断一个数是不是-快乐数"><a class="header-anchor" href="#编写一个算法来判断一个数是不是-快乐数">¶</a>编写一个算法来判断一个数是不是“快乐数”。</h3><p>思路，不断的求输入数字每个位置平方和，然后看是否等于1，等于1就是快乐数，问题是，什么时候判断false。<br>答案就是出现无线循环的时候，也就是出现重复的数字，必定会进行下一次循环。</p><pre><code class="language-python">class Solution:    def isHappy(self, n: int) -&gt; bool:        already = set()                while n != 1:            nums = 0            while n &gt; 0:                temp = n % 10                nums = nums + temp * temp                n = n // 10            if nums in already:                return False            else:                already.add(nums)                n = nums        return True    </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的循环遍历方法</title>
      <link href="/blog/posts/8925371c/"/>
      <url>/blog/posts/8925371c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近稍微刷了一下<code>leetcode</code>，想巩固一下编程功底，但是发现工作后的很少用到在学校时用的数据结构，好多都忘了，在这里做下记录。</p></blockquote><h3 id="1-二叉树的前序-中序-后序遍历"><a class="header-anchor" href="#1-二叉树的前序-中序-后序遍历">¶</a>1.二叉树的前序，中序，后序遍历</h3><p>前序遍历方向是 中 左 右</p><p>中序遍历方向是 左 中 右</p><p>后序遍历方向是 右 左 中</p><p>根据上面的定义，看的出来对于左右节点，顺序是不变的，只是中间节点出现的位置改变。所以，这也是一个防止忘记的技巧。</p><h3 id="2-代码实现"><a class="header-anchor" href="#2-代码实现">¶</a>2.代码实现</h3><pre><code class="language-python"># 定义节点对象class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = None# 准备测试数据a = TreeNode(1)a.left = TreeNode(2)a.left.left = TreeNode(4)a.left.right = TreeNode(5)a.right = TreeNode(3)a.right.left = TreeNode(6)a.right.right = TreeNode(7)class Solution:    def inorderTraversal(self,root):        &quot;&quot;&quot;        递归实现中序遍历        &quot;&quot;&quot;        if not root:            return []        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)        def inerderTraversalLoop(self,root):        &quot;&quot;&quot;        循环实现中序遍历        &quot;&quot;&quot;        result = []        stack = []        curr = root        while curr or stack:            if curr:                stack.append(curr)                curr=curr.left            else:                curr = stack.pop()                result.append(curr.val)                curr = curr.right        return result                                        def predorderTraversal(self, root):        &quot;&quot;&quot;        递归实现前序遍历        &quot;&quot;&quot;        if not root:            return []        return [root.val] + self.predorderTraversal(root.left) + self.predorderTraversal(root.right)            def predorderTraversalLoop(self,root):        &quot;&quot;&quot;        循环实现前序遍历        &quot;&quot;&quot;        result = []        stack = []        curr = root        while curr or stack:            if curr:                result.append(curr.val)                stack.append(curr.right)                curr = curr.left            else:                curr = stack.pop()                        return result                                 def postorderTraversal(self,root):        &quot;&quot;&quot;        递归实现后续遍历        &quot;&quot;&quot;        if not root:            return []        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]            def postorderTraversalLoop(self,root):        &quot;&quot;&quot;        循环实现后续遍历        &quot;&quot;&quot;        result = []        stack = []        curr = root        while curr or stack:            if curr:               result.append(curr.val)               stack.append(curr.left)               curr = curr.right            else:               curr = stack.pop()        return result[::-1]                 if __name__ == &quot;__main__&quot;:    s = Solution()    print(s.inorderTraversal(a))    print(s.inerderTraversalLoop(a))    print(s.predorderTraversal(a))    print(s.predorderTraversalLoop(a))    print(s.postorderTraversal(a))    print(s.postorderTraversalLoop(a))# [4, 2, 5, 1, 6, 3, 7]# [4, 2, 5, 1, 6, 3, 7]# [1, 2, 4, 5, 3, 6, 7]# [1, 2, 4, 5, 3, 6, 7]# [4, 5, 2, 6, 7, 3, 1]# [4, 5, 2, 6, 7, 3, 1]   </code></pre><p>上面就是实现代码。</p><p>先说下递归实现，根据第一节的遍历顺序定义，这里很简单就可以写出递归程序，只是返回的时候，更改下中间节点的位置就好。</p><p>在说下循环实现，在<code>LeetCode</code>里面，循环都是<code>hard</code>和<code>middle</code>的题，可见，用循环实现起来并不容易。</p><p>主要是要在一个函数里面实现遍历到整个树形结构，如果你能想到用<strong>栈</strong>（<code>stack</code>）来存节点，那么你应该差不多对数据结构运用有一定经验了。</p><p>如下的二叉树</p><pre><code class="language-python">      1   2      34    5</code></pre><p>对于中序遍历</p><p>每次将当前结点<code>curr</code>的左子结点push到栈中，直到当前结点<code>curr</code>为None。这时，<code>pop</code>出栈顶的第一个元素，设其为当前结点，并输出该结点的<code>val</code>值，且开始遍历该结点的右子树。当<code>stack</code>和<code>curr</code>都为空的时候，结束循环。</p><p>对于前序遍历</p><p>输出当前结点<code>curr</code>的<code>val</code>，并将右子结点<code>push</code>到栈中，然后将左子结点设为当前结点。入栈和出栈条件（当前结点<code>curr</code>不为<code>None</code>时，每一次循环将当前结点<code>curr</code>入栈；当前结点<code>curr</code>为<code>None</code>时，则出栈一个结点）以及循环结束条件（整个循环在<code>stack</code>和<code>curr</code>皆为<code>None</code>的时候结束）与中序遍历一模一样。</p><p>对于后序遍历</p><p>后序遍历在<code>leetcode</code>上是<code>hard</code>难度的题，这里有个技巧，后序是左右中，我们按照中右左的方式遍历，然后反向输出就可以了。而且中右左不就是前序遍历左右互相换下吗？</p><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>二叉树的循环遍历，还是要借助于栈这个非常有用的数据结构，有时我们都明白，比如，栈啊，队列啊，这些结构有什么特性，但是，要真正灵活的使用这些数据结构，还需要多多练习。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布订阅模式的javascript实现</title>
      <link href="/blog/posts/4ec38d83/"/>
      <url>/blog/posts/4ec38d83/</url>
      
        <content type="html"><![CDATA[<h3 id="发布订阅模式"><a class="header-anchor" href="#发布订阅模式">¶</a>发布订阅模式</h3><p>在<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">软件架构</a>中，<strong>发布-订阅</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF" target="_blank" rel="noopener">消息</a><a href="https://zh.wikipedia.org/wiki/%E8%8C%83%E5%BC%8F" target="_blank" rel="noopener">范式</a>，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。</p><p>发布/订阅是<a href="https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" target="_blank" rel="noopener">消息队列</a>范式的兄弟，通常是更大的<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%A2%E5%90%91%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">面向消息中间件</a>系统的一部分。大多数消息系统在<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">API</a>中同时支持消息队列模型和发布/订阅模型，例如<a href="https://zh.wikipedia.org/wiki/Java%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1" target="_blank" rel="noopener">Java消息服务</a>（JMS）。</p><p>这种模式提供了更大的网络<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7" target="_blank" rel="noopener">可扩展性</a>和更动态的<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91" target="_blank" rel="noopener">网络拓扑</a>，同时也降低了对发布者和发布数据的结构修改的灵活性。</p><p>优点：</p><ol><li>松耦合：发布者与订阅者<a href="https://zh.wikipedia.org/wiki/%E6%9D%BE%E8%80%A6%E5%90%88" target="_blank" rel="noopener">松耦合</a>，甚至不需要知道它们的存在。</li><li>可扩展性：通过并行操作，消息缓存，基于树或基于网络的路由等技术，发布/订阅提供了比传统的客户端–服务器更好的<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E6%94%BE%E6%80%A7" target="_blank" rel="noopener">可扩展性</a>。</li></ol><h3 id="javascript里的发布订阅模式"><a class="header-anchor" href="#javascript里的发布订阅模式">¶</a><code>JavaScript</code>里的发布订阅模式</h3><p>在<code>dom</code>事件里面，有一种事件监听的模式就是基于发布订阅设计的，比如非常常见的给节点添加点击事件</p><pre><code class="language-javascript">var button = document.getElementById(&quot;button&quot;)button.addEventListener('click',() =&gt; {alert('click')},false)</code></pre><p>这样的写法好处很明显，分离事件触发和事件内容解耦。</p><p>在<code>node</code>里面，还有<code>EventEmitter</code>这个类，用来实现发布订阅模式，来处理不同对象之间的事件调用。</p><pre><code class="language-javascript">const EventEmitter = require('events');const MyEventEmitter extends EventEmitterconst myEventEmitter = new MyEventEmittermyEventEmitter.on('event',() =&gt; {    console.log(&quot;target this event&quot;)})myEventEmitter.emit(&quot;event&quot;)// target this event</code></pre><p>我之前用<code>BackBone</code>构建单页面应用的时候，就广泛用到了发布订阅模式处理不同组件之间的数据交互，但是这种方法如果滥用，会造成事件交互逻辑的不清晰，所以，父子组件数据交互还是推荐用回调的方式来做。</p><h3 id="怎么实现eventemitter"><a class="header-anchor" href="#怎么实现eventemitter">¶</a>怎么实现<code>eventEmitter</code></h3><p>下面是简单实现<code>eventEmitter</code>的<code>javaScript</code>代码</p><pre><code class="language-javascript">function EventEmitter() {    this._event = {}    this.maxListenerNum = 10}EventEmitter.prototype.on = function(type,callback) {    if(typeof callback !== &quot;function&quot;) {        throw new TypeError('callback must be a function')    }    if(!this._event) {        this._event = Object.create(null) // 这里判断不存在就生成一个，如果是继承的，不会继承这个 _event    }    if(this._event[type] ) {        if(this._event[type.length &gt; this.maxListenerNum] ) {            throw new Error(&quot;too long&quot;)        }        this._event[type].push(callback)    } else {        this._event[type] = [callback]    }}EventEmitter.prototype.once = function (type,callback) {    let warp = (...args) =&gt; {        callback(...args)        this.removeListener(type,warp)    }    warp.flag = callback    this.on(type,warp)}EventEmitter.prototype.removeListener = function(type,callback)  {    if(this._event[type] ) {        this._event[type].splice(this._event[type].indexOf(callback),1)    }}EventEmitter.prototype.removeListeners = function(type){    this._event[type] = null}EventEmitter.prototype.emit = function(type,...args) {    if(this._event[type]) {        this._event[type].forEach(fn =&gt; {            fn(...args)        });    }}</code></pre><p>测试代码</p><pre><code class="language-javascript">var my = new EventEmittermy.on('a',(a) =&gt; {    console.log(a);})my.once('once', (a) =&gt; {    console.log(a);})let add = (a,b) =&gt; {    console.log(a+b); }my.on('b',add)my.emit('a',1)my.emit('a',2)my.emit('b',1,2)my.emit('once',1)my.emit('once',2)my.removeListeners('a')my.emit('a',1)my.removeListener('b')my.emit('b',1,2)/* 输出1231*/</code></pre><p>参考：</p><p>1.<a href="https://zh.wikipedia.org/zh-hans/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85</a></p><p>2.<a href="https://segmentfault.com/a/1190000015762318" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015762318</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底搞懂ajax</title>
      <link href="/blog/posts/e9a05528/"/>
      <url>/blog/posts/e9a05528/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每个会用<code>jquery</code>的人都会用<code>$.ajax</code>发起一个<code>ajax</code>请求，然后再回调函数里面取得返回的数据，但是并不是所有的人都知道这个流程里面发生了什么事，本文就深入讨论下关于<code>ajax</code>的所有（大部分）细节。</p></blockquote><p>[TOC]</p><h3 id="1-ajax其实是标准"><a class="header-anchor" href="#1-ajax其实是标准">¶</a>1.Ajax其实是标准</h3><p>很多人误以为<code>XMLHttpRequest</code>就是<code>Ajax</code>，其实不然，他们两个是两个不同维度的概念。</p><p>搜索<code>ajax</code>的<code>wiki</code>，是这样介绍的：</p><blockquote><p><strong>AJAX</strong>即“<strong>Asynchronous JavaScript and XML</strong>”（异步的<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>与<a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="noopener">XML</a>技术），指的是一套综合了多项技术的<a href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8" target="_blank" rel="noopener">浏览器</a>端<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81" target="_blank" rel="noopener">网页</a>开发技术。Ajax的概念由<a href="https://zh.wikipedia.org/wiki/%E5%82%91%E8%A5%BF%C2%B7%E8%A9%B9%E5%A7%86%E5%A3%AB%C2%B7%E8%B3%88%E7%91%9E%E7%89%B9" target="_blank" rel="noopener">杰西·詹姆士·贾瑞特</a>所提出。</p></blockquote><h4 id="ajax技术发展史"><a class="header-anchor" href="#ajax技术发展史">¶</a>ajax技术发展史</h4><p>​        上个世纪90年代，几乎所有的网站都由HTML页面实现，服务器处理每一个用户请求都需要重新加载网页。这样的处理方式效率不高。用户的体验是所有页面都会消失，再重新加载，即使只是一部分页面元素改变也要重新加载整个页面，不仅要刷新改变的部分，连没有变化的部分也要刷新。这会加重服务器的负担。</p><p>​        这可以用<a href="https://zh.wikipedia.org/wiki/%E7%95%B0%E6%AD%A5" target="_blank" rel="noopener">异步</a>加载来解决。1995年，JAVA语言的第一版发布，随之发布的的Java applets（JAVA小程序）首次实现了异步加载。浏览器通过运行嵌入网页中的Java applets与服务器交换数据，不必刷新网页。1996年，Internet Explorer将iframe元素加入到HTML，支持局部刷新网页。</p><p>​        1998年前后，Outlook Web Access小组写成了允许<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%84%9A%E6%9C%AC&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">客户端脚本</a>发送HTTP请求（<a href="https://zh.wikipedia.org/wiki/XMLHTTP" target="_blank" rel="noopener">XMLHTTP</a>）的第一个组件。该组件原属于微软Exchange Server，并且迅速地成为了Internet Explorer 4.0[<a href="https://zh.wikipedia.org/wiki/AJAX#cite_note-2" target="_blank" rel="noopener">2]</a>的一部分。部分观察家认为，Outlook Web Access是第一个应用了Ajax技术的成功的商业应用程序，并成为包括Oddpost的网络邮件产品在内的许多产品的领头羊。但是，2005年初，许多事件使得Ajax被大众所接受。<a href="https://zh.wikipedia.org/wiki/Google" target="_blank" rel="noopener">Google</a>在它著名的交互应用程序中使用了异步通讯，如<a href="https://zh.wikipedia.org/w/index.php?title=Google%E8%AE%A8%E8%AE%BA%E7%BB%84&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Google讨论组</a>、<a href="https://zh.wikipedia.org/wiki/Google%E5%9C%B0%E5%9B%BE" target="_blank" rel="noopener">Google地图</a>、<a href="https://zh.wikipedia.org/w/index.php?title=Google%E6%90%9C%E7%B4%A2%E5%BB%BA%E8%AE%AE&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Google搜索建议</a>、<a href="https://zh.wikipedia.org/wiki/Gmail" target="_blank" rel="noopener">Gmail</a>等。Ajax这个词由《<em>Ajax: A New Approach to Web Applications</em>》一文所创，该文的迅速流传提高了人们使用该项技术的意识。另外，对Mozilla/Gecko的支持使得该技术走向成熟，变得更为简单易用。</p><p>​        所以<code>ajax</code>是一种技术方案，<code>XMLHttpRequest</code>是<code>ajax</code>在web端实现所依赖的一个对象，是这个对象使得浏览器可以发出<code>HTTP</code>请求与接收<code>HTTP</code>响应，来异步的操作网页。</p><p>​        只是现在，市面上基本都用<code>XMLHttpRequest</code> 来发送<code>ajax</code>请求。</p><p>​        <code>es6</code>新增了<code>fetch</code>来代替<code>XMLHttpRequest</code> ,比起<code>XMLHttpRequest</code>具有更好的可扩展性和高效性，下文会详细介绍。</p><p>​</p><h3 id="2-xmlhttprequest介绍"><a class="header-anchor" href="#2-xmlhttprequest介绍">¶</a>2.<code>XMLHttpRequest</code>介绍</h3><blockquote><p>​       <strong>XMLHTTP</strong>是一组<a href="https://zh.wikipedia.org/wiki/API" target="_blank" rel="noopener">API</a>函数集，可被<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>、JScript、<a href="https://zh.wikipedia.org/wiki/VBScript" target="_blank" rel="noopener">VBScript</a>以及其它<a href="https://zh.wikipedia.org/wiki/Web%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">web浏览器</a>内嵌的<a href="https://zh.wikipedia.org/wiki/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">脚本语言</a>调用，通过<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>在浏览器和<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">web服务器</a>之间收发<a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="noopener">XML</a>或其它数据。XMLHTTP最大的好处在于可以动态地更新网页，它无需重新从服务器读取整个网页，也不需要安装额外的插件。该技术被许多网站使用，以实现快速响应的动态网页应用。例如：<a href="https://zh.wikipedia.org/wiki/Google" target="_blank" rel="noopener">Google</a>的<a href="https://zh.wikipedia.org/wiki/Gmail" target="_blank" rel="noopener">Gmail</a>服务、Google Suggest动态查找界面以及<a href="https://zh.wikipedia.org/wiki/Google%E5%9C%B0%E5%9B%BE" target="_blank" rel="noopener">Google Map</a>地理信息服务。</p></blockquote><p>​        一开始，巨硬公司发明了这个可以用来构造无刷新页面的对象，这个对象可以通过<code>javascript</code>,<code>VBScript</code>或者其他的浏览器内置脚本访问，后来其他的浏览器开发公司也逐步实现了这个标准对象，到了<code>dom3</code>标准时代，它已经成为<a href="https://zh.wikipedia.org/wiki/W3C" target="_blank" rel="noopener">W3C</a>推荐的方法。截止2011年，大多数浏览器已经支持。互联网程序迎来了无刷新的页面时代，诞生了一大批优秀的<code>web</code>应用。</p><p>​现代浏览器基本都支持<code>ajax</code>,但是他们的技术方案却分为两种：</p><p>​标准浏览器通过 <code>XMLHttpRequest</code> 对象实现了ajax的功能. 只需要通过一行语句便可创建一个用于发送ajax请求的对象.</p><pre><code class="language-javascript">var xhr = new XMLHttpRequest();</code></pre><p>​IE浏览器通过<code>XMLHttpRequest</code>或者<code>ActiveXObject</code>对象同样实现了ajax的功能。</p><pre><code class="language-javascript">var xhr = new ActiveXObject(ProgID);// progID可以是下面的值，对应不同的版本Microsoft.XMLHTTPMicrosoft.XMLHTTP.1.0Msxml2.ServerXMLHTTPMsxml2.ServerXMLHTTP.3.0Msxml2.ServerXMLHTTP.4.0Msxml2.ServerXMLHTTP.5.0Msxml2.ServerXMLHTTP.6.0Msxml2.XMLHTTPMsxml2.XMLHTTP.3.0Msxml2.XMLHTTP.4.0Msxml2.XMLHTTP.5.0Msxml2.XMLHTTP.6.0</code></pre><p>​r如何取得全平台兼容的<code>XMLHttpRequest</code>对象。</p><pre><code class="language-javascript">function getXHR(){  var xhr = null;  if(window.XMLHttpRequest) {    xhr = new XMLHttpRequest();  } else if (window.ActiveXObject) {    try {      xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);    } catch (e) {      try {        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);      } catch (e) {         alert(&quot;您的浏览器暂不支持Ajax!&quot;);      }    }  }  return xhr;}</code></pre><p>​<code>HTML 5</code>的概念形成后，<code>W3C</code>开始考虑标准化这个接口。2008年2月，就提出了<a href="http://dev.w3.org/2006/webapi/XMLHttpRequest-2/" target="_blank" rel="noopener">XMLHttpRequest Level 2</a> 草案（之前是<code>Level 1</code>）。这个新版本提出了很多实用的功能，大大的加快了互联网革新。</p><p>​<em>这里对比<code>level 1</code> 和 <code>level 2</code> 的区别</em></p><table><thead><tr><th>特性</th><th>level 1</th><th>level 2</th></tr></thead><tbody><tr><td>文本数据传送</td><td>支持</td><td>支持</td></tr><tr><td>读取上传二进制</td><td>不支持</td><td>支持</td></tr><tr><td>进度信息</td><td>不支持</td><td>支持</td></tr><tr><td>同源限制</td><td>不支持跨域</td><td>可发送跨域请求</td></tr><tr><td>超时时间</td><td>不支持自己设置</td><td><code>xhr.timeout</code>设置超时时间</td></tr></tbody></table><p>​此外，为了方便表单处理，<code>html5</code>新加了个<code>FormData</code>对象，新的标准同样支持这个对象，用来模拟表单。</p><p>关于<code>level 1</code> 和 <code>level 2</code>的区别，可也参考<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener">XMLHttpRequest Level 2 使用指南</a>，阮老师对每个新特性都写了代码实例。</p><p><code>XMLHttpRequest</code>对象：</p><p>属性：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/channel" target="_blank" rel="noopener"><code>channel</code></a> 草案，不知道是啥<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozAnon" target="_blank" rel="noopener"><code>mozAnon</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozBackgroundRequest" target="_blank" rel="noopener"><code>mozBackgroundRequest</code></a>草案，布尔值，为True 时，本次请求不带cookies或者头部认证信息<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozResponseArrayBuffer" target="_blank" rel="noopener"><code>mozResponseArrayBuffer</code></a> 草案<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozSystem" target="_blank" rel="noopener"><code>mozSystem</code></a> 草案<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/multipart" target="_blank" rel="noopener"><code>multipart</code></a> 草案<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/onreadystatechange" target="_blank" rel="noopener"><code>onreadystatechange</code></a> 只要``readyState` 发生改变，就调用这个函数。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState" target="_blank" rel="noopener"><code>readyState</code></a> 当前的状态，分别是0:UNSENT,1:OPENED,2:HEADERS_RECEIVED,3:LOADING,4:DONE。在ie里，状态名称不一样。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/response" target="_blank" rel="noopener"><code>response</code></a>请求响应的正文<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseText" target="_blank" rel="noopener"><code>responseText</code></a> 返回一个DOMString，它包含对文本的请求的响应。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType" target="_blank" rel="noopener"><code>responseType</code></a> 返回数据的类型，具体见下文<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseURL" target="_blank" rel="noopener"><code>responseURL</code></a> 返回响应的序列化URL或空字符串<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseXML" target="_blank" rel="noopener"><code>responseXML</code></a> 返回一个包含请求检索的HTML或XML的<code>Document</code><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/status" target="_blank" rel="noopener"><code>status</code></a> 响应的数字状态码，采用标准HTTP 状态码<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/statusText" target="_blank" rel="noopener"><code>statusText</code></a> 状态码对应的文本信息<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/timeout" target="_blank" rel="noopener"><code>timeout</code></a> 超时时间<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload" target="_blank" rel="noopener"><code>upload</code></a> 返回<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload" target="_blank" rel="noopener"><code>XMLHttpRequestUpload</code></a> 对象，用来表示上传的进度<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/withCredentials" target="_blank" rel="noopener"><code>withCredentials</code></a> 点击查看详情，和跨域请求认证有关</p><p>方法：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort" target="_blank" rel="noopener"><code>abort()</code></a>终止请求，<code>readyState</code>会变为0<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/getAllResponseHeaders" target="_blank" rel="noopener"><code>getAllResponseHeaders()</code></a>返回所有的响应头<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/getResponseHeader" target="_blank" rel="noopener"><code>getResponseHeader()</code></a>返回指定的响应头<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/open" target="_blank" rel="noopener"><code>open()</code></a>初始化一个请求。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/overrideMimeType" target="_blank" rel="noopener"><code>overrideMimeType()</code></a><code>level 1</code>的方法，用responseType代替</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/send" target="_blank" rel="noopener"><code>send()</code></a>发送http请求<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/sendAsBinary" target="_blank" rel="noopener"><code>sendAsBinary()</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/setRequestHeader" target="_blank" rel="noopener"><code>setRequestHeader()</code></a>设置http请求头</p><h3 id="3-使用xmlhttprequest"><a class="header-anchor" href="#3-使用xmlhttprequest">¶</a>3.使用<code>XMLHttpRequest</code></h3><p>下面是用 <code>XMLHttpRequest</code>发送<code>ajax</code>  <code>get</code> 请求的例子（用到了大部分<code>api</code>）。</p><pre><code class="language-javascript">var xhr = new XMLHttpRequest(); // 新建一个XMLHttpRequest对象实例xhr.open('get',&quot;url&quot;); // 设置请求方法和地址 xhr.responseType = &quot;text&quot;; // 设置返回的数据类型xhr.timeout = 3000; // 设置超时时间// 超时处理函数xhr.ontimeout = function(e) { console.error(&quot;timeout&quot;)}; // 请求错误处理函数xhr.onerror = function(e) { console.error(&quot;error&quot;)};// 请求进度处理函数xhr.upload.onprogress = function(e) {  if (e.lengthComputable) {      var completedPercent = e.loaded / e.total; // 请求百分比    }    // 对completedPercent 操作};// 成功接收到请求的函数xhr.onload = function(e) {    if(this.status = 200) {        console.log(this.responseText)；    }}xhr.send(); // 发送请求</code></pre><p>接下来，介绍一些常用的<code>api</code>：</p><p>更详细的可以看<code>mdn</code>的文档,里面有<code>XMLHttpRequest</code>对象所有的属性，方法。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest </a></p><h4 id="open"><a class="header-anchor" href="#open">¶</a>open()`</h4><pre><code class="language-javascript">XMLHttpRequest.open(method, url)XMLHttpRequest.open(method, url, async)XMLHttpRequest.open(method, url, async, user)XMLHttpRequest.open(method, url, async, user, password)</code></pre><p><code>method</code> 就是需要使用的http方法，包括[GET],[POST],[PUT],[DELETE]等。</p><p><code>url</code>就是请求的地址<code>url</code>。</p><p><code>async</code> @可选 一个可选的布尔参数，默认为<code>true</code>，表示要不要异步执行操作。如果值为<code>false</code>，<code>send()</code>方法直到收到答复前不会返回。如果<code>true</code>，已完成事务的通知可供事件监听器使用。如果<code>multipart</code>属性为<code>true</code>则这个必须为<code>true</code>，否则将引发异常。</p><p><code>user</code>@ 可选 用户名用于认证用途；默认为<code>null</code>。</p><p><code>password</code> @可选 密码用于认证用途，默认为<code>null</code>。</p><h4 id="setrequestheader"><a class="header-anchor" href="#setrequestheader">¶</a><code>setRequestHeader()</code></h4><p>**<code>XMLHttpRequest.setRequestHeader()**</code> 是设置HTTP请求头部的方法。此方法必须在  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/open" target="_blank" rel="noopener"><code>open()</code></a>方法和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/send" target="_blank" rel="noopener"><code>send()</code></a>   之间调用。如果多次对同一个请求头赋值，只会生成一个合并了多个值的请求头。</p><h4 id="send"><a class="header-anchor" href="#send">¶</a>send()</h4><pre><code class="language-javas">void send();void send(ArrayBuffer data);void send(ArrayBufferView data);void send(Blob data);void send(Document data);void send(DOMString? data);void send(FormData data);</code></pre><p>​方法用于发送 HTTP 请求。如果是异步请求（默认为异步请求），则此方法会在请求发送后立即返回；如果是同步请求，则此方法直到响应到达后才会返回。<code>XMLHttpRequest.send()</code> 方法接受一个可选的参数，其作为请求主体；如果请求方法是 GET 或者 HEAD，则应将请求主体设置为 null，此时参数应该在<code>url</code>后面。</p><p>😏 自定义一些header属性进行跨域请求时，可能会遇到&quot;<strong>not allowed by Access-Control-Allow-Headers in preflight response</strong>&quot;，你可能需要在你的服务端设置&quot;Access-Control-Allow-Headers&quot;。</p><p>接下来从一个完整的http请求流程介绍使用</p><h4 id="设置request-header"><a class="header-anchor" href="#设置request-header">¶</a>设置request header</h4><p>发送一个<code>http</code>请求之前，有时候我们需要设置一些请求头部信息。</p><p>比如常用的<code>cookie</code>,<code>content-type</code>等。</p><p>我们可以用<code>setRequestHeader(DOMString header, DOMString value)</code>这个函数设置。</p><ul><li>header大小写不明显，<code>cookie</code>和<code>Cookie</code>是等价的。</li><li><code>Content-Type</code>可以发送的数据类型可以看上面send函数的参数类型。</li><li>设置header 必须在<code>open</code> 和<code>send</code>之间，否则会报错。</li><li>这个函数可以调用多次，在<code>send</code>之前会合并多个调用设置的值。</li></ul><p>eg:</p><pre><code class="language-javascript">var xhr = new XMLHttpRequest()xhr.open('get','url')xhr.setRequestHeader('content-type','multipart/form-data')xhr.setRequestHeader('cookie','asdaadfasdfasdfa')// 上面设置后会合并两个headerxhr.send()</code></pre><h4 id="获取response-header"><a class="header-anchor" href="#获取response-header">¶</a>获取<code>Response Header</code></h4><p>获取<code>response header</code> 可以通过<code>getAllResponseHeaders()</code> 和<code>getResponseHeader(header)</code></p><p>从名字上可以看出来，一个是获取所有的header ，一个是获取指定的某个header 对应的值。</p><p><code>getResponseHeader(header)</code> 的参数不分大小写。</p><p>但是: 这里获取部分header 是有<strong>限制</strong>的，<strong>为了安全考虑</strong>，不管是不是同源都规定客户端无法获取<code>Set-Cookie</code>这个字段，在跨域的请求里，只能获取“<code>simple response header</code>”和“<code>Access-Control-Expose-Headers</code>”。</p><p>解释：</p><blockquote><p>“<code>simple response header</code>“包括的 header 字段有：<code>Cache-Control</code>,<code>Content-Language</code>,<code>Content-Type</code>,<code>Expires</code>,<code>Last-Modified</code>,<code>Pragma</code>;<br>”<code>Access-Control-Expose-Headers</code>”：首先得注意是&quot;<code>Access-Control-Expose-Headers</code>&quot;进行<strong>跨域请求</strong>时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。</p></blockquote><p>eg:</p><pre><code class="language-javascript">xhr.getResponseHeader('Cache-Control')</code></pre><h4 id="指定返回的数据类型"><a class="header-anchor" href="#指定返回的数据类型">¶</a>指定返回的数据类型</h4><p>用过<code>jquery</code>的<code>ajax</code>都知道里面有个属性<code>dataType</code>可以指定服务器返回的数据类型。</p><p>如果想通过<code>XMLHttpRequest</code>设置返回的数据类型，可以通过<code>xhr.responseType</code>属性来设置。<code>responseType</code>是<code>xhr level 2</code>新增的属性，用来指定<code>xhr.response</code>的数据类型，目前还存在些兼容性问题。</p><p><em>可以设置的值是：</em></p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left"><code>xhr.response</code> 数据类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>&quot;&quot;</code></td><td style="text-align:left"><code>String</code>字符串</td><td style="text-align:left">默认值(在不设置<code>responseType</code>时)</td></tr><tr><td style="text-align:left"><code>&quot;text&quot;</code></td><td style="text-align:left"><code>String</code>字符串</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&quot;document&quot;</code></td><td style="text-align:left"><code>Document</code>对象</td><td style="text-align:left">希望返回 <code>XML</code> 格式数据时使用</td></tr><tr><td style="text-align:left"><code>&quot;json&quot;</code></td><td style="text-align:left"><code>javascript</code> 对象</td><td style="text-align:left">存在兼容性问题，IE10/IE11不支持</td></tr><tr><td style="text-align:left"><code>&quot;blob&quot;</code></td><td style="text-align:left"><code>Blob</code>对象</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&quot;arrayBuffer&quot;</code></td><td style="text-align:left"><code>ArrayBuffer</code>对象</td><td style="text-align:left"></td></tr></tbody></table><p>eg.</p><pre><code class="language-javascript">var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png', true);xhr.responseType = 'blob'xhr.onload = function(e){    if (this.status == 200) {        // 这里有三个可以获取返回值的属性，分别是 response，responseType responseXml         var bloob = this.response;     }}xhr.send()</code></pre><p>获取返回值：</p><ul><li><code>xhr.response</code><ul><li>默认值：空字符串<code>&quot;&quot;</code></li><li>当请求完成时，此属性才有正确的值</li><li>请求未完成时，此属性的值可能是<code>&quot;&quot;</code>或者 <code>null</code>，具体与 <code>xhr.responseType</code>有关：当<code>responseType</code>为<code>&quot;&quot;</code>或<code>&quot;text&quot;</code>时，值为<code>&quot;&quot;</code>；<code>responseType</code>为其他值时，值为 <code>null</code></li></ul></li><li><code>xhr.responseText</code><ul><li>默认值为空字符串<code>&quot;&quot;</code></li><li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseText</code>，否则抛错</li><li>只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串<code>&quot;&quot;</code>：请求未完成、请求失败</li></ul></li><li><code>xhr.responseXML</code><ul><li>默认值为 <code>null</code></li><li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>、<code>&quot;document&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseXML</code>，否则抛错</li><li>只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为<code>null</code>：请求未完成、请求失败、请求成功但返回数据无法被正确解析时</li></ul></li></ul><h4 id="追踪ajax-的当前状态"><a class="header-anchor" href="#追踪ajax-的当前状态">¶</a>追踪<code>ajax</code> 的当前状态</h4><p>上文已经说过了<code>XMLHttpRequest</code>有<code>readyState</code>状态，共有5种。</p><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>UNSENT</code></td><td>代理被创建，但尚未调用 open() 方法。</td></tr><tr><td><code>1</code></td><td><code>OPENED</code></td><td><code>open()</code> 方法已经被调用。</td></tr><tr><td><code>2</code></td><td><code>HEADERS_RECEIVED</code></td><td><code>send()</code> 方法已经被调用，并且头部和状态已经可获得。</td></tr><tr><td><code>3</code></td><td><code>LOADING</code></td><td>下载中； <code>responseText</code> 属性已经包含部分数据。</td></tr><tr><td><code>4</code></td><td><code>DONE</code></td><td>下载操作已完成。</td></tr></tbody></table><p>状态改变的时候，会触发<code>onreadystatechange</code>事件。</p><pre><code class="language-javascript">xhr.onreadystatechange = function () {    switch(xhr.readyState){      case 1://OPENED        //do something            break;      case 2://HEADERS_RECEIVED        //do something        break;      case 3://LOADING        //do something        break;      case 4://DONE        //do something        break;    }</code></pre><h4 id="设置超时时间"><a class="header-anchor" href="#设置超时时间">¶</a>设置超时时间</h4><p><code>timeout</code> 属性  单位 毫秒</p><p>如何计算时间？</p><p>开始时间指的是 <code>send</code>方法调用的时候</p><p>结束时间是<code>loadend</code>事件触发</p><p>😏注意在同步的请求里面，这个值必须设置为0.否则会报错。</p><h4 id="同步请求"><a class="header-anchor" href="#同步请求">¶</a>同步请求</h4><p>不建议发送同步请求</p><p>一定要发送的话</p><pre><code class="language-javascript">open(method, url [, async = true [, username = null [, password = null]]])// async 设置为false</code></pre><h4 id="显示进度"><a class="header-anchor" href="#显示进度">¶</a>显示进度</h4><p>我们可以通过<code>onprogress</code>事件来实时显示进度，默认情况下这个事件每50ms触发一次。</p><p>但是，上传和下载，是不同对象的<code>onprogress</code>事件。</p><table><thead><tr><th>上传</th><th><code>xhr.upload</code></th></tr></thead><tbody><tr><td>下载</td><td><code>xhr</code></td></tr></tbody></table><pre><code class="language-javascript">xhr.onprogress = function(e) {    if(e.lengthComputable) {        var p = e.loaded / e.total    }}</code></pre><h4 id="send-data-的参数"><a class="header-anchor" href="#send-data-的参数">¶</a><code>send(data)</code>的参数</h4><p><code>xhr.send(data)</code>的参数data可以是以下几种类型：</p><ul><li><code>ArrayBuffer</code></li><li><code>Blob</code></li><li><code>Document</code></li><li><code>DOMString</code></li><li><code>FormData</code></li><li><code>null</code></li></ul><p>data的值会影响请求头部<code>content-type</code>的默认值。</p><ul><li>如果<code>data</code>是 <code>Document</code> 类型，同时也是<code>HTML Document</code>类型，则<code>content-type</code>默认值为<code>text/html;charset=UTF-8</code>;否则为<code>application/xml;charset=UTF-8</code>；</li><li>如果<code>data</code>是 <code>DOMString</code> 类型，<code>content-type</code>默认值为<code>text/plain;charset=UTF-8</code>；</li><li>如果<code>data</code>是 <code>FormData</code> 类型，<code>content-type</code>默认值为<code>multipart/form-data; boundary=[xxx]</code></li><li>如果<code>data</code>是其他类型，则不会设置<code>content-type</code>的默认值</li></ul><h3 id="4-ajax和js单线程机制"><a class="header-anchor" href="#4-ajax和js单线程机制">¶</a>4.<code>ajax</code>和<code>js</code>单线程机制</h3><p>​在说这个话题之前，需要先了解下<code>js</code>的单线程机制和浏览器的多线程机制：</p><p>​<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></p><p>​       批注版:<a href="https://blog.csdn.net/lin_credible/article/details/40143961#commentBox" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></p><p>​<em>这里没有黑阮老师的意思，阮老师翻译了很多优质的外文，他的本业是金融，对于计算机知识不够严谨，但对于科普，做简单的了解是足够的，并且阮老师也对博文内的错误做了修改。所以，我们也要明白，要想真正学到东西，还是要去看标准文档，比如<code>mdn web doc</code>，去看学校里的基础课程，任何人的二手知识，只能拿来参考，绝不能作为标准。</em></p><p>​我们都知道，<code>javaScript</code>是一门单线程的语言，但是它运行的环境（这里☞的是浏览器）是多线程的。用当前最流行的<code>Chrome</code>浏览器作为例子。</p><p>有以下几个常驻线程：</p><ul><li>渲染引擎线程：顾名思义，该线程负责页面的渲染</li><li><code>JS</code>引擎线程：负责<code>JS</code>的解析和执行</li><li>定时触发器线程：处理定时事件，比如<code>setTimeout</code>, <code>setInterval</code></li><li>事件触发线程：处理<code>DOM</code>事件</li><li>异步<code>http</code>请求线程：处理<code>http</code>请求</li></ul><p>​        需要注意的是，渲染线程和<code>JS</code>引擎线程是不能同时进行的。渲染线程在执行任务的时候，<code>JS</code>引擎线程会被挂起。因为<code>JS</code>可以操作DOM，若在渲染中<code>JS</code>处理了DOM，浏览器可能就不知所措了。</p><p>另外一个需要提起的是浏览器实现异步的消息队列和事件循环</p><p>​    浏览器有一个主线程用来执行代码，还有一些其他的线程执行比较耗时的操作，比如<code>http</code>请求，定时器等，所有的函数调用都在一个<code>stack</code>里面，主线程会依次执行这个<code>stack</code>里的代码，当遇到一个异步的操作时，异步线程执行异步操作，然后当异步执行完毕，会把回调函数作为一个任务加到一个<strong>消息队列</strong><code>queue</code>里面(实际上，有多个消息队列，这里为了说明做了简化)，浏览器不断的监听着<code>stack</code>，一旦<code>stack</code>被清空。就从队列里取出一个任务加到<code>stack</code>里面，然后主线程执行这个任务。</p><p>​由于<code>js</code>引擎从消息队列里面读取事件任务时不间断的，只要<code>stack</code>清空，就会有新的任务加到里面，如果消息队列里没有任务，就会一直等待，这就是<strong>事件循环</strong><code>Event Loop</code>。</p><p>类似下面代码:</p><pre><code class="language-javascript">while (queue.waitForMessage()) {  queue.processNextMessage();}</code></pre><p>这里插播一道题：</p><pre><code class="language-javascript">new Promise(resolve =&gt; {    resolve(1);    Promise.resolve().then(() =&gt; console.log(2));    console.log(4)}).then(t =&gt; console.log(t));console.log(3);</code></pre><p>答案是 <code>4，3，2，1</code></p><p>​    具体的解释点这里<a href="https://github.com/dwqs/blog/issues/61" target="_blank" rel="noopener">从一道题浅说 JavaScript 的事件循环</a>。</p><p>回归正传，</p><p>​当发起一个<code>ajax</code>请求，调用<code>send</code>方法后，浏览器开启新的线程，发起网络请求，<code>js</code>主线程会继续向下执行，当当ajax请求被服务器响应并且收到response后, 浏览器事件触发线程捕获到了ajax的回调事件 <code>onreadystatechange</code> (当然也可能触发<code>onload</code>, 或者 <code>onerror</code>等等) . 该回调事件并没有被立即执行, 而是被添加到 <code>任务队列</code> 的末尾. 直到<code>js</code>引擎空闲了, <code>任务队列</code> 的任务才被捞出来, 按照添加顺序, 挨个执行, 当然也包括刚刚append到队列末尾的 <code>onreadystatechange</code> 事件。</p><h3 id="5-ajax和跨域"><a class="header-anchor" href="#5-ajax和跨域">¶</a>5.<code>ajax</code>和跨域</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">http访问控制</a></p><p>首先要了解什么是跨域，跨域就是因为浏览器的同源策略，造成的访问限制。</p><p>关于解决方案，看下文：</p><p>[<a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">ajax跨域，这应该是最全的解决方案了</a>](<a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012469713</a>)</p><h3 id="6-fetch-api"><a class="header-anchor" href="#6-fetch-api">¶</a>6.<code>fetch api</code></h3><p><code>Fetch API</code> 提供了一个获取资源的接口（包括跨域请求）。任何使用过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a> 的人都能轻松上手，但新的<code>API</code>提供了更强大和灵活的功能集。并且<code>fetch</code>支持<code>promise</code>语法。</p><p>关于promise点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise对象</a></p><p>关于<code>fetch</code>点击 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch API</a></p><p><code>Fetch</code>有个缺点是不支持进度。</p><p>使用方法：</p><pre><code class="language-javascript">// 简单例子fetch('http://example.com/movies.json')  .then(function(response) {    return response.json();  })  .then(function(myJson) {    console.log(myJson);  });// 支持请求参数function postData(url, data) {  // Default options are marked with *  return fetch(url, {    body: JSON.stringify(data), // must match 'Content-Type' header    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached    credentials: 'same-origin', // include, same-origin, *omit    headers: {      'user-agent': 'Mozilla/4.0 MDN Example',      'content-type': 'application/json'    },    method: 'POST', // *GET, POST, PUT, DELETE, etc.    mode: 'cors', // no-cors, cors, *same-origin    redirect: 'follow', // manual, *follow, error    referrer: 'no-referrer', // *client, no-referrer  })  .then(response =&gt; response.json()) // parses response to JSON}// 默认情况下，fetch 不会从服务端发送或接收任何 cookies,如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）fetch('https://example.com', {  credentials: 'include'  })</code></pre><p><code>tags</code>:要在不支持的浏览器中使用Fetch，可以使用<a href="https://github.com/github/fetch" target="_blank" rel="noopener">Fetch Polyfill</a>。</p><h3 id="7-axios使用"><a class="header-anchor" href="#7-axios使用">¶</a>7.<code>Axios</code>使用</h3><p><code>Axios</code> 是一个基于 <code>promise</code> 的 <code>HTTP</code> 库，可以用在浏览器和 <code>node.js</code> 中。如果你不想为了简单的发送<code>ajax</code>请求就要下载庞大的<code>jquery</code>,只有几kb大小的<code>axios</code>是很好的替代产品。</p><p>使用方法：</p><pre><code class="language-javascript">// 执行get 请求// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345')  .then(function (response) {    console.log(response);  })  .catch(function (error) {    console.log(error);  });// 可选地，上面的请求可以这样做axios.get('/user', {    params: {      ID: 12345    }  })  .then(function (response) {    console.log(response);  })  .catch(function (error) {    console.log(error);  });// 执行postaxios.post('/user', {    firstName: 'Fred',    lastName: 'Flintstone'  })  .then(function (response) {    console.log(response);  })  .catch(function (error) {    console.log(error);  });// 执行多个并发请求function getUserAccount() {  return axios.get('/user/12345');}function getUserPermissions() {  return axios.get('/user/12345/permissions');}axios.all([getUserAccount(), getUserPermissions()])  .then(axios.spread(function (acct, perms) {    // 两个请求现在都执行完成  }));</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码新手容易犯的错误</title>
      <link href="/blog/posts/68922dda/"/>
      <url>/blog/posts/68922dda/</url>
      
        <content type="html"><![CDATA[<blockquote><p>怎么判断代码质量？答案是接手的人单位时间内骂脏话的频率，频率越高，代码质量越低。</p></blockquote><h3 id="无尽的if"><a class="header-anchor" href="#无尽的if">¶</a>无尽的if</h3><p>记得刚参加工作的时候，有幸见到了前同事留下的<code>python web</code>项目，从<code>svn</code>下载下来，刚用<code>vscode</code>打开就感觉一股王霸之气铺面而来，<code>.py</code>文件一行行<code>if</code>,<code>elif</code>构成了一条条精美的贝瑟尔曲线，<code>if</code>里面是<code>if</code>，再往里面还是<code>if</code>，一眼看不到尽头，当我要加个新的配置变量，这个请求都要翻过层层的<code>if</code>高山，跨过条条<code>elif</code>大海，最终才到达它应有的处理函数。更不要说在<code>python</code>里面直接拼接<code>html</code>代码了。说好的面向对象呢？说好的<code>mvc</code>呢？</p><p>终于，在排除这些判断条件不会造成影响后，我激动的提交请求，刷新页面，纳尼？怎么没效果呢？於是我打开chrome控制台，发现在某个引入的<code>js</code>文件里的不起眼的小角落，又是一层层的<code>if</code> <code>else</code>。。。</p><img src="https://wxt.sinaimg.cn/mw1024/bca3c023gy1g2728tm7b2j20k00jyglx.jpg?tags=%5B%5D" width="20%" height="10%"><p>孤军奋战了一个月，逐步理清了大部分逻辑后，才慢慢消灭了一部分面条代码，后来呢，估计老板也受不了了，直接让重构了。</p><p>到处都是<code>if else</code>的代码就像一盘意大利面条，绕来绕去，理不清头绪，那么怎么合理利用<code>if</code>呢？好的<code>if</code>看起来是树状结构的，而不是n个不相干的<code>if</code>穿插另外一些<code>else</code>,好的结构就像下面,它们有可能嵌套，有多层的缩进,但是把逻辑却整理的清清楚楚。</p><pre><code class="language-java">if (...) {  if (...) {    ...  } else {    ...  }} else if (...) {  ...} else {  ...}</code></pre><p>那么，从这里可以得到什么结论呢？</p><ol><li>写合理的<code>if</code>结构代码，分支太多<a href="https://baike.baidu.com/item/%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95/15768054?fr=aladdin" target="_blank" rel="noopener">可以用表驱动法消灭</a>，比如用<code>map</code>储存对应的<code>condition</code>和<code>process</code>。然后就可以用这个map的key直接拿到要进行的操作了。</li><li>大段复用代码抽象为函数。</li><li><code>oo</code>语言要学会运用面向对象，对象的组合，继承来实现多态，这里需要有一定的抽象能力。</li></ol><h3 id="为同一功能编写不同的函数"><a class="header-anchor" href="#为同一功能编写不同的函数">¶</a>为同一功能编写不同的函数</h3><p>这里有个很重要的<code>DRY</code>的原则，当产品一开始可能要求烹饪一只鱼，但是需求时时刻刻都在变化，后面可能又要油炸一块鸡排，如果一开始就写成<code>cookingFish</code>的函数，在第二次增加需求的时候，就要果断重构这个函数，可以把鱼当做函数传进去，而不是在copy一份代码写个<code>cookingChicken</code>的函数，当然最好一开始就写成<code>cooking</code>函数，不要特指处理的食材，这样才能在后面更好的扩展这个函数。</p><p>案例：</p><p>在工作过的地方，见到线上的代码有处理不同车型数据的函数，于是几乎逻辑一样的代码，出现了<code>processBmw</code>,<code>processBenz</code>,<code>processAudi</code>等等十几个函数，真的让人很无奈。</p><p>这个改进方案就很灵活了，可以把品牌作为参数传进去，或者用策略模式，对不同的品牌做不同的处理逻辑。</p><h3 id="对复杂度和性能不敏感"><a class="header-anchor" href="#对复杂度和性能不敏感">¶</a>对复杂度和性能不敏感</h3><p>经验丰富的程序员在编写每一行代码时都会有肌肉记忆，当在<code>for</code> 循环里面套<code>for</code>循环的时候就会意识到成指数上升的时间复杂度而去优化算法。经验不够丰富的一般凭感觉写代码，忽视复杂度，造成性能底下的代码。</p><p>这里一般情况下遇到性能瓶颈都可以去<code>review</code>代码,查看执行时间长的部分，优化过来。</p><p>但是还是要对性能敏感一点，每当写遍历，递归的时候，或者执行一个<code>io</code>操作的时候，多想想怎么提高性能。</p><p>案例：</p><p>线上代码，在验证客户提交的excel文件的时候，要验证每一行数据在配置文件里的规则是否合理，之前的同事写了个函数<code>check</code>，但是却把读取配置文件的步骤也写在这个函数里面，导致遍历客户上传的数据，每验证一行数据都要重新读取一下配置文件。</p><h3 id="命名不清晰"><a class="header-anchor" href="#命名不清晰">¶</a>命名不清晰</h3><p>这里提供一个好的命名方案</p><h5 id="有表现力的词"><a class="header-anchor" href="#有表现力的词">¶</a>有表现力的词</h5><table><thead><tr><th>单词</th><th>更多选择</th></tr></thead><tbody><tr><td>send</td><td>deliver、dispatch、announce、distribute、route</td></tr><tr><td>find</td><td>search、extract、locate、recover</td></tr><tr><td>start</td><td>launch、create、begin、open</td></tr><tr><td>make</td><td>create、set up、build、generate、compose、add、new</td></tr></tbody></table><h5 id="带单位的命名"><a class="header-anchor" href="#带单位的命名">¶</a>带单位的命名</h5><table><thead><tr><th>参数或变量</th><th>带单位的命名</th></tr></thead><tbody><tr><td>start(int delay)</td><td>delay -&gt; delaySecs</td></tr><tr><td>createCache(int size)</td><td>size -&gt; sizeMB |</td></tr><tr><td>throttleDownload(float limit)</td><td>limit -&gt; maxKB</td></tr><tr><td>setHeight(float height)</td><td>height -&gt; heightCM |</td></tr></tbody></table><h5 id="给名字附加额外信息"><a class="header-anchor" href="#给名字附加额外信息">¶</a>给名字附加额外信息</h5><table><thead><tr><th>场景</th><th>变量名</th><th>更好的名字</th></tr></thead><tbody><tr><td>一个纯文本的密码，需要加密后才可以使用</td><td>password</td><td>plaintextPassword |</td></tr><tr><td>一条用户评论，需要转义后显示</td><td>comment</td><td>unescapedComment</td></tr><tr><td>已转化为UTF-8的HTML文本</td><td>html</td><td>htmlUtf8</td></tr><tr><td>以&quot;URL&quot;方式编码的输入数据</td><td>data</td><td>dataURLEncode |</td></tr></tbody></table><h3 id="不懂语言内置函数"><a class="header-anchor" href="#不懂语言内置函数">¶</a>不懂语言内置函数</h3><p>这个就纯粹是经验问题了，不会用语言已经给的标准函数，偏偏自己写逻辑。但是，为啥我遇到那么多这样的代码，难道我接手的项目的都是编程小白写的？</p><p>举几个例子：</p><p>实现英文转换大小写，我看到是这样写的，定义了一个函数，接受一个字符串作为参数，遍历这个字符串，判断每个字符，如果是小写的<code>a</code>就转换为大写的<code>A</code>,依次类推，我无F可说了。</p><p>从数据库拿到数据后，自己有用冒泡排了顺序。是有多心疼数据库，舍不得让它多干一点事。</p><p>用<code>freemarker</code>做模板，输出<code>json</code>里面有特殊字符，遇到一个就<code>replace</code>一个，提交一次代码，就不能看下文档用<code>${string?JSON}</code>吗?</p><p>and so on…</p><p><img src="https://wx1.sinaimg.cn/mw1024/bca3c023gy1g272av1q13j207905d749.jpg" alt></p><p>所以。平时没事可以多看看<code>api</code>，遇到问题先找找有木有内置的标准库或者函数。免得自己写，效率低还可能有bug。</p><h3 id="计算机和网络基础薄弱"><a class="header-anchor" href="#计算机和网络基础薄弱">¶</a>计算机和网络基础薄弱</h3><p>有个需求是判断<code>api</code>请求来源是自己的web产品端还是通过其他微服务接口,有个同事是这样写的，在自己的web端调用每个接口的时候都加了个<code>FLAG</code>参数，然后在服务端每个接口都判断下<code>FLAG</code>,emmmmm~不说啥了。</p><p>判断云服务接口端（http和mqtt协议）是否正常，不实现心跳接口，反而在自己的代码里去<code>ping</code>服务端，这里就是不懂网络架构，如果懂网络七层协议，就不会想当然的把能<code>ping</code>通当做服务正常了。</p><p>还有一些读完文件不释放资源的，不明白异步和同步，在同步的代码里各种<code>sleep</code>的。</p><p>关于这部分，如果是科班出身的，基础不牢固真的对不起自己在学校花费的时间和经历。</p><h4 id="先写到这儿吧"><a class="header-anchor" href="#先写到这儿吧">¶</a>先写到这儿吧。</h4><p><em>题外话</em><br>说了这么多其实自己作为🐔时期也写了不少坑爹代码 😉，正所谓 问道有先后，一方面遇到这些代码要冷静，想想怎么改善一点点的重构，另一方面也要规范编码习惯和提升姿势水平，争取让自己的代码被别人读的时候，少说几句&quot;wtf&quot;。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 吐槽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html各种布局整理</title>
      <link href="/blog/posts/e08b183b/"/>
      <url>/blog/posts/e08b183b/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="传统布局"><a class="header-anchor" href="#传统布局">¶</a>传统布局</h3><blockquote><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="noopener">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="noopener"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener"><code>float</code></a>属性。</p></blockquote><h4 id="1-圣杯布局"><a class="header-anchor" href="#1-圣杯布局">¶</a>1.圣杯布局</h4><p>圣杯布局就是两边顶宽，中间自适应的三栏布局，中间栏要放在文档流前面一优先渲染。</p><p>很多经典的网页就是这种布局，应用场景很多。</p><p>先看下圣杯布局的<code>dom</code>结构。</p><pre><code class="language-html">&lt;section class=&quot;layout grail&quot;&gt;        &lt;h1&gt;圣杯布局&lt;/h1&gt;        &lt;article class=&quot;left-center-right&quot;&gt;            &lt;div class=&quot;center&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;        &lt;/article&gt;    &lt;/section&gt;</code></pre><p>注意：</p><p>这里center 要放在第一个，就是 <strong>中 左 右</strong> 的顺序。</p><p>把“中”放在第一位，是为了首先加载“中”的内容，并且“中”的宽度是自适应的。</p><p>有两种方法，第一种是给左右设置负的<code>margin-left</code>,<a href="http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html#2457812" target="_blank" rel="noopener">点击查看负margin的原理</a>。</p><p>简单来说，给左 设置 <code>margin-left:-100%</code>.右设置<code>margin-left:-300px;</code>就把这两个box 拉回上一行，然后给父容器设置左右<code>padding</code> 为 左右的宽度，不过此时左右又受到<code>padding</code>的影响，向中间挤。此时然后再用相对定位把左右调整一下。</p><p><code>css</code>代码如下。</p><pre><code class="language-css">.layout.grail .left-center-right {            padding: 0 300px;            min-width: 304px;        }        .layout.grail .left-center-right&gt;div {            float: left;            min-height: 100px;        }        .layout.grail .center {            background: yellow;            width:100%;        }        .layout.grail .left {            margin-left: -100%;            width: 300px;            background: red;            position: relative;            left: -300px;        }        .layout.grail .right {            margin-left: -300px;            width: 300px;            background: blue;            position: relative;            right: -300px;        }</code></pre><p>第二种是给父容器设置</p><pre><code class="language-css"> overflow: hidden;    box-sizing: border-box;    padding: 0 300px 0 300px;</code></pre><p>圣杯布局的优点：</p><ul><li>主列率先加载</li><li>允许任何列是最高的</li><li>DOM结构简单</li></ul><p>缺点：</p><ul><li>和双飞翼布局相比CSS样式较为复杂</li></ul><h4 id="2-双飞翼布局"><a class="header-anchor" href="#2-双飞翼布局">¶</a>2.<strong>双飞翼布局</strong></h4><p>双飞翼布局源自淘宝UED，第一步和圣杯布局一样，浮动三列，给左右两列设置负外边距；同样会覆盖主列main，双飞翼布局的做法是在主列main后面添加了一个宽度为100%的div，再设置主列main的左右边距，代码如下：</p><pre><code class="language-html">&lt;div class=&quot;wrap&quot;&gt;    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="language-css">  .wrap{            float: left;            width: 100%;        }        .main{            height: 200px;            margin-left: 110px;            margin-right: 210px;            background-color: #01549b;        }        .left{            float: left;            height: 200px;            width: 100px;            margin-left: -100%;            background-color: #bd4147;        }        .right{            float: left;            height: 200px;            width: 200px;            margin-left: -200px;            background-color: #419641;        }</code></pre><p>优点：</p><ul><li>率先加载主列main</li><li>允许任何列是最高的</li><li>CSS样式简单</li></ul><p>缺点：</p><ul><li>和圣杯布局相比DOM结构较为复杂</li></ul><h3 id="现代布局"><a class="header-anchor" href="#现代布局">¶</a>现代布局</h3><h4 id="1-flex-布局"><a class="header-anchor" href="#1-flex-布局">¶</a>1.flex 布局</h4><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a>  阮一峰老师翻译的css-tricks上的文章。</p><p>原文地址：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">A Complete Guide to Flexbox</a></p><p>用<code>Flex</code>布局实现中间自适应，两边固定，很简单。</p><p><code>dom</code>节点</p><pre><code class="language-html">   &lt;header&gt;        header    &lt;/header&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;div class=&quot;left&quot;&gt;             left        &lt;/div&gt;        &lt;div class=&quot;center&quot;&gt;             center        &lt;/div&gt;        &lt;div class=&quot;right&quot;&gt;             right            &lt;/div&gt;    &lt;/div&gt;    &lt;footer&gt;        footer    &lt;/footer&gt;</code></pre><p><code>css</code>代码</p><pre><code class="language-css">.box {    display: flex;    justify-content: space-between;}.left {    width:300px;    background-color: aquamarine;}.center {    background-color: black;    width: 100%;}.right{    width: 350px;background-color: blue;}</code></pre><p>只要把父的<code>dom</code>的<code>display</code>设置为<code>flex</code>就行了。</p><h4 id="2-grid-布局"><a class="header-anchor" href="#2-grid-布局">¶</a>2.grid 布局</h4><p><a href="https://www.jianshu.com/p/d183265a8dad" target="_blank" rel="noopener">Grid布局指南</a>  也是一篇译文。</p><p>原文地址：<a href="https://css-tricks.com/snippets/css/complete-guide-grid/#prop-grid-column-row" target="_blank" rel="noopener">A Complete Guide to Grid</a></p><pre><code class="language-html">&lt;div class='grid'&gt;    &lt;div class=&quot;left&quot;&gt;        left    &lt;/div&gt;    &lt;div class='rigth'&gt;        right    &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="language-css">.grid{    display: grid;    grid-template-columns: 200px auto;    grid-template-rows: 200px;}</code></pre><hr><p>资料和代码来源：</p><p><a href="https://zhuanlan.zhihu.com/p/25353247" target="_blank" rel="noopener">双飞翼布局与圣杯布局</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-一个所见即所得的文本编辑器</title>
      <link href="/blog/posts/f7575273/"/>
      <url>/blog/posts/f7575273/</url>
      
        <content type="html"><![CDATA[<h3 id="typora"><a class="header-anchor" href="#typora">¶</a>typora</h3><p>​很久很久之前，我以为<code>word</code>就是<strong>所见即所得</strong>的最佳文档编写工具，直到熬夜写完毕业论文，第五次跑到打印店更正格式，来满足范文的正确格式。我突然明白，同学和我说，一定要用<code>pdf</code>来写论文是什么意思了。</p><h4 id="1-真正的所见即所得"><a class="header-anchor" href="#1-真正的所见即所得">¶</a>1.真正的所见即所得</h4><p>​word 功能很强大，也很复杂，是非常非常非常（重要的事情说三遍）专业的文本处理软件，但是，有时我们只想写简单的文档，为毛在自己电脑上看到的和打印出来的不一样呢？这就很令人烦恼。</p><p>​用typora + markdown来写简单的文档是再合适不过了，令人惊奇的的是，typora不想其他的markdown软件，有编辑区和预览区两个部分，它只有编辑区，当你输入一行markdown语法的文本，按下回车，这行文本立刻被渲染成最终展示的效果。</p><p>比如输入</p><pre><code class="language-sh">### 这是三级标题</code></pre><p>立刻生成</p><hr><h3 id="这是三级标题"><a class="header-anchor" href="#这是三级标题">¶</a>这是三级标题</h3><hr><p>其他的包括有序，无序列表，表格，图片等都是这样。</p><h3 id="2-数学代码块"><a class="header-anchor" href="#2-数学代码块">¶</a>2.数学代码块</h3><p>​markdown中的数学表达式的语法跟latex的语法一样，习惯latex语法的人可以采用latex的语法编辑数学表达式，但是其中也有一些不同，比如：</p><p>数学表达式的斜体字强制为非斜体字：{\rm [非斜体字的内容]}</p><p>假设要将表达式中的and改为非斜体字的格式，可以采用 {\rm and}实现。</p><p>行内公式可以用$$后输入回车来插入数学公式。（需要在File-&gt;Preferences中勾选“Inline math”）</p><p>这个我现在用的很少，只恨当时再学校的时候不知道这个神器，用word 写数学公式有多痛苦:，用过的都知道。</p><h3 id="3-绘制图表"><a class="header-anchor" href="#3-绘制图表">¶</a>3.绘制图表</h3><p>代码来自官方：</p><pre><code class="language-shell">graph LRA[Hard edge] --&gt;B(Round edge)    B --&gt; C{Decision}    C --&gt;|One| D[Result one]    C --&gt;|Two| E[Result two]</code></pre><p>对应的是：</p><p><img src="https://wx4.sinaimg.cn/mw1024/bca3c023gy1g1xv6mmn64j20wm07sjrb.jpg" alt="img"></p><p>此外，还支持流程图</p><pre><code class="language-shell">st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op</code></pre><p><img src="https://wx3.sinaimg.cn/mw1024/bca3c023gy1g1xv6mhti3j20wn0hrjrk.jpg" alt="img"></p><p>UML时序图：</p><pre><code class="language-/shell">对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗</code></pre><p><img src="https://wx1.sinaimg.cn/mw1024/bca3c023gy1g1xv6mhnjkj20wk0b60ss.jpg" alt="img"></p><p>怎么样？是不是很强大。</p><p>学会上面三种语法，简单画图再也不用word，viso,这些占内存的专业软件了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> typora </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript异步操作进化曲</title>
      <link href="/blog/posts/2b77e8c0/"/>
      <url>/blog/posts/2b77e8c0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>老生常谈，今天也来总结下<code>javaScript</code> 中异步操作的历史。</p></blockquote><p><em>TL;DR</em><br>1.同步和异步区别<br>2.经典的回调函数<br>3.简单明了的<code>promise</code>函数<br>4.未来的主流<code>async</code>函数</p><h2 id="同步和异步的区别"><a class="header-anchor" href="#同步和异步的区别">¶</a>同步和异步的区别</h2><p>异步简单来说就是做一件事时，做到一半可能需要等待系统或服务处理之后才会得到响应和结果，此时可以转去做另一件事，等到获得响应之后在去执行剩下一半的事情。反之同步就是一直等到响应然后接着做事，中间不会跳去做别的事。</p><h2 id="回调函数"><a class="header-anchor" href="#回调函数">¶</a>回调函数</h2><p>就是我们经常用到的回调函数，最开始用ajax 的时候，会写出下面样子的代码。</p><pre><code class="language-javascript">$.ajax({    url:&quot;path&quot;,    success:function() {        // do something    }})</code></pre><p>缺点是读起来跳跃性太强，不好跟踪代码。而且在前后依赖的时候，形成回调地狱，一旦修改一个，嵌套的都要改。另外就是无法合并多个异步代码。</p><h2 id="简单明了的promise函数"><a class="header-anchor" href="#简单明了的promise函数">¶</a>简单明了的<code>promise</code>函数</h2><p>Promise的引入就解决了以上这些问题,首先来看下Promise的简单用法：</p><pre><code class="language-javascript">let p = new Promise(function(resolve, reject) {    resolve(100)；})；p.then(function(data) {    console.log('data', data);}, function(err) {    console.log('err', err);});</code></pre><p>可以看到Promis通过then的链式调用解决了嵌套回调的问题，在用法上Promise的构造函数会接受一个executor函数，这个函数带有两个参数resolve和reject，两个参数背后其实就是两个函数，而通过Promise构造函数创建出来的对象会保存一个status属性，resolve会做的事就是将这个属性从初始化的pending转为resolved，而reject则是转为rejected，同时两个函数都可以接受一个参数，作为之后then中回调函数的参数传入，那么在then方法中我们可以看到它接收两个参数，第一个就是成功resolved之后会调用的回调函数，第二个就是rejected的回调函数。<br>这里注意的是，只要状态转为resolved或rejected之中的其中一个，那么当前promise对象就不能再转变状态了。之后不管调resolve还是reject都会被忽略。<br>另外，上面所说Promise是可以支持链式调用的，所以then是可以多次调用的，但是因为刚刚所说状态不可转变的问题，所以链式调用每次then返回的不是当前的Promise对象而是一个新的Promise对象，那么第2次then的状态又是怎么决定的呢，第一次then中无论是成功的回调还是失败的回调只要返回了结果就会走下一个then中的成功，如果有错误走下一个then的失败。</p><p>此外，<code>promise</code> 还有：</p><pre><code class="language-javascript">Promise.all()Promise.race()Promise.resolve()Promise.reject()</code></pre><p>这些api<br><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise 对象</a>。</p><p>关于promise的实现，可以看下PromiseA+的原则。下面是一个实现：</p><!-- Get UTF-8 Size (ANSI C) --><!-- Begin --><script src="https://gist.github.com/x1nes/5fad2985f43f235ed59702b805a7d824.js"></script><!-- End --><h2 id="async-await"><a class="header-anchor" href="#async-await">¶</a>async+await</h2><p>async+await就是目前为至，异步的最佳解决方案，它同时解决了<br>其实，它是<code>Generator</code>函数的语法糖，之后我会单独写一篇博文介绍<code>Generator</code>函数和它的异步用法。<br>回调地狱<br>并发执行异步，在同一时刻同步返回结果 Promise.all<br>返回值的问题<br>可以实现代码的try/catch;</p><pre><code class="language-javascript">let bluebird = require('bluebird');let fs = require('fs');let read = bluebird.promisify(fs.readFile);// 用async来修饰函数，aysnc需要配await, await只能接promise// async和await(语法糖) === co + generatorasync function r() {    try{        let content1 = await read('./2.promise/100.txt', 'utf8');        let content2 = await read(content1, 'utf8');        return content2;    } catch(e) { // 如果出错会catch        console.log('err', e)    }}// async函数返回的是promiser().then(function(data) {    console.log('flag', data);}, function(err) {    console.log(err);`})</code></pre><p>此外，还有Generator 实现的，利用<code>co</code>库实现 next方法嵌套取值执行，本人很少用到，就不详细介绍了。<br>可以看<a href="http://es6.ruanyifeng.com/#docs/generator-async" target="_blank" rel="noopener">Generator 函数的异步应用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js变量提升的原理</title>
      <link href="/blog/posts/97277281/"/>
      <url>/blog/posts/97277281/</url>
      
        <content type="html"><![CDATA[<blockquote><p>新版的es6里面，加入了块级作用域<code>let</code>,算是解决了长久以来javascript的变量提升问题。没有<code>let</code>之前，变量只有函数内的作用域和全局作用域（其实全局也是在<code>window</code>这个对象下的），一方面如果忘记加上<code>var</code>,作用域就会提升，另一方面，对变量提升一知半解，导致变量先计算，再赋值，会造成难以预料的问题。</p></blockquote><h2 id="js引擎的方式"><a class="header-anchor" href="#js引擎的方式">¶</a>JS引擎的方式</h2><p>因为javaScript是脚本语言，运行在JS虚拟机里面，因此，非常有必要了解一下JS引擎执行JS代码的过程。<br>JS引擎的工作方式就是：1，解析（编译）JS代码，这时候会声明所有的变量，注意这里没有对变量赋值；2，运行，运行的时候会对变量进行赋值。同一个作用域内，变量的声明语句都会被提升到代码的头部，这个就是变量提升，比如：</p><pre><code class="language-javascript">console.log(a);var a = 10;</code></pre><p>运行结果是：</p><pre><code class="language-javascript">undefined;</code></pre><p>因为变量提升后是这样的：</p><pre><code class="language-javascript">var a ;console.log(a);a = 10;</code></pre><p>实际上运行的时候，<code>a</code>还没有被赋值。</p><h2 id="需要注意的地方"><a class="header-anchor" href="#需要注意的地方">¶</a>需要注意的地方</h2><p>1.变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。</p><pre><code class="language-javascript">console.log(aa);aa =1;  // 会报错</code></pre><p>2.function也可以看为变量，会发生提升。但是如果是赋值的形式，则不会</p><pre><code class="language-javascript">function a(){}; // 会提升var b = function(){}; // 不会提升，因为这个是赋值语句，运行时，b没有被赋值，因此是undefined</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛顿法求平方根</title>
      <link href="/blog/posts/75cc5c0/"/>
      <url>/blog/posts/75cc5c0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>沉积了几周后突然想发个博文，没啥特别的理由，任性！虽然这个算法非常简单，但是还是有点不一样的，因为要用lisp写的。</p></blockquote><h2 id="怎么求一个数的平方根"><a class="header-anchor" href="#怎么求一个数的平方根">¶</a>怎么求一个数的平方根</h2><p>当提到平方根，我们心里都很清楚这个概念，A的平方如果等于B，那么A就是B的平方根。计算机是怎么计算平方根呢？最常用的就是牛顿的逐步逼近法。这个方法就是，如果对X的平方根的值有一个猜测Y，那么就可以通过执行一个简单的操作去得到一个更好的猜测：只需要求出Y和X/Y的平均值，然后继续这一计算过程，就可以得到对X的平方根越来越接近的近似值。</p><h2 id="下面就是代码了"><a class="header-anchor" href="#下面就是代码了">¶</a>下面就是代码了。</h2><pre><code class="language-lisp">(define (abs x)  (if (&lt; x 0)       (- x)       x))(define (square x) (* x x))(define (average x y)(/ (+ x y) 2))(define (improve guess x) (average guess (/ x guess)))(define (good-enough? guess x)  (&lt; (abs (- (square guess) x)) 0.001))(define (sqrt-iter guess x)  (if (good-enough? guess x)      guess      (sqrt-iter (improve guess x) x)))(define (sqrt x)  (sqrt-iter 1.0 x))</code></pre><h2 id="关于lisp"><a class="header-anchor" href="#关于lisp">¶</a>关于lisp</h2><p>lisp真的和之前写过任何一种编程语言都不一样，它褪去了所有的伪装，直白的用近似语法树的<code>s</code>表达式来生成各种逻辑。<br>关于lisp，可以看一篇文章<a href="http://www.yinwang.org/blog-cn/2013/03/26/lisp-dead-alive" target="_blank" rel="noopener">Lisp 已死，Lisp 万岁！</a>,另外，知名科普读物《黑客与画家》中也花费大额的文字介绍这个陌生的语言，更给它添加上了神秘的色彩。</p>]]></content>
      
      
      
        <tags>
            
            <tag> lisp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天讲讲字符串</title>
      <link href="/blog/posts/66f44841/"/>
      <url>/blog/posts/66f44841/</url>
      
        <content type="html"><![CDATA[<blockquote><p>编程中，很常见的环节就是处理字符串，今天介绍一些常用的字符串处理技巧。</p></blockquote><h2 id="什么是字符串？"><a class="header-anchor" href="#什么是字符串？">¶</a>什么是字符串？</h2><p>字符串是编程语言中的概念，我所接触到的所有的编程语言都支持字符串，字符串从概念上就是由零个或多个字符组成的有限序列。在我们编写代码时，通常以串的整体作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。注：子串就是长度小于或者等于待处理字符串的一个字符串。<br><em>字符串的长度</em>：尽管形式字符串可以有任意（但有限）的长度，实际语言的字符串的长度经常被限制到一个人工极大值。一般的说，有两种类型的字符串数据类型：“定长字符串”，它有固定的极大长度并且不管是否达到了这个极大值都使用同样数量的内存；和“变长字符串”，它的长度不是专断固定的并且依赖于实际的大小使用可变数量的内存。在现代编程语言中的多数字符串是变长字符串。尽管叫这个名字，所有变长字符串还是在长度上有个极限，一般的说这个极限只依赖于可获得的内存的数量。<br><em>常见的字符串操作</em>：连接两个字符串，在一个长字符串中搜索一个子串，求得子串在长字符串的位置，转换大小写，将字符串按照字符分割成数组，按照下标分割成若干个字符串。</p><h2 id="实现方式"><a class="header-anchor" href="#实现方式">¶</a>实现方式</h2><p>众所周知，在java里面字符串是不可变类，也就是final类，主要是为了安全性，比如我们经常用<code>String</code>类型作为<code>hashmap</code>的<code>key</code>，如果<code>String</code>是可变的类，那就很容易出现一样的<code>key</code>了，另外，<code>String</code><br>这种经常使用的数据类型，就像<code>int</code>,<code>boolean</code>一样，设计成不可变的,也是合乎情理。<br>查看java的<code>String</code>的源代码，就可以看到</p><pre><code class="language-java">  public final class String      implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {      /** The value is used for character storage. */      private final char value[];</code></pre><p>这里很关键的地方是组成字符串的字符数组是<code>private final</code> 的，这样就阻止了修改一个字符串对象的值。sun公司的工程师这样做，主要考虑到了我们经常用到<code>String</code>，干脆设计为不可变，免得出问题，当然，考虑到性能，又设计了<code>StringBuilder</code>和<code>StringBuffer</code>这两个可以变的字符串对象。</p><h2 id="常用算法"><a class="header-anchor" href="#常用算法">¶</a>常用算法</h2><p>1 简单粗暴的匹配算法—bf算法<br>BF算法(Brute-Force，最基本的字符串匹配算法)，bf算法的思路很简单，定义两个索引，i和j，分别是主串T和子串C正在做比较的下标，i从0开始比较，如果判断相等，就比较后续的字符，后续不匹配，就从主串的下一个字符比较，知道主串里的每个字符都依次和子串相等。</p><pre><code class="language-javascript">function bfSearch(sourceStr, searchStr) {  var i = 0,      j = 0;    while (i &lt; sourceStr.length) {        // 两字母相等则继续          if (sourceStr.charAt(i) == searchStr.charAt(j)) {          i++;          j++;        } else { // 两字母不等则角标后退重新开始匹配            i = i - j + 1; // i 回退到上次匹配首位的下一位            j = 0; // j 回退到子串的首位          }        if (j == searchStr.length) {          return i - j;        }    }    return -1}</code></pre><p>2 效率高的匹配算法—KMP算法</p><p>3 回文算法</p><hr><p>未完待续。。。。</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5到底是啥？</title>
      <link href="/blog/posts/d374f967/"/>
      <url>/blog/posts/d374f967/</url>
      
        <content type="html"><![CDATA[<blockquote><p>现在招聘前端信息上动不动就是熟练掌握h5开发，我有点费解，h5到底是啥？貌似平时也有用到H5的新标签和webSocket等技术，这样算是掌握h5开发了吗？查找资料后简单介绍下这个当红的技术。</p></blockquote><h2 id="html5介绍："><a class="header-anchor" href="#html5介绍：">¶</a>html5介绍：</h2><p>html5是超文本标记语言的第五代。<br>狭义上的HTML5：</p><ol><li>HTML4.0的升级版本</li><li>HTML5+CSS3+新增JS API</li><li>W3C制定的关于HTML技术约定的新规范</li></ol><p>广义上的HTML5：</p><ol><li>HTML5行业的代名词</li><li>行业的技术标准</li><li>当前新技术的代名词</li></ol><p>其实，有些招聘的要求会h5，就是会做那些微信扫码打开的炫酷宣传页面，比如活动页面，祝福贺卡之类的，当然，这些只是h5的一小部分内容.h5包括以下部分：</p><ol><li>新增标签以及属性；</li><li>CSS3的新特性；</li><li>Canvas绘图；</li><li>JavaScript的新增API（如重力感应、HTML5视音频等）；</li><li>移动端。</li></ol><h2 id="新特性介绍："><a class="header-anchor" href="#新特性介绍：">¶</a>新特性介绍：</h2><p>1.新标签：<br><br>Html5新增了 27 个元素，废弃了 16 个元素，根据现有的标准规范，把 HTML5 的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。<br><br>结构性元素主要负责web上下文结构的定义 <br><br>section：在 web 页面应用中，该元素也可以用于区域的章节描述。<br><br>header：页面主体上的头部， header 元素往往在一对 body 元素中。<br><br>footer：页面的底部（页脚），通常会标出网站的相关信息。<br><br>nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。<br><br>article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。<br><br>级块性元素主要完成web页面区域的划分，确保内容的有效分割。<br><br>aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。<br><br>figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。<br><br>code：表示一段代码块。<br><br>dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。<br><br>行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。<br><br>meter：表示特定范围内的数值，可用于工资、数量、百分比等。<br><br>time：表示时间值。<br><br>progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。<br><br>video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。<br><br>audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。<br><br>交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。<br><br>details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。<br><br>datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。<br><br>menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。<br><br>command：用来处理命令按钮。<br><br><br><br>2.CSS3的新特性；<br><br>CSS3实现圆角（border-radius），阴影（box-shadow）<br><br>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）<br><br>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜等等变换<br><br>增加了更多的CSS选择器  多背景 rgba<br><br>在CSS3中唯一引入的伪元素是 ::selection.<br><br>媒体查询，多栏布局，弹性盒子<br><br>border-image<br><br>css3动画<br></p><p>3.canvas绘图：<br><br>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。<br><br>没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。<br></p><p>4.JavaScript的新增API：<br><br>requestAnimationFrame,相比于setInterval,性能更高的动画实现方法。<br><br>Page Visibility api,页面是否被隐藏，最小化的api接口。<br><br>Geolocation Api,地理位置。<br><br>File Api:文件操作。<br><br>web Worker:后台运行js代码，不会影响页面显示。<br><br><br></p><p>5.移动端：<br><br>借助于响应式开发，和更强大的js引擎，以及新的css实现，语义化，现在网页在移动端也可以表现的更好了。<br></p><h2 id="后记"><a class="header-anchor" href="#后记">¶</a>后记</h2><p>好久没写博客了，东拼西凑又攒了一篇。。。</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解下Three.js(二)</title>
      <link href="/blog/posts/bf5e5ce9/"/>
      <url>/blog/posts/bf5e5ce9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上篇讲了Three.js入门，介绍了three.js的基本信息的三大部分（scene,renderer,camera）,算是对Three.js有了基本的认识。这篇来具体创建一些三维物体，并用requestAnimationframe做一个可以动的效果。</p></blockquote><h2 id="画一个三维场景"><a class="header-anchor" href="#画一个三维场景">¶</a>画一个三维场景</h2><p>主要用到了下面这些东西。</p><table><thead><tr><th>对象</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Panel(平面)</td><td style="text-align:center">作为地面的二维矩阵</td></tr><tr><td>Cube(方块)</td><td style="text-align:center">三维立方体</td></tr><tr><td>Sphere(球体)</td><td style="text-align:center">三维球体</td></tr><tr><td>Camera(相机)</td><td style="text-align:center">相机决定你可以看到的东西</td></tr><tr><td>Axes(轴)</td><td style="text-align:center">x，y，z三个轴</td></tr></tbody></table><p>代码如下</p><pre><code class="language-javascript">var scene = new THREE.Scene();var camera = new THREE.PerspctiveCamera(45,window.innerWidth/window.innerHeight,0.1,1000);var renderer = new THREE.WebGLRender();renderer.setClearColorHex();renderer.setClearColor(new THREE.Color(0xEEEEEE));renderer.setSize(window.innerWIth,window.innerHeight);// 创建一个轴var axes = new THREE.AxisHelper(20);scene.add(axes);// 创建一个平面var planeGeometry = new THREE.PlaneGeometry(60,40);var planeMaterial = new THREE.MeshBasicMaterial({color: 0xcccccc});var plane = new THREE.Mesh(planeGeometry,planeMaterial);plane.rotation.x = -0.5 * Math.PI;plane.position.x = 15;plane.position.y = 0;plane.position.z = 0;scene.add(plane)// 创建一个方体var cubeGeometry = new THREE.BoxGeometry(4, 4, 4);var cubeMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true});var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);cube.position.x = -4;cube.position.y = 3;cube.position.z = 0;scene.add(cube);// 创建一个球体 wireframe是是否显示网格。var sphereGeometry = new THREE.SphereGeometry(4, 20, 20);var sphereMaterial = new THREE.MeshBasicMaterial({color: 0x7777ff, wireframe: true});var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);sphere.position.x = 20;sphere.position.y = 4;sphere.position.z = 2;scene.add(sphere);camera.position.x = -30;camera.position.y = 40;camera.position.z = 30;camera.lookAt(scene.position);document.getElementById(&quot;WebGL-output&quot;).appendChild(renderer.domElement);// 开始渲染renderer.render(scene, camera);</code></pre><p>这里用到了透视相机，该类型的相机使用透视矩阵，也就是人眼看到的近大远小的效果；</p><p>构造函数：<br>PerspectiveCamera(fov, aspect, near, far)<br>Fov – 相机的视锥体的垂直视野角<br>Aspect – 相机视锥体的长宽比<br>Near – 相机视锥体的近平面<br>Far – 相机视锥体的远平面</p><p>关于相机的具体信息，以后会单独用一篇来讲。</p><h2 id="关于坐标"><a class="header-anchor" href="#关于坐标">¶</a>关于坐标</h2><p>three.js用的是右手坐标系</p><p><img src="/img/yszbx.jpg" alt="右手坐标系"></p><p>AxisHelper是一个坐标轴对象，添加到场景中我们就可以看到世界坐标系的具体位置。</p><h2 id="加点别的东西"><a class="header-anchor" href="#加点别的东西">¶</a>加点别的东西</h2><p>上面生成的场景是不是有点单调呢？我们还可以再加点调料，比如~~~灯光什么的。</p><pre><code class="language-javaScript">var spotLight = new THREE.SpotLight(0xffffff);spotLight.position.set(-40, 60, -10);scene.add(spotLight);</code></pre><p>但是！添加光源后什么都没发生，原来，MeshBasicMaterial(基础材质)创建的物体不能反射光源。所以我们要改变这些对象的材质。用MeshLambertMaterial或者MeshPhongMaterial。这下好了，可以看到光源了。</p><p>但是*2！怎么没有影子呢？原来，渲染阴影需要大量的计算资源。默认下，Three.js不渲染阴影。<br>需要：</p><pre><code class="language-javaSCript">renderer.shadowMapEnabled = true;// 物体也需要设置接受阴影plane.receveShadow = true;cube.castShadow = true;sphere.castShadow = true;// 灯也需要设置spotLight.castShadow = true;</code></pre><p>接下来，就要用到requestAnimationframe了，让三维物体动起来。<br>我们都知道，可以设置定时任务。setInterval(f,i),但是，浏览器刷新重绘是有固定间隔的，一般是16ms，所以一般这个定时任务也会设置为这个间隔，但是有些不是，就可以用requestAnimationframe，它会根据浏览器刷新执行函数。</p><pre><code class="language-javascript">function renderScene() {    /**/    requestAnimationframe(renderScene);    renderer.render(scene,camera);}</code></pre><p>这样就可以不停的执行渲染函数了，发挥你的想象力，在上面注释的部分加上代码，让物体动起来吧。</p><p>比如，旋转方块</p><pre><code class="language-javascript">cube.rotation.x +=0.02;cube.rotation.y +=0.02;</code></pre><p>小tips：<br>如何在页面显示FPS<br>在页面上加div</p><pre><code class="language-html">&lt;div id=&quot;state&quot;&gt;&lt;div&gt;&lt;script&gt;var stats = initstate();function initstate() {    var stats = new Stats();    stats.setMOde(0);    stats.domElement.style.position = 'absolute';    stats.domElement.style.left = '0px';    stats.domElement.style.top = '0px';    document.getElementById(&quot;Stats-output&quot;).appendChild(stats.domElement);    return stats;}&lt;script&gt;</code></pre><p>然后，在render里执行<code>stats.update();</code> 就OK了。</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
            <tag> webGl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解下Three.js</title>
      <link href="/blog/posts/e3a8ed0a/"/>
      <url>/blog/posts/e3a8ed0a/</url>
      
        <content type="html"><![CDATA[<blockquote><p>年初就有了学习Three.JS的想法，但是拖延症犯了，一直到现在才开头。为啥要学习Three.js呢？因为OpenGL太难了，webGl同理，作为webGL的封装，Three.js应该会简单一点吧。学习新的东西总是令人兴奋的，大学的时候曾经有openGL的课程，可惜当时对编程不感兴趣，因而错过了好多，这次一定不要半途而废，目标是：用Three.js作一个简单的Html5游戏。</p></blockquote><h2 id="什么是webgl？"><a class="header-anchor" href="#什么是webgl？">¶</a>什么是webGL？</h2><p>WebGL（全写 Web Graphics Library ）是一种 3D 绘图标准，这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定， WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示 3D 场景和模型了，还能创建复杂的导航和数据视觉化。显然， WebGL 技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂 3D 结构的网站页面，甚至可以用来设计 3D 网页游戏等等。 其实要想好好了解webGL，建议还是从OpenGL开始了解。因为WebGL的技术规范继承自免费和开源的OpenGL标准。</p><p>简而言之，你可以用webGL在网页上不借助任何插件创建3D图形了。</p><h2 id="什么是three-js？"><a class="header-anchor" href="#什么是three-js？">¶</a>什么是Three.js？</h2><p>threejs是一个让用户通过javascript入手进入搭建webgl项目的类库。众所周知学习webgl需要图形学知识，而语言需要通过js和glsl两种语言。如果我们不通过threejs使用webgl势必逃不过以上这些东西，你必须全面了解着色器语法和自己编写顶点着色片元着色；但你使用了threejs显然可以便捷的逃过这些对于传统js从业人员挑战的shader编写。  ----来自逼乎<a href="https://www.zhihu.com/question/36367846?from=profile_question_card" target="_blank" rel="noopener">如何系统的学习three.js？</a></p><h2 id="入门实例"><a class="header-anchor" href="#入门实例">¶</a>入门实例</h2><p>获取Three.js代码：github地址 <a href="https://github.com/mrdoob/three.js" target="_blank" rel="noopener">https://github.com/mrdoob/three.js</a></p><p>下面是一个简单的例子<br>既然是在web里的首先要一个html文件</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;    &lt;style&gt;canvas { width: 100%; height: 100% }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--引入three.js代码--&gt;    &lt;script src=&quot;https://raw.github.com/mrdoob/three.js/master/build/three.js&quot;&gt;&lt;/script&gt;    &lt;!--引入事例代码--&gt;    &lt;script src=&quot;demo.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后是js代码</p><pre><code class="language-javascript">        var scene = new THREE.Scene();                var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);                var renderer = new THREE.WebGLRenderer();                renderer.setSize(window.innerWidth, window.innerHeight);                document.body.appendChild(renderer.domElement);        var geometry = new THREE.CubeGeometry(1,1,1);        var material = new THREE.MeshBasicMaterial({color: 0x00ff00});        var cube = new THREE.Mesh(geometry, material);         scene.add(cube);        camera.position.z = 5;        function render() {            requestAnimationFrame(render);            cube.rotation.x += 0.1;            cube.rotation.y += 0.1;            renderer.render(scene, camera);        }        render();</code></pre><p>效果就是屏幕里出现了一个立方体。。。</p><p>虽然很简单，但是已经包括了three.js基本需要的对象了。<br>分别是：<br><em>场景（scene）、相机（camera）和渲染器（renderer）</em><br>有了这三样，就可以把物体渲染到网页里了。当然这只是简单的介绍，其实场景里还要有模型，光源；相机还要有位置，投影方式，视线等；但是现在先不介绍，以后会一一详细说明。</p><p>场景：<code>var scene = new THREE.Scene();</code><br>场景可以看作是一个容器，你想加点什么东西，都是加到场景里面去。比如加入一个box，这个box实际上就是一个模型，模型由几何体和材质构成</p><pre><code class="language-javascript">var geometry = new THREE.CubeGeometry(1,1,1);//这是集合体var material = new THREE.MeshBasicMaterial({color: 0x00ff00});//这是材质var cube = new THREE.Mesh(geometry, material); </code></pre><p>用过unity3D的人应该很熟悉材质了。</p><p>相机：<code>var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);</code></p><p>这是创建相机，可以把相机看作我们眼睛所在的位置。场景只有一种，但是相机却又很多种。和现实中一样，不同的相机确定了呈相的各个方面。比如有的相机适合人像，有的相机适合风景，专业的摄影师根据实际用途不一样，选择不同的相机。对程序员来说，只要设置不同的相机参数，就能够让相机产生不一样的效果。上面我们用的是透视相机。</p><p>渲染器：<code>var renderer = new THREE.WebGLRenderer();</code></p><p>最后一步就是设置渲染器，渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制。<br>渲染有两种方式：实时渲染和离线渲染 。</p><p>实时渲染：就是需要不停的对画面进行渲染，即使画面中什么也没有改变，也需要重新渲染。下面就是一个渲染循环：</p><pre><code class="language-javascript">function render() {    cube.rotation.x += 0.1;    cube.rotation.y += 0.1;    renderer.render(scene, camera);    requestAnimationFrame(render);}</code></pre><p>其中一个重要的函数是requestAnimationFrame，这个函数就是让浏览器去执行一次参数中的函数，这样通过上面render中调用requestAnimationFrame()函数，requestAnimationFrame()函数又让rander()再执行一次，就形成了我们通常所说的游戏循环了。</p><p>参考：<br><a href="http://www.hewebgl.com/article/getarticle/50" target="_blank" rel="noopener">webGl中文网</a></p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
            <tag> webGl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是事件冒泡和事件委托</title>
      <link href="/blog/posts/ae7587e9/"/>
      <url>/blog/posts/ae7587e9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自从有了javaScript这个浏览器端的脚本语言，用户们终于可以告别单调的展示网页了，javaScript给网页带来了新的生命力，网页前端从此变得有趣起来，最主要的，网页上的元素有了事件这个元素，但是关于事件，就不得不提事件冒泡和事件委托这两个关键的知识点。</p></blockquote><h2 id="什么是事件？"><a class="header-anchor" href="#什么是事件？">¶</a>什么是事件？</h2><p>JavaScript与html之间的交互全部都是由事件实现的。事件就是你操作鼠标或者键盘，对网页进行交互，比如你点击一个按钮，就触发了一个<code>onClick</code>事件，你改变input节点内的<code>value</code>,就出发了<code>onChange</code>事件。</p><h2 id="事件流和事件冒泡"><a class="header-anchor" href="#事件流和事件冒泡">¶</a>事件流和事件冒泡</h2><p>你可以把网页想象成几个同心圆，当你点击最中心的圆的时候，也相当与点击外层的几个圆了，所以说，当你点击页面上的一个按钮，就相当于点击了整张页面，会触发这个按钮的所有父节点的click事件，这个就是事件流。但是当时ie和其他的浏览器偏偏要不一样，ie支持的是冒泡流，而网景提出的是捕获流，后来，在w3c组织的统一下，js支持冒泡流和捕获流，但是呢，某些低版本的浏览器（ie6,ie7,ie8）却只支持冒泡流。直接用onClick就是在冒泡阶段添加事件。</p><pre><code>&lt;div in=&quot;outer&quot;&gt;    &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>对于事件捕获来说，是从外到内的，点击#inner的div，会从window开始捕获，然后是document,html,…,一直到#outer，再到#inner。<br>对于事件冒泡来说，是从内到外的，点击#inner的div，会从#inner开始，到#outer，…，最后是window。</p><p>dom事件流分为三个阶段<br>1.事件捕获。<br>2.处于目标阶段。<br>3.事件冒泡。</p><p>可以分别给dom元素添加事件流事件</p><pre><code>document.addEventListener('click',function(){            console.log('document处于事件捕获阶段');        }, true);// true是捕获阶段，false是冒泡阶段。</code></pre><p>问题来了，如果不想事件冒泡怎么办？我们点击子节点，不想触发父节点的事件。可以这样做：</p><pre><code>stopPropagation() 方法终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。调用该方法后，该节点上处理该事件的处理程序将被调用，事件不再被分派到其他节点。</code></pre><h2 id="事件委托"><a class="header-anchor" href="#事件委托">¶</a>事件委托</h2><p>先说下event对象，这个对象会作为事件的默认参数。<br>api：</p><pre><code>bubbles返回布尔值，指示事件是否是起泡事件类型。cancelable返回布尔值，指示事件是否可拥可取消的默认动作。currentTarget返回其事件监听器触发该事件的元素。eventPhase返回事件传播的当前阶段。target返回触发此事件的元素（事件的目标节点）。timeStamp返回事件生成的日期和时间。type返回当前 Event 对象表示的事件的名称。</code></pre><p>为啥要进行事件委托，我们都知道dom操作是很花费时间的。与dom节点交互，访问dom节点，非常影响性能。比如要给<code>ul</code>下的<code>li</code>都添加上click事件，最简单的方法，写个for循环，挨个click就行了，但是这样要多次操纵dom节点。利用事件委托的方式，把<code>click</code>事件绑定到<code>ul</code>上，因为事件冒泡的存在，会触发<code>ul</code>的<code>click</code>事件，而且就一次dom操作，那怎么判断点击的是哪一个li呢？这时候上面的event对象就起作用了，event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement。<br>这时候我们就拿到了具体点击的dom节点，然后用nodeName获取节点名，在函数内部判断下，就实现把dom操作放在js代码内部来实现了。<br>而且这样做还有一点好处就是，新添加的<code>li</code>标签不会点击无效，如果直接把事件绑定在<code>li</code>上，每添加<code>li</code>都要重新绑定事件。</p><pre><code>&lt;ul id=&quot;ul&quot;&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;window.onload = function(){    　　var oUl = document.getElementById(&quot;ul&quot;);    　　oUl.onclick = function(ev){    　　　　var ev = ev || window.event;   　　　　var target = ev.target || ev.srcElement;        　　　　if(target.nodeName.toLowerCase() == 'li'){        　 　　　　　　alert(123);　　　　　　　  alert(target.innerHTML);　　　　}    　　}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react组件编写非最佳实践</title>
      <link href="/blog/posts/3705f364/"/>
      <url>/blog/posts/3705f364/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果问我2018年最想掌握的东西是什么，第一个是webgl，第二个就是react.js全家桶了。之前也写了一些demo，也不经意间总结了一些东西，可能不是最好的写法，在这里做一些记录。</p></blockquote><h2 id="语法篇"><a class="header-anchor" href="#语法篇">¶</a>语法篇</h2><p>1 灵活使用箭头函数<br>在给组件绑定类似<code>onClick</code>事件的时候,组件内定义的函数里面的this在执行的时候会变成全局，但是es6默认严格模式不允许全局，因此一般会用<code>bind</code>函数绑定this，当然，用箭头函数更简单，因为箭头函数会继承上下文的this。</p><p>2 多用三目表达式和逻辑符号<br>因为jsx语法不支持写if语句,但是我们可以用三目表达式来代替<br><code>{a?&lt;A/&gt;:&lt;B/&gt;}</code><br>但是有时候我们只用判断一次,不需要false情况下做处理，可以用逻辑与<br><code>!!a&amp;&amp;&lt;A/&gt;</code></p><p>3 利用解构赋值解决props过长导致的代码量过大<br>es6 里面在赋值新增加了解构赋值的语法，用起来很方便，例如：<br><code>let [a, b, c] = [1, 2, 3];</code><br><code>let {a,b,c} = {4,5};\\ c的值是undefined</code><br>在组件里面可以<br><code>const {id,name,title,time} = this.props</code><br>这样可以节约很多代码。</p><p>4 用SFC（Stateless Functional Component）代替一般的纯组件的class写法</p><p>sfc就是这样的代码：</p><pre><code class="language-javascript">const _handleClick(suggestedUrl, onClick, event) =&gt; {  event.preventDefault();};const RelatedSearch = ({ relatedQueries, onClick }) =&gt;  &lt;section className=&quot;related-search-container&quot;&gt;    &lt;h1 className=&quot;related-search-title&quot;&gt;Related Searches:&lt;/h1&gt;    &lt;Layout x-small={2} small={3} medium={4} padded={true}&gt;      {relatedQueries.map((query, index) =&gt;        &lt;Link          className=&quot;related-search-link&quot;          onClick={(event) =&gt;            _handleClick(query.searchQuery, onClick, event)}          key={index}&gt;          {query.searchText}        &lt;/Link&gt;      )}    &lt;/Layout&gt;  &lt;/section&gt;export default RelatedSearch;</code></pre><p>参数就是props，这种写法比用class写法省略很多东西，没有构造函数，用箭头函数代替render(),因为现在都用redux管理状态，所以有很多纯组件，这种写法可以减少代码量。</p><h2 id="思路篇"><a class="header-anchor" href="#思路篇">¶</a>思路篇</h2><p>1 关于state和props的区别<br>props ：一般用于父组件向子组件通信，在组件之间通信使用。<br>state :  一般用于组件内部的状态维护，更新组建内部的数据，状态，更新子组件的props等。<br>所以如果是组件本身的状态,不需要用到状态管理比如redux，就用state就行了；一般情况下都是用props的。</p><p>2 尽量是用纯组件，细化组件，提高组件复用<br>状态用redux处理，因为当组件更新时，如果组件的 props 和 state 都没发生改变，render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，没状态的组件会提高性能。细化组件可以多次使用一个组件，因为react其实就像堆积木一样，组件就是每一块积木，积木越小越灵活。</p><p>3 reducer要灵活<br>首先说一点reducer是实现(state, action) -&gt; newState的纯函数，所以不能有异步操作，需要异步的话<code>yarn add react-thunk</code>，请，当然也有其他的中间件，reducer是可以嵌套的，比如有studentlist的reducer，就可以写个student的函数，处理单个student的数据，在students函数里来处理所有的student的数据。这样避免单个reducer太长，逻辑混杂很难看的。reducer的编写比起组件来说要复杂一点我觉得，写法上也很考验js水平。关于reducer有文章可以参考<a href="https://www.jianshu.com/p/938f8121ba0f" target="_blank" rel="noopener">Reducer 最佳实践，Redux 开发最重要的部分</a>。</p><p>未完待续–还要讲的有高阶组件，中间件，异步操作等。</p>]]></content>
      
      
      <categories>
          
          <category> javaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你真的会用搜索引擎吗？</title>
      <link href="/blog/posts/c475ea5/"/>
      <url>/blog/posts/c475ea5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天,地球上不同国家的人们都会使用到搜索引擎,或许用来了解新事物,或许用来查找资料文件,当然也有用来下载盗版电影或者游戏的。相信读者可能会对本篇标题不屑一顾,百度一下嘛,谁不会啊？但是,那些高级的搜索技巧你却不一定知道。</p></blockquote><h2 id="选择合适的搜索引擎"><a class="header-anchor" href="#选择合适的搜索引擎">¶</a>选择合适的搜索引擎</h2><p>先说一下为啥我不用百度,不单单是因为“魏泽西事件”,一开始我也会依赖百度的,自从我接触到google后,慢慢的就习惯用google了,为什么不用百度了呢？原因有一下几点：<br>1.搜索结果阉割严重（构建和谐社会必要条件,你懂得）<br>2.因为“gfw”的存在,被墙的网站搜不出来,其中可能包括一些技术站点<br>3.对洋文的收录太少了,不得不承认,在技术上,洋文站点往往更新更全<br>4.百度本身的弊端,烂的不行的百度知道,坑人的竞价排名</p><p>所以,我就抛弃百度,改用google了,但是你知道的,google现在在墙内无法访问,但也不是毫无办法,只要你花费一点时间,就可以突破&quot;gwf&quot;,拥抱freedom了,具体方法不在本文讨论内容里,但是我可以提过一些关键词----“赛风”,“tor”,“lantern”,“自由门”,“vpn”,大部分我都用过,现在正在用&quot;lantern&quot;,如果你有需求,可以用这个软件,具体内容在另外一篇博文里有。</p><h2 id="搜索技巧"><a class="header-anchor" href="#搜索技巧">¶</a>搜索技巧</h2><p>既然说到了google,就介绍一下几个常用的搜索技巧吧！</p><p>1.巧用“与”和“或”<br>“与”很简单，你输入多个关键词,默认情况下,就是与的关系。只有网页同时包含这些关键词,才会被抓取到。<br>“或” 就是在关键词之间加上大写的OR，比如 <code>关键词1 OR 关键词2</code>这样只要包含任一关键词,都可以被搜索到。</p><p>2.关键词排列<br>比如你想搜索美国苹果,但是可能会搜索到网页的开头是美国,结尾是苹果的页面,很明显,这个不是你真正要查的东西。这时候,你用<code>&quot;美国苹果&quot;</code>,就能搜到真正的美国苹果了。</p><p>3.google hacking<br>这一部分比较多,但是功能非常强大。</p><ul><li>只搜索某个网站的内容  <code>site:example.com</code> ，也可以site:.com，这样,就只会搜到.com域名的网站了。</li><li>限定文件格式  <code>关键词 filetype:[filetype]</code>,filetype可以是pdf,xlsx,doc等文件格式。</li><li>限定标题内容 <code>intitle:关键词</code>,这样,只有标题里面含关键词的才会被搜索出来。</li><li>限定网页正文 <code>intext:关键词</code>或者<code>allintext:关键词</code>,关键词只有在网页正文中。</li><li>限定网页url <code>inurl:关键词</code>，举个栗子,<code>inurl:id=1</code>,很多php站点在这里可以尝试sql注入脱库。<code>inurl:login</code>可以找到一些后台管理的登录页面。</li><li>模糊搜索同义词 <code>~关键词</code>,google可以搜到关键词的同义词的页面。</li><li>通配符 <code>*</code> 你可以用星号 * 指代任何一个词汇。也可以配合上面的第二点<code>&quot;*州市&quot;</code>,猜猜可以搜到啥？</li><li>排除 <code>-</code>  紧挨着关键词之前放减号，表示排除该关键词,比如你想搜索苹果,但不是苹果手机就这样 <code>苹果 -手机</code></li></ul><p>注意：上面这些技巧可以组合使用。</p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教练,我想学webSocket</title>
      <link href="/blog/posts/9ceb5dee/"/>
      <url>/blog/posts/9ceb5dee/</url>
      
        <content type="html"><![CDATA[<blockquote><p>html5里,我最感兴趣的两个部分一个是canvas,因为可以实现在页面上画画,基于webgl的技术在未来网页游戏上一定会大放异彩,而另外一部分,就是webSocket了。<strong>但是实际上websocket不是HTML5 的东西</strong>。它是一个协议,归属于IETF。HTML5只是提供了WebSocket API ，两个规范是独立发布的。</p></blockquote><h2 id="什么是websocket-？"><a class="header-anchor" href="#什么是websocket-？">¶</a>什么是webSocket ？</h2><p>WebSocket是一种网络通讯协议,目前市面上很多网站都用到了这项技术,比如在线聊天室,在线客服系统,还有一些评论系统,WebIM等。它的特点就是：持久化,实时性,客户端和服务端双向通讯。<br>为什么需要webSocket呢？相信很多程序员都遇到过这样类似的需求----实时的显示物品的价格、股票走势的图标、网页上实现聊天等交互功能。这些需求如果用http协议,只能客户端发请求,服务端返回结果,就需要不停的&quot;轮询&quot;：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询的效率很低,并且浪费资源,需要服务器有很快的处理速度和资源。另外还有一种长连接的方式（long poll）,是阻塞式的ajax,一次请求直到有结果返回才会进行下一次请求,这种方式需要服务器高并发能力。</p><p>而WebSocket就是一个很好的解决方案。</p><h2 id="怎么做到的"><a class="header-anchor" href="#怎么做到的">¶</a>怎么做到的 ?</h2><p>WebSocket基于HTTP协议,借用HTTP的协议完成一部分握手。<br>在握手阶段是一样的。</p><p>下面是WebSocket的握手（如果你经常看htpp的包,就很容易看懂下面的东西）。</p><pre><code>GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com</code></pre><p>这里比HTTP多了几个东西</p><pre><code>Upgrade: websocketConnection: Upgrade</code></pre><p>这两行会告诉服务器：这是一个WebSocket协议,请用对应的模块处理。</p><pre><code>Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13</code></pre><p>Sec-WebSocket-Key 是一个Base64 encode的值，这个是浏览器随机生成的密文,要求服务端必须返回一个对应的加密Sec-WebSocket-Accept应答,否则客户端会抛出Error during WebSocket handshake错误，并关闭连接。<br>Sec-WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。<br>Sec-WebSocket-Version 是告诉服务器所使用的Websocket Draft(协议版本),现在都是13。</p><p>然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！</p><pre><code>HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat</code></pre><p>这样就是websocket链接成功,接下来就可以不用request和response愉快的收发数据了。<br>不同的服务端有不同语言的实现方式,而在客户端通常使用js或者其他封装库。</p><p>对比一下HTTP和WebSocket,是这样的~~</p><h3 id="http"><a class="header-anchor" href="#http">¶</a>http:</h3><p>客户端：现在比特币价格多少！<br>服务端：20000刀！<br>10s后<br>客户端：现在比特币价格多少！<br>服务端：18000刀！<br>开始轮询~~~<br>客户端：现在比特币价格多少！<br>0.5s后<br>客户端：现在比特币价格多少！<br>0.5s后<br>客户端：现在比特币价格多少！<br>服务端：19000刀<br>服务端：19000刀<br>服务端：@%#……&amp;@<em>……</em>#*（内心os:累死我了，不干了！）</p><h3 id="websocket"><a class="header-anchor" href="#websocket">¶</a>WebSocket</h3><p>奥义–websocket链接！！<br>客户端：要是比特币价格变了及时告诉我。<br>服务端：ok，没问题。<br>服务端：惊天大消息，比特币暴跌！<br>客户端：不慌不慌,继续加仓。<br>20s后<br>服务端：涨了！涨了！<br>客户端：还会再涨，加仓，拉满。</p><p>总结就是：<br>1  建立在 TCP 协议之上，服务器端的实现比较容易。<br>2  与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>3  数据格式比较轻量，性能开销小，通信高效。<br>4  可以发送文本，也可以发送二进制数据。<br>5  没有同源限制，客户端可以与任意服务器通信。<br>6  协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p><h2 id="客户端例子"><a class="header-anchor" href="#客户端例子">¶</a>客户端例子</h2><p>在客户端,webSocket使用起来很简单</p><pre><code class="language-javascript">var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);ws.onopen = function(evt) {   console.log(&quot;Connection open ...&quot;);   ws.send(&quot;Hello WebSockets!&quot;);};ws.onmessage = function(evt) {  console.log( &quot;Received Message: &quot; + evt.data);  ws.close();};ws.onclose = function(evt) {  console.log(&quot;Connection closed.&quot;);};  </code></pre><p>初中英语都能看懂是什么意思,就不解释了。<br>另外还有常用的webSocket库,<a href="http://xn--socket-hh4k.io" target="_blank" rel="noopener">如socket.io</a>。</p><h3 id="api"><a class="header-anchor" href="#api">¶</a>api:</h3><p>webSocket.readyState readyState属性返回实例对象的当前状态,0:表示正在连接;1,表示连接成功;<br>2，表示连接正在关闭;3，表示连接已经关闭，或者打开连接失败。<br>webSocket.onopen 用于指定连接成功后的回调函数。<br>webSocket.onclose 用于指定连接关闭后的回调函数。<br>webSocket.onmessage 用于指定收到服务器数据后的回调函数。<br>webSocket.send() 用于向服务器发送数据。<br>webSocket.bufferedAmount 表示还有多少字节的二进制数据没有发送出去。<br>webSocket.onerror  用于指定报错时的回调函数。<br>以上api仅简单介绍。详情参照官方<br><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">文档</a></strong></p><h2 id="服务端"><a class="header-anchor" href="#服务端">¶</a>服务端</h2><p>基本上支持网络编程的语言都可以创建webSocket服务,比如java,php,python,node等，网上都有解决方案。<br>下面是用python写的服务端代码,只用到了一些网络模块,方便熟悉webSocket协议内容和步骤</p><pre><code class="language-python">import simplejsonimport socketimport sysimport base64import hashlibimport timeHOST = '127.0.0.1'PORT = 9000MAGIC_STRING = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'HANDSHAKE_STRING = &quot;HTTP/1.1 101 Switching Protocols\r\n&quot; \    &quot;Upgrade:WebSocket\r\n&quot; \    &quot;Connection: Upgrade\r\n&quot; \    &quot;Sec-WebSocket-Accept: {1}\r\n&quot; \    &quot;WebSocket-Location: ws://{2}/chat\r\n&quot; \    &quot;WebSocket-Protocol:chat\r\n\r\n&quot;def parse_data(msg):    v = ord(msg[1]) &amp; 0x7f    if v == 0x7e:        p = 4    elif v == 0x7f:        p = 10    else:        p = 2    mask = msg[p:p+4]    data = msg[p+4:]    return ''.join([chr(ord(v) ^ ord(mask[k%4])) for k, v in enumerate(data)])def start():    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    try:        sock.bind((HOST, PORT))        sock.listen(100)    except Exception as e:        print('bind error')        print(e)        sys.exit()    while True:        conn, add = sock.accept()        try:            handshake(conn)        finally:            print('finally')            conn.close()    sock.close()    passdef handshake(conn):    headers = {}    shake = conn.recv(1024)    print shake    if not len(shake):        print('len error')        return False    header, data = shake.split('\r\n\r\n', 1)    for line in header.split('\r\n')[1:]:        key, value = line.split(': ', 1)        headers[key] = value    if 'Sec-WebSocket-Key' not in headers:        print('this is not websocket, client close.')        print headers        conn.close()        return False    sec_key = headers['Sec-WebSocket-Key']    res_key = base64.b64encode(hashlib.sha1(sec_key + MAGIC_STRING).digest())    str_handshke = HANDSHAKE_STRING.replace('{1}', res_key).replace('{2}', HOST + &quot;:&quot; + str(PORT))    print str_handshke    conn.send(str_handshke)    time.sleep(1)    conn.send('%c%c%s' % (0x81, 6, 'suren1'))    msg = conn.recv(1024)    msg = parse_data(msg)    print('msg : ' + msg)    time.sleep(1)    conn.send('%c%c%s' % (0x81, 6, 'suren2'))    msg = conn.recv(1024)    msg = parse_data(msg)    print('msg : ' + msg)    time.sleep(1)    conn.send('%c%c%s' % (0x81, 6, 'suren3'))    msg = conn.recv(1024)    msg = parse_data(msg)    print('msg : ' + msg)    return True    passif __name__ == '__main__':    try:        start()    except Exception as e:        print(e)</code></pre><p>参考：<br>（1）<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a><br>（2）<a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">知乎–WebSocket 是什么原理？为什么可以实现持久连接？</a><br>（3）<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">webApi接口|mdn</a></p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript柯里化</title>
      <link href="/blog/posts/2b34be88/"/>
      <url>/blog/posts/2b34be88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直对函数式编程非常感兴趣，因此时常会留意下关于函数式编程的概念，之前一直听到柯里化，但是只闻其名，知道他可以接受一个函数，并且返回值也是函数，返回的函数可以继续接受参数运算，直到出发原始函数的执行条件，并没有认真研究，今天就花点时间好好研究下，看看如何写出符合柯里化（curry）的函数，</p></blockquote><h3 id="什么是柯里化？"><a class="header-anchor" href="#什么是柯里化？">¶</a>什么是柯里化？</h3><p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p><blockquote><p>柯里化允许我们把函数与传递给它的参数结合，产生一个新的函数。[引自《JavaScript语言精髓》，第43页 柯里化]</p></blockquote><p>通俗一点，就是之前的函数是这样的</p><pre><code class="language-javascript">function add(x,y) {return x+y;}</code></pre><p>而柯里化后</p><pre><code class="language-javascript">var curryAdd = curry(add)</code></pre><p>要计算的时候，就是</p><pre><code class="language-javascript">cuurryAdd(1)(2)</code></pre><p>看上去很不错吧，在函数式编程里面，简化了代码的复杂性，代码量变小，看起来更加优雅，可以达到延迟计算的方法，不断传入参数，最后执行；另外，根据网上的说法:</p><blockquote><p>函数柯里化允许和鼓励你分隔复杂功能变成更小更容易分析的部分。这些小的逻辑单元显然是更容易理解和测试的，然后你的应用就会变成干净而整洁的组合，由一些小单元组成的组合。</p></blockquote><p>关于这一点，我还在自己品味。是不是可以省略多参函数的参数，带入具体的函数以提供更细分的方法调用？</p><h3 id="通用的柯里化方法："><a class="header-anchor" href="#通用的柯里化方法：">¶</a>通用的柯里化方法：</h3><p>[代码引自《JavaScript: Novice to Ninja》，第319页 A General Curry Function]</p><pre><code class="language-javascript">function curry(func) {  var fixedArgs = [].slice.call(arguments,1);  return function() {    args = fixedArgs.concat([].slice.call(arguments))    return func.apply(null, args);  };}</code></pre><p>运行方法：</p><pre><code class="language-javascript">function divider(x,y) {  return x/y;}reciprocal = curry(divider,1);reciprocal(2);</code></pre><p>执行reciprocal(2)相当于执行curry(divider,1)(2)。然后看curry方法通过[].slice方法去掉了传入的第一个参数，即function divider(x,y) {return x/y;}，之后保留了变量x=1并返回一个新的函数，这是一个匿名函数，同时传入变量y=2，这时fixedArgs.concat([].slice.call(arguments))将之前传入的变量x和现在传入的变量y重新组合成一个数组，最后执行函数divider，这时使用的参数是组合后的[1,2]。整个curry方法主要工作就是组织两次传入的参数，然后通过apply方式调用函数。</p><p>最后，如果利用es6的新特性的话，就可以一行写出一个柯里化函数</p><pre><code class="language-javascript">var currySingle = fn =&gt; ((limit) =&gt; judgeCurry = (...args) =&gt; args.length &gt;= limit ? fn.apply(null, args) : (...args2) =&gt; judgeCurry.apply(null, args.concat(args2)))(fn.length)</code></pre><p>摘自[一行写出javascript函数式编程中的curry] <a href="https://segmentfault.com/a/1190000008248646" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008248646</a></p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react脚手架</title>
      <link href="/blog/posts/773e1506/"/>
      <url>/blog/posts/773e1506/</url>
      
        <content type="html"><![CDATA[<blockquote><p>react是facebook工程师制作的一款web框架，一开始只是单纯得得得ui框架，但是因为它的架构很不错，用起来很爽，于是就开源了，现在，react是最热门的前端框架，业内人士甚至预测他将来会颠覆webapp现有技术，基于react的react-native在发布的第一天就收获了5000颗star,可见它的未来不可限量。</p></blockquote><p><a href="http://ot5267s9k.bkt.clouddn.com/v2-d6281f9eae238597d7c3eef15171d4fa_hd.jpg" title="老夫就用jquery!" target="_blank" rel="noopener"><img src="http://ot5267s9k.bkt.clouddn.com/v2-d6281f9eae238597d7c3eef15171d4fa_hd.jpg" alt="老夫就用jquery!" title="老夫就用jquery!"></a></p><h3 id="先说说webpack"><a class="header-anchor" href="#先说说webpack">¶</a>先说说webpack</h3><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。<br>几个比较好的教程：<br><a href="http://www.jianshu.com/p/42e11515c10f" title="入门webpack，看这篇就够了。" target="_blank" rel="noopener">入门webpack，看这篇就够了。</a><br><a href="http://www.jianshu.com/p/b95bbcfc590d" title="wwebpack简明学习教程" target="_blank" rel="noopener">webpack简明学习教程</a></p><p><strong>总结：纸上得来终觉浅 绝知此事要躬行</strong></p><h3 id="再说说create-react-app"><a class="header-anchor" href="#再说说create-react-app">¶</a>再说说create-react-app</h3><p>create-react-app是来自于Facebook出品的零配置命令行工具，能够帮你自动创建基于Webpack+ES6的最简易的React项目模板，有助于初学者快速上手实践。安装create-react-app的方式也非常简单，可以直接使用npm命令进行全局安装。</p><pre><code class="language-shell">    npm install -g create-react-app        create-react-app my-app    cd my-app/    npm start</code></pre><p>执行完上述命令之后，你可以直接打开http://localhost:3000， 即可以看到运行效果。此时也是处于开发模式下。</p><p>项目的结构如下：<br><a href="http://ot5267s9k.bkt.clouddn.com/webappreact.PNG" title="结构" target="_blank" rel="noopener"><img src="http://ot5267s9k.bkt.clouddn.com/webappreact.PNG" alt="结构" title="结构"></a></p><p>如果你要进行发布，则使用npm run build进行编译。编译后，项目目录下会出现一个build目录，就是编译完的项目。</p><p>划重点了，怎么看不到webpack的配置文件啊？？？<br>原来为了“优雅”，脚手架隐藏了所有的webpack的配置文件，需要执行下面的命令：</p><p><code>npm run eject</code></p><p>再看项目目录是不是所有的配置文件都有了。</p><p>fackbook给所有的配置都写了详细的注释，英文好的同学可以参考学习一下。</p><p>不过不看配置，也可以直接在app.js 里修改代码，看一下页面的变化，体会一下webpack热部署，打包，构建的方便之处，练习一下react的基础语法，也是不错的。</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue.js实例分析</title>
      <link href="/blog/posts/7008012c/"/>
      <url>/blog/posts/7008012c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从一开始用原生javascript，到用jQuery,backbone.js,来实现前端的各种功能，越来越体会到使用框架是多么重要的一件事,那些杂乱，各种写法混杂，业务和ui逻辑写在一起的js脚本,维护起来简直是噩梦😱。</p></blockquote><p>还好现在有很多mvc，mvvm框架，掌握了这些，前端模块化就轻松多了,之前公司用的是backbone.js,但是所有逻辑基本都是在view层实现，并且bacjbone.js数据是单向绑定,功能实现往往需要频繁的手动render渲染,自己水平有限，有时太复杂的逻辑，写起来也感觉自己写的特别啰嗦。最近看了vue.js的官网，通读了起步文档,大致了解了vue，但是具体实现自己写起来还是没有头绪，所以现在开始看vue实例，一点一点分析。</p><p><strong>Talk is cheap,Show me the code!</strong></p><h3 id="实例分析："><a class="header-anchor" href="#实例分析：">¶</a>实例分析：</h3><p>地址：<a href="https://jsfiddle.net/yyx990803/xkkbfL3L/?utm_source=website&amp;utm_medium=embed&amp;utm_campaign=xkkbfL3L" title="vue 网格组件" target="_blank" rel="noopener">vue 网格组件</a></p><p>这是一个网格组件，可以根据某一列进行正序或者逆序排序,也可以根据input框搜索，模糊查询只显示匹配的数据。<br><a href="http://ot5267s9k.bkt.clouddn.com/imageGrid.PNG" title="截图" target="_blank" rel="noopener"><img src="http://ot5267s9k.bkt.clouddn.com/imageGrid.PNG" alt="截图" title="截图"></a><br>下面的表格是一个vue组件，两个<th>可以点击用来触发排序。</th></p><h3 id="代码："><a class="header-anchor" href="#代码：">¶</a>代码：</h3><h4 id="html"><a class="header-anchor" href="#html">¶</a>html</h4><pre><code class="language-html">&lt;!-- component template --&gt;&lt;script type=&quot;text/x-template&quot; id=&quot;grid-template&quot;&gt;  &lt;table&gt;    &lt;thead&gt;      &lt;tr&gt;        &lt;th v-for=&quot;key in columns&quot;          @click=&quot;sortBy(key)&quot;          :class=&quot;{ active: sortKey == key }&quot;&gt;          {{ key | capitalize }}          &lt;span class=&quot;arrow&quot; :class=&quot;sortOrders[key] &gt; 0 ? 'asc' : 'dsc'&quot;&gt;          &lt;/span&gt;        &lt;/th&gt;      &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;      &lt;tr v-for=&quot;entry in filteredData&quot;&gt;        &lt;td v-for=&quot;key in columns&quot;&gt;          {{entry[key]}}        &lt;/td&gt;      &lt;/tr&gt;    &lt;/tbody&gt;  &lt;/table&gt;&lt;/script&gt;&lt;!-- demo root element --&gt;&lt;div id=&quot;demo&quot;&gt;  &lt;form id=&quot;search&quot;&gt;    Search &lt;input name=&quot;query&quot; v-model=&quot;searchQuery&quot;&gt;  &lt;/form&gt;  &lt;demo-grid    :data=&quot;gridData&quot;    :columns=&quot;gridColumns&quot;    :filter-key=&quot;searchQuery&quot;&gt;  &lt;/demo-grid&gt;&lt;/div&gt;</code></pre><p>上方是组件的模板<br>sortKey是排序的关键字（那一列），sortOrders这个数组储存的是正序还是逆序。这两个用来控制class样式 <code>：class</code> 是<code>v-bind:class</code>.<br>下面是实例部分, 通过props 属性将数据传入组件demo-grid。data是要展示的数据，filter-key是查询参数，columns是每一行的数据的key组成得数组。<br>js部分</p><pre><code class="language-javascript">// register the grid component  Vue.component('demo-grid', {    template: '#grid-template',    props: {//props可以通过组件的属性从父组件传递。      data: Array,//要展示的对象数组      columns: Array,//每一行的对象的key组成的数组，用来便利对象的时候取值用      filterKey: String//查询参数    },    data: function () {//组件数据,需要在模板里用到，来控制样式      var sortOrders = {}      this.columns.forEach(function (key) {        sortOrders[key] = 1  //用数组储存两个排序参数的正逆序（1，-1）      })      return {        sortKey: '',//判断排序参数匹配        sortOrders: sortOrders//判断正序还是逆序。      }    },    computed: {//计算属性      filteredData: function () {        var sortKey = this.sortKey        var filterKey = this.filterKey &amp;&amp; this.filterKey.toLowerCase()        var order = this.sortOrders[sortKey] || 1 //默认是正序        var data = this.data        if (filterKey) {//根据查询参数,得到匹配数据          data = data.filter(function (row) {            return Object.keys(row).some(function (key) {              return String(row[key]).toLowerCase().indexOf(filterKey) &gt; -1            })          })        }        if (sortKey) {//根据排序参数排序          data = data.slice().sort(function (a, b) {//排序方法参照splice和sort，可以到w3c看一下。a,b分别是相邻的两个元素            a = a[sortKey]            b = b[sortKey]            return (a === b ? 0 : a &gt; b ? 1 : -1) * order //order用来控制排序方式          })        }        return data      }    },    filters: {// 渲染过滤器,语法 {{ text|filter }}      capitalize: function (str) {//首字母大写过滤器        return str.charAt(0).toUpperCase() + str.slice(1)      }    },    methods: {//绑定的点击函数,这里就体检了数据绑定的意义,改变model，model也变化也体现在页面上,避免手动管理渲染      sortBy: function (key) {        this.sortKey = key  //排序参赋值        this.sortOrders[key] = this.sortOrders[key] * -1 //排序方式赋值。      }    }  })    // bootstrap the demo  var demo = new Vue({    el: '#demo',    data: {      searchQuery: '',      gridColumns: ['name', 'power'],      gridData: [        { name: 'Chuck Norris', power: Infinity },        { name: 'Bruce Lee', power: 9000 },        { name: 'Jackie Chan', power: 7000 },        { name: 'Jet Li', power: 8000 }      ]    }  })</code></pre><p>上面是具体的实现注释,其实不是很难理解,主要是要明白<br>1️⃣.vue是基于双向数据绑定,改变model会同时反映到页面上。<br>2️⃣.灵活运用数据结构,来储蓄需要的数据。<br>3️⃣.用函数式的编码技巧，比如map，filter,some 函数处理集合，代码逻辑更加清晰。</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript编码技巧</title>
      <link href="/blog/posts/6cf112d6/"/>
      <url>/blog/posts/6cf112d6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在平时的工作中，一些前端的工作，经常要用的到javaScript，而且现在自己正在学习react.js和node.js,所以现在把自己平时遇到的写代码猜到的一些坑记录下来，此篇文章会随时更新。</p></blockquote><hr><h1>1. 避免TypeError异常</h1><p>有时从后台取到的json对象，里面某个属性可能不存在，就会返回undefined,比如</p><pre><code class="language-javascript">    var cat = {name: &quot;mm&quot;}    cat.color //undefinedd    cat.color.code // 报异常TypeError （去拿颜色代码）    //可以用下面的代码    var code = cat.color &amp;&amp; cat.color.code // &amp;&amp; 具有短路功能,前面是false就不去执行后面的,前面是true，得到后面的值</code></pre><h1>2. 高阶函数的使用</h1><p>把函数作为参数传入，这样的函数称为高阶函数.<br>高阶函数英文叫Higher-order function。 对于结集合的操作，遍历做一些操作，用高阶函数很简洁也可以写成链式语法。</p><p><code>map</code></p><pre><code class="language-javascript">var l = [1,2,3,4,5,6,7]l = l.map(v =&gt; v*v)[1, 4, 9, 16, 25, 36, 49]</code></pre><p><strong>map就是对集合里每一个元素进行操作,比如求每一个元素的平方。</strong></p><p><code>filter</code></p><pre><code class="language-javascript">var l = [1,2,3,4,5,6];l = l.filter(v =&gt; v%2 === 0);[2, 4, 6]</code></pre><p><strong>filter过滤出集合重符合某些条件的元素，得到这些元素组成的新的集合。</strong></p><p><code>every</code></p><pre><code class="language-javascript">var l = [1,2,3,4,5,6,7,8]l.every(v =&gt; v&lt;3)false</code></pre><p><strong>every 对每个元素执行操作，全部为true，就返回true，有一个false就返回false,它只对数组中的非空元素执行指定的函数，没有赋值或者已经删除的元素将被忽略.用来判断集合是不是每一个都符合筛选条件。</strong></p><p><code>some</code><br><strong>类似上面的every，它只要有一个符合就返回true,用来判断集合内有没有符合条件的元素。</strong></p><p><code>reduce</code></p><pre><code class="language-javascript">var numbers = [65, 44, 12, 4]; function getSum(total, num) {    return total + num;}function myFunction(item) {    document.getElementById(&quot;demo&quot;).innerHTML = numbers.reduce(getSum);}</code></pre><p>这个函数：<br><code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>total</td><td>必需。初始值, 或者计算结束后的返回值。</td></tr><tr><td>currentValue</td><td>必需。当前元素</td></tr><tr><td>currentIndex</td><td>可选。当前元素的索引</td></tr><tr><td>arr</td><td>可选。当前元素所属的数组对象。</td></tr></tbody></table><p><strong>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终为一个值，是ES5中新增的又一个数组逐项处理方法</strong></p><p>注意 sort函数：<br><code>arr.sort()</code> 默认情况下是用unicode 码来排序，也可以传入一个返回值为&quot;数值&quot;的函数:</p><pre><code class="language-javascript">function compare(a,b){    return a-b;}</code></pre><p>因此，如果不能直接减的变量，要先判断大小，在返回（-1，1,0）等数值。</p><h1>3.特殊的技巧</h1><p>js是一个很神奇的编程语言，有各种骚操作，下面举几个例子：</p><p>向下取整<br><code>var a = ~~1.3;//1</code></p><p>转数字<br><code>var a = +&quot;22&quot;;//22</code></p><p>日期转数字<br><code>var date = +new Date()</code></p><p>设置默认值<br><code>var b = &quot;cat&quot;||&quot;default&quot;</code>;</p><p>类数组对象转成数组<br><code>var arr = Array.prototype.slice.call(arguments)</code></p><p>漂亮的随机码</p><pre><code>Math.random().toString(16).substring(2); //14位Math.random().toString(36).substring(2); //11位</code></pre><p>交换值<br><code>a= [b, b=a][0];</code></p><p>匿名函数立即执行，可以避免全局变量的污染</p><pre><code>(function(){ //code here})();</code></pre><p>怎么在手机上调试js代码?<br>这里推荐以下 微信 团队做的 js调试利器–vconsole.<br><code>npm install vconsole</code><br>或者</p><pre><code class="language-javascript">&lt;script src=&quot;path/to/vconsole.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  // init vConsole  var vConsole = new VConsole();  console.log('Hello world');&lt;/script&gt; </code></pre><h2 id="4-编程习惯"><a class="header-anchor" href="#4-编程习惯">¶</a>4.编程习惯</h2><p><code>if else</code><br>不要小看<code>if else</code> 语句，尤其是在有异常处理的时候。<br>有些同学喜欢这样写</p><pre><code class="language-javascript">if(/*条件*/){    //正常逻辑}else{    //出错的时候处理}</code></pre><p>这样很容易忽略错误的条件,改成这样</p><pre><code class="language-javascript">if(/*出错的条件*/){    // 对错误处理}//正常逻辑</code></pre><p>这样就很清晰了。突出错误的条件，就会避免这些不合法的输入。</p><p>变量的初始化<br><code>var a = &quot;&quot;;</code><br><code>var b = [];</code><br><code>var c= {};</code><br>直接用字面表达展示数据类型,避免用new 操作符。</p><p>简单的技巧提高网页函数复用<br>我曾看到过长达两百多行的javascript函数，只是为了处理页面上的一个点击事件，其实有个很简单的范式，一个函数用来处理事件，接受事件，另外一个函数用来处理业务，参数来自上个函数。这样一般情况下就会提高函数复用。</p><p>声明局部变量<br>每一个js函数都会带有一个叫做[[Scope]]的内部属性，也就是该函数的作用域链，它决定了哪些数据能被函数访问。<br>一个函数若要使用一个变量，它会从最近的地方，也就是定义在函数内部的局部变量里面去找；若没有找到，则往更远处的全局变量（或者上一级作用域）里面去找。恰恰是这个“找”的过程，产生了性能的问题。 因此，可以把一个较深的变量赋值给一个局部变量，在函数内部直接调用这个局部变量来提升性能。</p><p>使用jquery选择器的时候,把选到的jquery对象缓存到一个变量里,避免每次使用到这个元素都重新查询。<br>如：</p><pre><code class="language-javascript">var $input = $(&quot;input&quot;);</code></pre><h2 id="none"><a class="header-anchor" href="#none">¶</a></h2>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>processing-小白也可以做艺术家</title>
      <link href="/blog/posts/e318f551/"/>
      <url>/blog/posts/e318f551/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对于非计算机专业的人来说，为了做计算机图形而去学习opencv，学习opengl，会是一件很漫长而且艰难的经历，首先你要有最少一门语言基础，c++，python都可以，掌握这些就要花很长的时间，如果你只是想像用草稿纸一样画图，不要去关心一条直线是怎么一个一个像素生成的，也不关心图形学中有多少种曲线的生成方式，你只是想画点可能会很cool的图像，processing很适合你。</p></blockquote><h2 id="processing简介"><a class="header-anchor" href="#processing简介">¶</a>processing简介</h2><p>Processing是一种具有革命前瞻性的新兴计算机语言，它的概念是在电子艺术的环境下介绍程序语言，并将电子艺术的概念介绍给程序设计师。它是 Java 语言的延伸，并支持许多现有的 Java 语言架构，不过在语法 (syntax) 上简易许多，并具有许多贴心及人性化的设计。Processing 可以在 Windows、MAC OS X、MAC OS 9 、Linux 等操作系统上使用。目前最新版本为Processing 3。以 Processing 完成的作品可在个人本机端作用，或以Java Applets 的模式外输至网络上发布。 虽然图形用户界面(GUI)早在二十年前成为主流，但是基础编程语言的教学到今天仍是以命令行接口为主，学习编程语言为什么要那么枯燥呢？人脑天生擅长空间辨识，图形用户界面利用的正是这种优势，加上它能提供各种实时且鲜明的图像式反馈 (feedback)，可以大幅缩短学习曲线，并帮助理解抽象逻辑法则。举例来说，计算机屏幕上的一个像素(pixel) 就是一个变量值(the value of a variable) 的可视化表现。Processing将Java的语法简化并将其运算结果“感官化”，让使用者能很快享有声光兼备的交互式多媒体作品。 Processing的源代码是开放的，和近来广受欢迎的Linux 操作系统、Mozilla浏览器、或Perl语言等一样，用户可依照自己的需要自由裁剪出最合适的使用模式。Processing的应用非常丰富，而且它们全部遵守开放源代码的规定，这样的设计大幅增加了整个社群的互动性与学习效率。 以上来自百度百科。</p><p>总而言之，学习processing会是一件有趣，不那么艰难的一件事。</p><p><a href="https://processing.org/" target="_blank" rel="noopener">processing的官网</a></p><p>下面贴几张大佬们用processing做的艺术品，希望自己也可以做出这样水平的作品出来。</p><p><img src="https://wx3.sinaimg.cn/mw1024/bca3c023gy1g1xw3d8sggj20b4069jse.jpg" alt="img"></p><p>​                                                                                                                          视频中两个酷炫图形过渡</p><p><img src="https://wx2.sinaimg.cn/mw1024/bca3c023gy1g1xw3d8nq8j20go0610tx.jpg" alt="img"></p><p>​                                                                                                                     旋转（rotate）、随机（random）</p><p><img src="https://wx1.sinaimg.cn/mw1024/bca3c023gy1g1xw3d8kbzj20go09d3ze.jpg" alt="img"></p><p>​                                                                                                                              加上颜色酷炫的随机和旋转</p><h2 id="processing-js"><a class="header-anchor" href="#processing-js">¶</a>processing.js</h2><p>processing.js是一个javascript实现的canvas绘图库,他的作用就是把processing的代码翻译成javascript代码,从而实现在浏览器里面使用processing绘图.</p><p>用法 :<br>首先下载processing.js<br>在html代码里创建<canvas>对象,他的data-processing-sources属性指向你写好的.pde代码.<br>如:</canvas></p><pre><code class="language-html">&lt;script src=&quot;processing-1.3.6.min.js&quot;&gt;&lt;/script&gt; &lt;canvas data-processing-sources=&quot;hello-web.pde&quot;&gt;&lt;/canvas&gt;</code></pre><p>最后,canvas里就出现了你在.pde里绘制的图像了。</p><p>下面介绍<code>youtube</code>里面一个教你用<code>processing</code>语言的频道</p><p><strong>The Coding Train</strong></p><div class="video-container"><iframe src="//www.youtube.com/embed/5N31KNgOO0g" frameborder="0" allowfullscreen></iframe></div>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>locustio</title>
      <link href="/blog/posts/638a2703/"/>
      <url>/blog/posts/638a2703/</url>
      
        <content type="html"><![CDATA[<blockquote><p>什么是locustio?<br>Locust是一个简单易用的分布式负载测试工具，主要用来对网站进行负载压力测试。基于gevent协程，可以轻松实现上千的并发量，自己定制task任务，可以模拟用户的各种行为，自带web页面，实时监控测试情况，不仅如此，loucusio还可以实现自己的客户端类，理论上可以对各种系统进行并发压力测试。</p></blockquote><p>##1.如何安装locustio</p><p>在liunx下，可以用<code>pip install locustio</code>或者<code>easy_install locustio</code>安装。<br>安装完毕后，shell里键入<code>locust --help</code>查看帮助信息。</p><p><img src="https://x1nes.github.io/img/help.png" alt="help"></p><p>##2.如何使用locustio进行压力测试<br>对于一个已经编码完成的locust测试脚本，例如：<a href="http://basic.py" target="_blank" rel="noopener">basic.py</a></p><p>执行<code>locust -f basic.py -H host</code> 进行启动</p><p><a href="http://xn--locustfile-0m4pu20c3wqx6fl3x9kqytcu9ibl3a437b2f1hx7i.py" target="_blank" rel="noopener">这里注意如果文件的名字是locustfile.py</a> ,可以省略 -f ,如果脚本里指明了host(要测试的目标地址，例如：192.168.100.199：8080),也可以省略 -H ，否则会覆盖脚本里的host.<br>如果想生成日志文件，则加上<code>-L LOGLEVEL --logfile=LOGFILE</code></p><p>启动成功后，在浏览器里输入<code>localhost:8089</code>,进入web页面，输入要模拟的并发数量和每秒增加的数量。</p><p><img src="https://x1nes.github.io/img/web.png" alt="控制页面"></p><p>##3.如何编写mqtt客户端的测试脚本</p><p>写一个locustfile,就可以进行负载测试了。</p><hr><p>对于locustio,一个用户就是一个locust(蝗虫)类，locustio里面已经实现了一个HttpLocust类，可以发送http请求对网站进行测试，一个locust类有一个client属性，而HttpLocust的client就是HttpSession的实例,而HttpSession是requests库里的类，可以用很简单的语句发送http请求。<br>需要一个user类（名字可以随便这里的user只是举个例子），继承locust类，HttpLocust类或者自己实现的locust类。这个类定义了要测试的地址host,执行任务的最小和最大时间差min_wait.max_wait（这些属性也可以定义到继承TaskSet的类里）。<br>user类还要有一个task_set属性，继承TaskSet类，定义了脚本要执行的具体任务，就是模拟用户要进行的行为（函数），推荐用@task装饰器来定义要进行的任务。里面的函数都是随机执行，根据权重的大小，执行的频率也会不同。</p><blockquote><p>下面是一个简单例子：</p></blockquote><pre><code class="language-python">from locust import HttpLocust, TaskSet, taskclass UserBehavior(TaskSet):    def login(self):        self.client.post(&quot;/login&quot;, {&quot;username&quot;:&quot;ellen_key&quot;, &quot;password&quot;:&quot;education&quot;})    @task(2)    def index(self):        self.client.get(&quot;/&quot;)class WebsiteUser(HttpLocust):    task_set = UserBehavior    min_wait=5000    max_wait=9000</code></pre><p>这里继承自TaskSet的类就是用户的行为，也可以用装饰器@task（1）这里的1是任务执行的权重，所以index 函数就是要执行的行为，权重是1。min_wait,max_wait的单位是毫秒。</p><p>为了测试mqtt服务器，这里要实现MqttClient和Mqttlocust（因为模拟的是盒子，所以取名AgentLocust,模拟盒子agent）。<br>client可以使用paho-mqtt库</p><p><code>pip install paho-matt</code><br>具体如何使用可以看paho的官方文档。<br>客户端代码</p><pre><code class="language-python">class MqttClient(mqtt.Client):def __init__(self,*args, **kwargs):    super(MqttClient,self).__init__(*args, **kwargs)def on_message(self,client, userdata, msg):    print(msg.topic+&quot; &quot;+str(msg.payload))def on_connect(self,client,userdata,flags,rc):    data = msgProcess.register(self._client_id,itemCount)    self.publish(topic=data[0], payload=data[1], qos=qos, retain = retain)    self.subscribe(topic='/at/'+str(self._client_id)+'/AID', qos=2)def on_disconnect(self,client,userdata,rc):    fire_locust_failure(    request_type = 'mqtt',    name = client,    response_time = 0,    exception = DisconnectError(&quot;disconnected&quot;),    )    self.reconnect()</code></pre><p>这里把测试云平台的“注册”行为写进了client连接的回调函数，也可以载task类里用on_start()函数实现。on_start()就是task类开始时执行的。<br>locust代码</p><pre><code class="language-python">class AgentLocust(Locust):def __init__(self,*args, **kwargs):    super(AgentLocust,self).__init__(*args, **kwargs)    if self.host is None:        raise LocustError(&quot;You must specify the base host. Either in the host attribute in the           Locust class, or on the command line using the --host option.&quot;)    try:        [host, port] = self.host.split(&quot;:&quot;)    except:        host, port = self.host, 1883    global agentIDbegin    clientID = agentIDbegin    agentIDbegin = agentIDbegin + 1    self.client = MqttClient(client_id=str(clientID), clean_session=False)    self.client.connect(host, port=port,keepalive=60)    self.client.loop_start()</code></pre><p>实现的方式是很灵活的，<a href="http://xn--locustfile-sj2p2kx7f97offp69ann4a3f2gl83i.py" target="_blank" rel="noopener">不嫌麻烦可以再写个locustfile.py</a></p><pre><code class="language-python">class AnylinkUser(AgentLocust):host = &quot;ip:port&quot;min_wait = minmax_wait = maxclass task_set(TaskSet):@task(1)def hisItemdata(self):    data = msgProcess.saveItemData(self.client._client_id,itemCount)    self.client.publish(topic=data[0], payload=data[1], qos=qos, retain = retain)</code></pre><p>以后要模拟agent的行为，在task_set里添加函数，加上@task装饰器和权重就好了，另外，task_set也支持嵌套，可以更灵活的实现用户行为。<br>为了生成topic和payload,写了根据参数生成的模块来调用：</p><pre><code class="language-python">def register(agentID,itemCount):topic = '/at/' + str(agentID) + '/[60]'msg = []msg.append('[60]&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;')//省略n行协议代码return topic,''.join(msg)def saveItemData(agentID,itemCount):topic = '/at/' + str(agentID) + '/[31]'msg = []msg.append(&quot;[31]{z:&quot;+str(agentID)+&quot;,y:[{d:&quot;+ str(agentID) +&quot;,t:$t,c:[&quot;)for i in xrange(itemCount):    msg.append(&quot;[&quot;+str(i)+&quot;,&quot;+str(random.randint(1,100))+&quot;,g],&quot;)msg.append(&quot;]}]}&quot;)msg = ''.join(msg).replace(&quot;$t&quot;,str(int(round(time.time() * 1000))))return topic,msg</code></pre><p>还有参数，放在哪里都可以只要调用方便，现在放在一个para.py模块里，直接放在locustfile.py里更简单一点。</p><pre><code class="language-python">agentIDbegin = 5999  #agentID,IncrementitemCount = 100 #每个agent的数据量qos = 0  #mqtt质量retain = False #是否是遗嘱消息min = 590000max = 610000</code></pre><p>现在，只要在locustfile目录下，执行locust -H 加上要测试的服务器就好了。然后进入web页面输入蝗虫数量和孵化率，点击start,就可以看到页面上user的数量在增加，然后去mqtt的18083端口号的页面查看连接客户端数量。</p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux sar命令</title>
      <link href="/blog/posts/aa18d564/"/>
      <url>/blog/posts/aa18d564/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天要进行服务器压力测试，用到了Linux下的sar命令。</p></blockquote><p>sar(System Activity Reporter)是Linux上最全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：系统调用的使用情况，文件的读写情况，磁盘I/O，cpu效率，内存使用情况，进程活动及IPC有关的活动等。</p><p>sar命令常用格式：<br><code>sar [option] [-A] [-o file] t [n]</code><br>其中：<br>t为采样间隔，n为采样次数，默认值为1：</p><ul><li>o file表示将命令结果以二进制格式存放在文件中，file是文件名。<br>options 是 命令行选项，常用的选项如下：<br><code>用法: sar [ 选项 ] [ &lt;时间间隔&gt; [ &lt;次数&gt; ] ] 选项: [ -A ] [ -B ] [ -b ] [ -C ] [ -d ] [ -H ] [ -h ] [ -p ] [ -q ] [ -R ] [ -r ] [ -S ] [ -t ] [ -u [ ALL ] ] [ -V ] [ -v ] [ -W ] [ -w ] [ -y ] [ -I { &lt;中断&gt; [,...] | SUM | ALL | XALL } ] [ -P { &lt;cpu&gt;[,...] | ALL } ] [ -m { &lt;关键词&gt; [,...] | ALL } ] [ -n { &lt;关键词&gt; [,...] | ALL } ] [ -j { ID | LABEL | PATH | UUID | ... } ] [ -f [ &lt;文件名&gt; ] | -o [ &lt;文件名&gt; ] | -[0-9]+ ] [ -i &lt;间隔&gt; ] [ -s [ &lt;时:分:秒&gt; ] ] [ -e [ &lt;时:分:秒&gt; ] ]&lt;/cpu&gt;</code></li></ul><p>此次用到了：<br>-u：输出CPU使用情况的统计信息<br>-b：显示I/O和传送速率的统计信息<br>-r：输出内存和交换空间的统计信息</p><p>sar -u:<br>输出项说明：<br>CPU：all 表示统计信息为所有 CPU 的平均值。</p><p>%user：显示在用户级别(application)运行使用 CPU 总时间的百分比。</p><p>%nice：显示在用户级别，用于nice操作，所占用 CPU 总时间的百分比。</p><p>%system：在核心级别(kernel)运行所使用 CPU 总时间的百分比。</p><p>%iowait：显示用于等待I/O操作占用 CPU 总时间的百分比。</p><p>%steal：管理程序(hypervisor)为另一个虚拟进程提供服务而等待虚拟 CPU 的百分比。</p><p>%idle：显示 CPU 空闲时间占用 CPU 总时间的百分比。</p><p>sar - b:<br>输出项说明：<br>tps：每秒钟物理设备的 I/O 传输总量</p><p>rtps：每秒钟从物理设备读入的数据总量</p><p>wtps：每秒钟向物理设备写入的数据总量</p><p>bread/s：每秒钟从物理设备读入的数据量，单位为 块/s</p><p>bwrtn/s：每秒钟向物理设备写入的数据量，单位为 块/s</p><p>sar -r:<br>输出项说明：<br>kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</p><p>kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</p><p>%memused：这个值是kbmemused和内存总量(不包括swap)的一个百分比.</p><p>kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.</p><p>kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</p><p>%commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.</p><p><strong>要判断系统瓶颈问题，有时需几个 sar 命令选项结合起来</strong></p><p>怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看</p><p>怀疑内存存在瓶颈，可用 sar -B、sar -r 和 sar -W 等来查看</p><p>怀疑I/O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
